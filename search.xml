<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>原笔记：Abstract Factory</title>
    <url>/2016/10/06/Abstract-factory/</url>
    <content><![CDATA[<h1>意图</h1>
<p>Abstract Factory给一类class提供了一个统一接口。Client调用接口时会得到实际起作用的那一个class的实例。
而决定哪一个class起作用的是abstract factory。这样client便与class的具体实现解耦。</p>
<!-- more  -->
<h1>应用领域</h1>
<p>-系统的实现不关心product是如何创建，组成，表示的；（系统只需要知道有这样一个product。）
-系统可以被一类product中的任意一个所配置；
-一类product的接口是相同的；（所有的类都是Abstract factory的子类）
-提供一个含有相同接口的class的库，你只想提供其接口，而不想提供它的具体实现。</p>
<h1>结构</h1>
<p>![](/images/2016/10/Abstract Factory.png)</p>
<h1>参与者</h1>
<ul>
<li>AbstractFactory</li>
<li>ConcreteFactory</li>
<li>AbstractProduct</li>
<li>ConcreteProduct</li>
<li>Client</li>
</ul>
<h1>作用过程</h1>
<p><code>client</code>调用<code>AbstractFactory</code>，而实际上，<code>AbstractFactory</code>会使用<code>ConcreteFactory</code>去实例化真正起作用的<code>class</code>。
<code>client</code>通过<code>AbstractProduct</code>去处理<code>ConcreteFactory</code>返回的<code>ConcreteProduct</code>。通过继承和多态，这个设计是可以实现的。</p>
<h1>优势与劣势</h1>
<ul>
<li>
<p>实现了<code>client</code>与<code>concrete class</code>的隔离。
通常意义上，<code>concrete class</code>才是实际承担工作的<code>class</code>。如何使他们在一起工作？一个本能的想法就是，<code>client</code>直接调用<code>concrete class</code>。
但是当软件需求发生变化时，比如需要一个新的实现。我们将会被迫去修改所有<code>client</code>中对于上一个<code>concrete class</code>的调用。当使用<code>Abstract Factory</code>
模式时，<code>client</code>不会关心实际的<code>concrete class</code>是什么。这样，当需求变化时，只需要修改<code>abstract factory</code>去返回新的<code>concrete class</code>，
而不需要改动<code>client</code>。而后者这种修改显然是更为便捷的。</p>
</li>
<li>
<p>使得<strong>运行时改变</strong>生效的<code>concrete class</code>更为容易
<code>abstract factory</code>模式下，改变其返回的<code>concrete class</code>是十分简单的。甚至可以在运行时完成转换。</p>
</li>
<li>
<p>要求<code>product</code>具有一致性
<code>client</code>通过<code>AbstractProduct</code>去操作实际的<code>ConcreteProduct</code>，显然，需要<code>ConcreteProduct</code>的接口一致。</p>
</li>
<li>
<p>在添加新需求时<strong>缺乏灵活性</strong>
<code>ConcreteFactory</code>需要与<code>AbstractFactory</code>的接口保持一致，但是如果在开发过程中出现了新的需求，将不可避免的要更改<code>AbstractFactory</code>，
然后,<code>ConcreteFactory</code>要保持一致的话也需要更改。在一个大型系统中，这个工作量是非常大的。</p>
</li>
</ul>
<h1>参考文献</h1>
<ul>
<li>[1]	Gamma E, Helm R, Johnson R. Design Patterns: Elements of Reusable Object-Oriented Software [M]. Boston: Addison-Wesley, 1994.</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
        <tag>Abstract Factory</tag>
        <tag>Raw Note</tag>
      </tags>
  </entry>
  <entry>
    <title>SICP 1.2节读书笔记</title>
    <url>/2016/10/19/SICP-1-2/</url>
    <content><![CDATA[<p>Procedure and Process</p>
<span id="more"></span>
<h2 id="1-2-1-线性递归处理-linear-recursion-process-与迭代处理-iteration-process"><a class="header-anchor" href="#1-2-1-线性递归处理-linear-recursion-process-与迭代处理-iteration-process">¶</a>1.2.1 线性递归处理（Linear Recursion Process）与迭代处理（Iteration Process）</h2>
<h3 id="线性递归处理"><a class="header-anchor" href="#线性递归处理">¶</a>线性递归处理</h3>
<p>递归处理(Recursive Process)是指由一些推迟的操作（Defered operation）构成的处理链。
这些操作的结果无法依赖现有的信息得到，只能推迟到信息充足时才能够从递归的内部往外计算。如，
计算阶乘时采用以下迭代式：
\begin{equation}
n!=n(n-1)!
\end{equation}</p>
<p>在Scheme中定义函数如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">def</span> (<span class="name">factorial</span> x)</span><br><span class="line">     (<span class="name">if</span> (<span class="name">=</span> x <span class="number">1</span>)</span><br><span class="line">         <span class="number">1</span></span><br><span class="line">         (<span class="name">*</span> x (<span class="name">factorial</span> (<span class="name">-</span> x <span class="number">1</span>)))</span><br><span class="line">      )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果要执行<code>(factorial 4)</code>，它的执行情况如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">*</span> <span class="number">4</span> (<span class="name">factorial</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name">*</span> <span class="number">4</span> (<span class="name">*</span> <span class="number">3</span> (<span class="name">factorial</span> <span class="number">2</span>)))</span><br><span class="line">(<span class="name">*</span> <span class="number">4</span> (<span class="name">*</span> <span class="number">3</span> (<span class="name">*</span> <span class="number">2</span> (<span class="name">factorial</span> <span class="number">1</span>))))</span><br><span class="line">(<span class="name">*</span> <span class="number">4</span> (<span class="name">*</span> <span class="number">3</span> (<span class="name">*</span> <span class="number">2</span> <span class="number">1</span>)))</span><br><span class="line">(<span class="name">*</span> <span class="number">4</span> (<span class="name">*</span> <span class="number">3</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name">*</span> <span class="number">4</span> <span class="number">6</span>)</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>在得到结果的过程中，可以看到在头3步的递归调用。在这个过程中，解释器在后台自动记录了整
个计算过程。在通常的编程语言中，这个计算过程的中间变量将会被记录在栈上，这一片内存由系统自
动管理。所需要内存量随调用深度线性增长。所以这个处理过程又被称为<strong>线性递归处理</strong>。</p>
<h3 id="迭代处理"><a class="header-anchor" href="#迭代处理">¶</a>迭代处理</h3>
<p>迭代处理（Iterative Process）是通过<em>操作所有的状态</em>，逐步迭代得到最终结果。使用迭代
处理需要能够找出完成这一函数的所有状态。以计算加法为例：
\begin{equation}
c=a+b=(a-1)+(b+1)=\dots=(a-a)+(b+a)=0+b+a
\end{equation}</p>
<p>在Scheme中定义函数如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">dec</span> x) (<span class="name">-</span> x <span class="number">1</span>))</span><br><span class="line">(<span class="name">define</span> (<span class="name">inc</span> x) (<span class="name">+</span> x <span class="number">1</span>))</span><br><span class="line">(<span class="name">define</span> (<span class="name">+</span> a b)</span><br><span class="line">     (<span class="name">if</span> (<span class="name">=</span> a <span class="number">0</span>)</span><br><span class="line">         b</span><br><span class="line">         (<span class="name">+</span> (<span class="name">dec</span> a) (<span class="name">inc</span> b))</span><br><span class="line">     )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果要执行<code>(+ 3 1)</code>，其执行过程如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">+</span> <span class="number">2</span> <span class="number">2</span>)</span><br><span class="line">(<span class="name">+</span> <span class="number">3</span> <span class="number">1</span>)</span><br><span class="line">(<span class="name">+</span> <span class="number">4</span> <span class="number">0</span>)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>显然在这种模式下，解释器不必要去保存中间变量，直接将最后的结果作为结果就行。理想中，这种
调用过程是不会产生额外的内存开销的。但是在通常的编程语言，如C中，系统要维护调用栈，即使
是这种写法，仍然会产生额外的内存开销。此时，可以通过将递归改写成由循环免去调用过程的代价。
这种技法叫<em>尾递归</em>。Scheme在解释器层面进行了尾递归优化，所以在上述执行过程中是没有额外内
存开销的。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年终总结</title>
    <url>/2018/12/31/annual-reflection-2018/</url>
    <content><![CDATA[<p><img src="/2018/12/31/annual-reflection-2018/thumbnail.png" alt="Kawaii Hifumi chan"></p>
<p>争取在 24 点之前填完这个坑吧（笑）。</p>
<span id="more"></span>
<p>在 7 天前，我在一个年终总结的贴子上发了不是“还有 7 天吗？我还能拖”。（笑）
事实上，我在很久之前就在想写一篇年终总结了。可是今年发生了太多，回看起来我有点百感交集。</p>
<p>首先，今年调了很久的参，发了一篇会议论文。然后，今年又是毕业前的最后一年，
对于我来说重中之重当然是找工作了。但是没想到的是满怀期待开始，却以零收获结束。
对于这一滑铁卢，我总结起来原因有二。第一是，我没能够理解社会运行的机理。
社会是非常讲求效率的。因此，如果看到有想要抓住的机会一定要马上抓住。
第二是，我没能够提前了解业界对工程师的要求，导致我对工程师应该掌握的认识上有点偏差。
现实让我认识到，这些偏差是很难在短时间内弥补的。难道，我要放弃了吗？</p>
<p>但是我还是喜欢搞技术的，我喜欢创造一件东西的感觉。大概是 2016 年，我看了一些前端技术的东西。
我的本科毕设还在导师的要求下增加了一个用来展示数据的 Web 页面。很自然的，
我就有“要不要试一试前端”的想法。于是，我在很短时间内重拾了 CSS/JavaScript。
了解一些之后发现前端技术变化很大啊。在 2016 年，ES6 只是刚刚提上台，
而在 2018 年已经成为了必备。应工程化的发展，构建工具和框架也成为了必须学习的一部分。
Node.js 让前端工程师不仅能在“前端”领域大展身手，
也能够在传统上属于“后端”的领域也能够做一些事情。这是非常酷的工作啊。就决定是它了。
我在年前找到一份实习工作，氛围非常棒。但是这份工作的总结还是留给下一年吧（笑）。</p>
<p>2018 年，对于我而言是“改变”的一年。从学生到社会人，为了完成这一转变，我还有很多需要去学。</p>
<h2 id="mv-goals-2018-md-goal-2019-md"><a class="header-anchor" href="#mv-goals-2018-md-goal-2019-md">¶</a><code>mv goals-2018.md goal-2019.md</code></h2>
<p>在新的 2019 年里，第一重要的还是毕业。第二，多学东西，多写东西，
在面试中，我感受到了写博客的作用。写过的东西理解上要深很多。第三，保持身体健康，
多锻炼锻炼。最后，如果有机会的话，带父母在年底的时候出去玩一玩？</p>
<p>希望大家和自己都能够在新的 2019 年里健康、好运。</p>
<p>2018-12-31</p>
<p>北京</p>
]]></content>
      <categories>
        <category>Annual Reflection</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年终总结</title>
    <url>/2020/12/31/annual-reflection-2020/</url>
    <content><![CDATA[<p>又到了一年的结尾，大家今年过得如何呢？</p>
<span id="more"></span>
<p>2020 年，对于全世界而言会是非常不平凡的一年。肆虐的 COVID-19 疫情使世界经济受到了重大的打击。由于病毒的威胁，人们或主动或被迫接触 Work from Home（WFH）这一全新的工作形式。尽管，由于仓促上阵，人们没有掌握正确的 WFH 的工作方法，很难在 WFH 环境下发挥 100% 的工作效率。但是，这次突然的检验会暴露很多现有实践与工具的问题。WFH 是一种非常具性价比的工作方式，我看好 WFH 的未来。</p>
<p>各国对 COVID-19 疫情应对的方式不同导致了疫情发展的结果也不同。率先控制疫情的国家将会吃到后疫情时代起步早的红利。世界上巨头国家力量的相对变化到底会对人们的生活造成什么影响？这又是一个非常值得关注的发展方向。</p>
<p>2020 年是<strong>一切皆有可能</strong>之年——美国总统特朗普未能在大选中连任、英法美首脑确诊感染 COVID-19、桐生可可涉台问题导致 Hololive 被驱逐出中国市场等等。不禁令人感叹 2020 年真是魔幻的一年啊。</p>
<h2 id="life"><a class="header-anchor" href="#life">¶</a>Life！</h2>
<p>第一次完全独自一个人生活，有了足以养活自己的收入，两件快乐事情重合在一起…咳咳，就不咏唱圣经了。今年在生活中算是圆儿时梦的一年。</p>
<p>在大概初中的时候，我就拥有了一台自己的 PC。那是我爸从附近网吧淘汰的机器中淘回来的电脑。CPU 是一颗 Intel 赛扬处理器。在那台电脑上打一些大型游戏非常的卡。那时我非常沉迷《微软模拟飞行 2004》（也被称为 FS9），基本上只能跑出 20FPS 左右的帧率。这个习惯也因此培养了我现在 「10 帧能玩，20 帧流畅」的低要求。后来《微软模拟飞行 10》（FSX）流行起来，当时的主流配置都无法满足 FSX 的要求，更不用说我那赛扬老机器了。因此，我儿时最大的愿望可能就是拥有一台能够流畅运行 FSX 的 PC 了。</p>
<p><img src="/2020/12/31/annual-reflection-2020/Screen_Shot_2020-12-31_at_9.50.33_PM.png" alt="微软模拟飞行 2004 启动封面"></p>
<p>在今年里，乘着 AMD YES！的风潮，我终于拥有了一台高性能的 PC。3900 + 2080Super + 32G 足以流畅运行市面上所有 3A 大作。初次之外也购置了 Honeycomb 飞行摇杆、节流阀与脚舵三件套。终于（在硬件上）成为了键盘飞行员（笑）。完成了儿时的愿望。另外值得一提的是，2080Super 却是被老黄暗算了啊。</p>
<h2 id="work"><a class="header-anchor" href="#work">¶</a>Work！</h2>
<p>2020 年是我作为全职前端工程师的第一年。由于所在的组是业务的第一线，这一年里主要的精力都投入到了这种业务之上。这一年在工作中的体会有两点：一是业务逻辑抽象的困难性；二是开发方式上的随意性。</p>
<p>业务不像理论有缜密的逻辑。业务是谈判、妥协与实验的产物。代码中充斥着特例，给抽象带来了很大困难，因此很难有业务逻辑上的沉淀。很多时候，我们都在重复造轮子，工作在编程语言与框架提供的最低的抽象层级，开发效率上难以提升。</p>
<p>在公司业务中开发方式是随意的。你可以使用任何开发方法论去开发一个功能。一个功能可以没有具体的结构设计，在开发过程中可以随意发散。最后的产物可能是一个功能完好，却很难重用与扩展的软件。另外，在开发过程中很少有单元测试与集成测试，使得后来人几乎无法重构，渐渐项目代码就腐化为了臭不可闻的遗留代码。</p>
<h2 id="做的不好的地方"><a class="header-anchor" href="#做的不好的地方">¶</a>做的不好的地方</h2>
<p>前几天和朋友开玩笑说：「2021 年的新年愿望是写完 2020 年的年终总结，2020 年未完成的愿望是写完 2019 年的年终总结」。的确，去年我没有发布 2019 年年终总结。但是很遗憾没能够完成它。它还躺静静地在我的草稿箱里。2020 年中，做的不好的地方可以总结为：</p>
<ul>
<li>没有计划性</li>
<li>没有建立反馈</li>
</ul>
<p><img src="/2020/12/31/annual-reflection-2020/Screen_Shot_2020-12-29_at_10.59.39_PM.png" alt="弃坑的总结"></p>
<h3 id="没有计划性"><a class="header-anchor" href="#没有计划性">¶</a>没有计划性</h3>
<p>由于年初没有建立目标，可以说今年我是没有任何既定目标，在盲目地摸索。没有目标很爽，因为我无法得到一个「控制信号」 ，结果怎么样都好。但是长期而言，没有目标是很危险的，就像前面所说的随意发散的软件，没有目标的人非常容易沉沦与腐化。因此，明年一定要改变这一现状。</p>
<h3 id="没有建立反馈"><a class="header-anchor" href="#没有建立反馈">¶</a>没有建立反馈</h3>
<p>一个良性的渐进改良过程离不开正确的反馈。比如，目标是提高编码效率，首先我们需要定义「编码效率」这一概念的具体度量指标，是完成一个需求的平均天数？还是每日编码的平均行数？然后，通过实验备择的改良方式，观察备择方式对指标的影响，从而做出决策。但是，在今年，无论是生活还是工作中，都没有能够建立起正确的反馈渠道。因此无从对生活方式或者工作方法进行改良。久而久之就会一直陷在一个效率较低的方法论里。</p>
<h2 id="2021-年的新年目标"><a class="header-anchor" href="#2021-年的新年目标">¶</a>2021 年的新年目标</h2>
<p>谈到将要到来的 2021 年，为了终结「没有计划性」这一现状，为明年立一些 flag 就成为了 2020 年最后的重要工作。我为明年挑选的 flag 大概可以列为：</p>
<ul>
<li>基于 Jest 与 Cypress 的前端单元测试与 E2E 测试的系列教程；</li>
<li>参与开源项目，向知名开源项目提交至少一个功能性或者修复性 PR；</li>
<li>至少发布 12 篇有质量的技术文章</li>
<li>掌握系统化的开发方法，并熟练运用于日常开发中；</li>
</ul>
<p>今年，我在前端工作中实践了 TDD，使用了 Jest 与 Cypress 对前端项目编写了完整的单元测试与端到 E2E 测试。在实践中，收获了很多经验，也踩了很多坑。我认为任何严肃的软件项目都应该有一套完整的测试用例。我希望能够将这些经验系统化起来，形成一个系列文章。帮助软件项目逃离祖传代码的诅咒。</p>
<p>作为软件工程师，参与高质量的项目无疑是成长最快的方法。而在软件领域，能够参与的最高质量的项目无疑又是一些知名的开源项目，如 Node.js、React、Vue 等。这些项目支撑了全球数以亿计的前端业务。从中可以一窥究竟大型项目的组织、设计思路以及工程实践。对于工程师而言，这些经验是不可估量的宝贵财富。</p>
<p>第 3 个 flag 是「至少发布 12 篇有质量的技术文章」。在这里，「有质量的技术文章」指的是由自我思考得出来的具有严谨逻辑的技术文章。在工作中，我发现「输出观点」对于工程师是非常重要的。然而，没有人会认同毫无根据的观点。要「输出观点」，严谨的逻辑是必要的。锻炼逻辑，最有效的方式可能就是写文章了。</p>
<p>最后一个 flag 是「掌握系统化的开发方法，并熟练运用于日常开发中」。在前面，我也提到过，在公司中开发方式一般是随意的、不成系统的。随意的软件设计导致了成品代码耦合程度高，难以维护。在 2021 年，掌握系统化的开发设计方法，从像 Code Complete 这样的软件设计经典中取经，将这些标准流程用到日常的开发实践中。提高软件架构设计的能力。</p>
<p>在文章的最后，祝愿大家接下来的 2021 年里身体健康，万事如意。希望席卷全球的新冠疫情能够平息下来，世界各地的人们的生活能够恢复正常。 Everything will be better.</p>
]]></content>
      <categories>
        <category>Annual Reflection</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 年终总结</title>
    <url>/2022/01/01/annual-reflection-2021/</url>
    <content><![CDATA[<p>转眼间又到了年末年初的时候了，又到了每年一度的年终总结的时候。回顾即将过去的 2021 年，
2021年可能是会载入史册的一年。但是对于我来说，而是「低潮」与「思考」的一年。</p>
<span id="more"></span>
<p>这一年里，我经历了公司搬迁、经历了半夜还在配合修改需求的日子、
也经历了被裁员。在人生的第一份工作中以被裁员而终结，
如果在游戏中应该拿一个成就吧，哈哈哈。</p>
<p><img src="/2022/01/01/annual-reflection-2021/ji.jpg" alt="寄.jpg"></p>
<h2 id="生活"><a class="header-anchor" href="#生活">¶</a>生活</h2>
<p>今年在生活上算是完成了一个目标——把驾照考出来了。在同学的“刺激”之下，
6月底我终于狠下心来报了驾校。这期间我也体会到了为什么大家都说驾照最好在大学考出来。
学车完全占据了我7月的所有的周末，几乎没办法休息。由于考试只能在工作日进行，
我还需要请若干天年假来考试。如果考试不通过的话还要再请假，一天的工资也是不小的损失。
幸好这次驾考是一次过。我还挺怀念那段时间的，非常充实。拿到驾照之后，
我还去与驾校散养的羊驼与孔雀告别。哈哈。</p>
<p><img src="/2022/01/01/annual-reflection-2021/alpacas-in-driving-school.jpeg" alt="驾校的羊驼.jpg"></p>
<p>由于被裁员，今年我多出了很多时间用于生活。但是不巧，新冠疫情仍然在世界范围内流行，
出去旅行可能并不是一个好的选择。在毕业之前，我就有想出去走一走的想法，
一直未能成行。我非常希望世界能够回到新冠前时代的开放，祝愿疫情早日平息。</p>
<h2 id="工作"><a class="header-anchor" href="#工作">¶</a>工作</h2>
<p>今年的工作总结起来就是——寄。今年年初，我与小伙伴以支援的身份被调出。
两个人接手一个新的小程序项目，项目从零开始搭建，在过程中踩了一些坑，
总体而言算是痛并快乐着。</p>
<p>然后到了6月份，我回到了原来的开发组。但是，7月份我又被以支援的身份调出到其他开发组。
我感觉在今年的工作中，我一直处于哪里需要往哪搬的备份状态。没有一个固定的项目来维护，
对于程序员的成长是很不利的。也由此萌生了离职的念头。但是没想到没等我提出来，
公司抢先一步把我裁了，当时不知道是一件该难过还是该伤心的事情。现在想起来，
这可能并不是坏事。因为我有了很多宝贵的时间来思考之前中很难思考到的重要问题。
在之前，「技术改变世界」这个想法占据了我的头脑。
技术仿佛是能够解决一切问题的手段。但是，在仔细思考之后发现，
这个世界不是这么运转的。因此，在这后半年里，我开始（重新）接触技术之外的东西，
发现确实十分受用。</p>
<p>除了工作之外，我抽出了一些时间来参与开源项目的开发。
成为了 <a href="https://github.com/nodejs/node">Node.js</a> 的 Collaborator。
出乎意料的是，成为开源项目甚至是知名开源项目的维护者对技术的要求并没有想象中的那么高。
只需要热情与恒心加上一点点的编码能力，就足够了。</p>
<h2 id="2021年目标回顾"><a class="header-anchor" href="#2021年目标回顾">¶</a>2021年目标回顾</h2>
<p>从 <a href="/2020/12/31/annual-reflection-2020/" title="2020 年终总结">去年的年终总结</a> 中复制过来的。</p>
<ul>
<li>
<p>❌ 基于 Jest 与 Cypress 的前端单元测试与 E2E 测试的系列教程；</p>
<p>非常遗憾，第一项没有完成。没能够规划好时间来写这一系列文章。但是，
我仍然认为自动化测试应该是严肃的软件项目中重要的组成部分。
希望今年能够完成这个目标。</p>
</li>
<li>
<p>✅ 参与开源项目，向知名开源项目提交至少一个功能性或者修复性 PR；</p>
<p>在开源项目方面，我今年向 Node.js 提交了 27 个 PR，
除去 2 个程序性的 PR，应该有 25 个文档或者修复性的 PR，其中 15 个被接收。
我应该算是完成了第二个目标。</p>
</li>
<li>
<p>❌ 至少发布 12 篇有质量的技术文章</p>
<p>很遗憾没有完成，今年在技术方面只发布了 3 篇文章。尚且不论有没有质量，
在数量上就没有达标。这自己还是堕怠了啊。</p>
</li>
<li>
<p>掌握系统化的开发方法，并熟练运用于日常开发中；</p>
<p>这个目标从今年看来，没有可以量化的指标来衡量这个目标，
也就无法判断是否达到这个目标。</p>
</li>
</ul>
<h2 id="2022年展望"><a class="header-anchor" href="#2022年展望">¶</a>2022年展望</h2>
<p>在 2022 年里，我会从之前的技术中心向生活中心转变，
重新出发去寻找适合自己的生活方式与节奏。</p>
<p>初步的 2022 年目标如下：</p>
<p>Object 1：在技术领域继续提高，丰富自己的业务经验与能力</p>
<ul>
<li>完成基于 Jest 与 Cypress 的前端单元测试与 E2E 测试的系列教程；</li>
<li>发布 12 篇博客文章；</li>
<li>学习 rust，以完成一个 TCP 链接库作为考察标准；</li>
<li>持续参与 Node 的维护工作，提交至少 5 个 PR；</li>
</ul>
<p>Object2: 平衡生活与工作，使自己感到生活的快乐</p>
<ul>
<li>去国内的一个城市旅游一番；</li>
<li>学习MIDI键盘，完成 160 次至少 1小时的训练（以钢琴形式）；</li>
<li>看 20 部 TV 动画；</li>
</ul>
<p>Object3: 保持身体健康</p>
<ul>
<li>每个月至少长途骑行（&gt; 30 km） 2 次；</li>
<li>体重减到 75 kg（目前 77kg - 79kg）；</li>
</ul>
<p>在最后，祝大家新年快乐，在 2022 年里身体健康，万事如意。
希望新冠疫情能够早日平息，能够重回开放且自由的生活。</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>Annual Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>允许自己的不完美</title>
    <url>/2021/11/18/combat-with-perfectionism/</url>
    <content><![CDATA[<p>有时自己明明想写一篇文章来分享某个主题，
但是下笔之后总觉得哪里哪里都有点不完美，相较大牛的文章简直相形见绌，
于是失去了发布的勇气。久而久之，每当自己有些文章的念想时，
在潜意识里就会有拖延的倾向——「为什么要写文章？反正你又不发布」。
最后就是喜闻乐见的「下次一定」了。
不知道大家有没有相同经历，我自己是饱受这种想法的影响的。</p>
<span id="more"></span>
<p>最近在看来自哈佛大学的 Tal 博士主讲的
<a href="https://www.bilibili.com/video/BV1Gs411o71d">《积极心理学》</a>课程。
在课程中，Tal 博士分享了很多心理学研究成果，将它们串联起来变成一条通往「幸福」
的通路，让人变得更加积极，更加有生产力与创造力。我强烈推荐各位去看看这一系列视频。
真的能够受益终身。</p>
<p>在课程中，Tal 博士专门花了一节课的时间来讨论完美主义以及其造成的影响。
比如完美主义是拖延的主要因素、完美主义降低了人们的幸福度，使人自卑等。
我特别想在此分享他的一些思考。</p>
<h2 id="完美主义是什么"><a class="header-anchor" href="#完美主义是什么">¶</a>完美主义是什么</h2>
<p>在 Tal 博士的定义中，<em>完美主义</em>是一种对失败的失能性的恐惧，
特别是在自己在意的领域上失败。所谓失能性的恐惧是指，完美主义者害怕失败，
害怕到以至于无法继续前进或者失去尝试的勇气。</p>
<p>与此相对的，有一类人我们定义为是<em>追求卓越</em>的人，
他们在追求一个目标的时候，能够允许一定的失败。在完美主义者中眼中，
如果要从 A 点到 B 点，选择的必然是从 A 点到 B 点的直线。但是在追求卓越者眼中，
从 A 点到 B 点可以是一个反复曲折的过程，只要在最后达成目的即可。</p>
<p><img src="/2021/11/18/combat-with-perfectionism/perfectionist-vs-pursuiter-for-excellency.png" alt="完美主义 vs 追求卓越"></p>
<p>在生活中，我们似乎不会将完美主义视为一种缺点。
拥有完美主义特质的人会竭尽自己的全力去达成自己的目标，
通常会选择最直接的那条路，永远不回头的走下去。
完美主义与<em>完美</em>和<em>成功</em>通常联系在一起。这样的特质很好啊，
为什么会说有缺点呢？</p>
<h2 id="完美主义的缺点"><a class="header-anchor" href="#完美主义的缺点">¶</a>完美主义的缺点</h2>
<p>在开头提到了博客主都会遇到的一个难题。自己写出来的文章比不上大家，如
<a href="https://overreacted.io/">Dan Abramov</a>、 <a href="https://martinfowler.com/">Martin Flower</a>、
<a href="https://www.zhangxinxu.com/">张鑫旭</a>等等。然后久而久之就失去了写文章的兴趣。
这就是完美主义作祟的一个例子。</p>
<p>人对失败是敏感的，没有人会喜欢失败。人总会竭尽自己的全力来避开失败。
但是，人生中失败是不可避免的。就如一场比赛中不会所有人都是第一名一样，
一场 8 个人的比赛中，就会产生 7 个失败者。更不如说，失败才是生活的常态。</p>
<p>如果人惧怕失败，以至于用「不行动」来实现「不失败」这一目标。
这就落入了完美主义的圈套中了。这是拖延乃至扼杀一种兴趣的普遍原因之一。
如果自己写的文章比不上大家，那我不写不就好了吗？
博客就会这样无限期的断更下去。</p>
<p>另外，有一句古话曰「失败是成功之母」。每一次失败都是一次获得新知识的机会。
如果不写文章，那么写作技巧就不会提高。如果不实际编写程序，那么技术也不会提高。
如果想要一发入魂，一次就编写出「最完美」的作品，这是不可能的，
身体就会自然的抗拒。</p>
<p>人类的大脑能够感知到现实与理想的差异。大脑不喜欢这种差异，如果有差异存在，
大脑会产生焦虑的情绪，迫使人类要么改变现实，要么改变理想，
使这两个世界变得一致。这种机制不是坏事，它驱动着人们向着理想世界的方向改变现实。
但是在完美主义者中，这个机制却出现了一些问题。在完美主义者的理想世界中，
失败是不应该存在的东西，而在现实世界中，失败是普遍的。
因此理想世界与现实世界出现了差异，大脑会产生焦虑的情绪。此时，
完美主义为了缓解焦虑需要使理想世界与现实世界变得一致。要改变理想吗？
开始接纳失败。如果这样的话，完美主义者就不是完美主义者了。
为了符合完美主义者特质，完美主义者只能够改变现实世界，
即在现实生活中要一直赢。
一步失败就会让完美主义者陷入差异产生的深深的焦虑与抑郁中。
然而，在现实生活中，失败才是常态。
这意味着这种焦虑与抑郁也会是完美主义者人生中的常态。
这不禁让人自问——「这值得吗？」</p>
<h2 id="为什么会造成完美主义"><a class="header-anchor" href="#为什么会造成完美主义">¶</a>为什么会造成完美主义</h2>
<p>那么，什么因素造成了完美主义如植入了 DNA 中一样如此普遍呢？
也许有两个因素，其一是人类社会与教育重视达成目标，却轻视达成目标的过程；
其二是在个人层面，完美主义与「成功」等正面素质关联在一起，
当想放弃完美主义的时候，潜意识中会以为同时在放弃「成功」与「完美」，
进而会阻止放弃完美主义。</p>
<p>在社会与教育中，一直以来达成目标是最重要的。达成目标会收到奖励，
如升学，晋升等。但是，为了升学与晋升，期间的努力与坎坷是没有被重视的。
至少我没有听说过为了庆祝失败举办的活动。
也许大家会问，升学与晋升这一结果不就是这段过程的奖励吗？但是如果
没能够成功达成目标又会怎么样呢？这就不变成了纯粹的痛苦经历了吗？
为了逃避这样悲惨的事情，人们只能采取「只能成功不能失败」这种观点。</p>
<p>另外在个人层面，「完美主义」常常与「成功」等正面素质关联在一起。
如果想要放弃「完美主义」，接纳失败的话，人的潜意识中会认为「成功」
会被同时放弃。当然，潜意识会抗拒这样的改变。但是，放弃「完美主义」并不意味着
放弃「成功」。只不过是在通往「成功」的道路上可能绕一些路，看到更多的风景而已。</p>
<h2 id="思考"><a class="header-anchor" href="#思考">¶</a>思考</h2>
<p>Dr. Tal 对于完美主义的研究也启发了我的一些思考。首先，在做事的方法论上，
无论是什么事情，只要想去做的话尽管去做。如果成功的话自然很好，
如果失败的话也能从中获取一些新的经验。做事最怕的不是失败，而是不做事。
其次，要重视旅途上风景，不要总盯着目标。奖励不一定是要在达成目标的时候，
开始做某件事之类的也是值得奖励的。</p>
<p>自从看了<a href="https://www.bilibili.com/video/BV1Gs411o71d">《积极心理学》</a>课程之后，
我特别想分享 Dr. Tal 的一些关于如何变得快乐与积极的看法。
这是其中之一。在现代社会中，我们的物质变得更加富足，
但是我们似乎并没有变得更加快乐。快乐并不是少数人的特权，
它是每个人应得的。所以，希望世界上每一个人都能够获得自己的幸福与快乐。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>完美主义</tag>
        <tag>心理</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习常用概率分布速查</title>
    <url>/2017/05/28/common-dist-in-ml/</url>
    <content><![CDATA[<p>本文收录了一些机器学习中常用的概率分布。其中的大部分摘自《Machine Learning a probalistic perspective》。这篇文章是一篇参考性质的文章，仅罗列结论而不会关心它的来源。本文将会在学习过程中随时更新。</p>
<span id="more"></span>
<div class="note info"><p>点击本页右下角的图标可以开启目录。</p>
</div>
<hr>
<h2 id="离散分布"><a class="header-anchor" href="#离散分布">¶</a>离散分布</h2>
<h3 id="二项分布与伯努利分布"><a class="header-anchor" href="#二项分布与伯努利分布">¶</a>二项分布与伯努利分布</h3>
<p><strong>二项分布</strong>是\(n\)次独立的是非实验成功的个数\(k\)服从的分布。记为\(k \sim \text{Bin}(n,\theta)\)。其中\(\theta\)是单次实验成功的概率。</p>
<p>概率质量函数（pmf）：
$$
Bin(k|n,\theta)=\left(\begin{array}{c}n\\k\end{array}\right)\theta^k(1-\theta)^{n-k}
$$
均值：$\text{mean}=\theta$
方差：$\text{var}=n\theta(1-\theta)$</p>
<p>$n=1$时的二项分布称为<strong>伯努利分布</strong>，设随机变量$X$服从伯努利分布，记为$X \sim \text{Ber}(\theta)$。</p>
<p>概率质量函数：
$$
\text{Ber}(x|\theta)=\theta^{\mathbb{I}(x=1)}(1-\theta)^{\mathbb{I}(x=0)}
$$
其中：
$$
\mathbb{I}(x=n) = \left\{
\begin{eqnarray*}
&amp;&amp;1 \quad x=n \\
&amp;&amp;0 \quad \text{otherwise}
\end{eqnarray*}
\right.
$$</p>
<p>均值：$\text{mean}=\theta$
方差：$\text{var}=\theta(1-\theta)$</p>
<div class="note info"><p>引入$\mathbb{I}$是为了简化公式的表示。比如这里伯努利函数的pmf可以表示为：
$$
\text{Ber}(k|\theta) = \left\{
\begin{eqnarray*}
&amp;&amp;\theta \quad &amp;x=1 \\
&amp;&amp;1-\theta \quad &amp;x=0
\end{eqnarray*}
\right.
$$
在公式较为复杂的时候，我们会采用更为简单的方式表示。</p>
</div>
<h3 id="多项分布与类别分布"><a class="header-anchor" href="#多项分布与类别分布">¶</a>多项分布与类别分布</h3>
<p><strong>多项分布</strong>是二项分布在多个可能结果的实验上的推广。</p>
<p>概率质量函数：
$$
\text{Mu}(\pmb{x}|n,\theta)=\left(
\begin{array}
{c}n \\
x_1,\dots, x_K
\end{array}\right)\prod_{j=1}^K\theta^x_j
$$</p>
<p>其中：
$$
\left(\begin{array}{c}n\\x_1,\dots, x_K\end{array}\right) \triangleq \frac{n!}{x_1!x_2!\dots x_K!}
$$</p>
<p>当$n=1$时，多项分布称为<strong>类别分布</strong>。</p>
<p>概率质量函数：
$$
\text{Cat}(x|\theta) = \prod_{j=1}^K\theta^{\mathbb{I}(x_j=1)}
$$</p>
<hr>
<h2 id="连续分布"><a class="header-anchor" href="#连续分布">¶</a>连续分布</h2>
<h3 id="beta分布"><a class="header-anchor" href="#beta分布">¶</a>Beta分布</h3>
<p><strong>Beta分布</strong>是一个在区间$[0,1]$上的一个分布。</p>
<p>概率密度函数：
$$
\text{Beta}(x|a,b)=\frac{1}{B(a,b)}x^{a-1}(1-x)^{b-1}
$$
其中$B(a,b) \triangleq \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}$</p>
<p>均值：$\text{mean}=\frac{a}{a+b}$
众数：$\text{mode}=\frac{a-1}{a+b-2}$
方差：$\text{var}=\frac{ab}{(a+b)^2(a+b+1)}$</p>
<hr>
<h2 id="多维联合分布"><a class="header-anchor" href="#多维联合分布">¶</a>多维联合分布</h2>
<h3 id="多维正态分布"><a class="header-anchor" href="#多维正态分布">¶</a>多维正态分布</h3>
<p>**多维正态分布(Multivariate Gaussian, or Multivariate normal, MVN)**是正态分布在多维的推广。</p>
<p>假设$\pmb{x} \in \mathbb{R}^D$，则概率密度函数为：</p>
<p>$$
\mathcal{N}(\pmb{x}|\pmb{\mu},\pmb{\Sigma}) \triangleq \frac{1}{(2\pi)^{D/2}|\pmb{\Sigma}|^{1/2}}\exp{\left[-\frac{1}{2}(\pmb{x}-\pmb{\mu})^T\pmb{\Sigma}^{-1}(\pmb{x}-\pmb{\mu})\right]}
$$</p>
<p>其中，$\pmb{\mu}=\mathbb{E}[\pmb{x}]\in\mathbb{R}^D$, $\pmb{\Sigma} =\text{cov}[{\pmb{x}}] \in \mathbb{R}^{D \times D}$为协方差矩阵。</p>
<h3 id="dirchlet分布"><a class="header-anchor" href="#dirchlet分布">¶</a>Dirchlet分布</h3>
<p><strong>Dirchlet分布</strong>是Beta分布在多维情况下的一个推广。由于<strong>Direchlet分布</strong>仅在_概率单纯形_的面上有分布，所以被认为是分布的分布。</p>
<p>定义概率单纯形$S_k=\{x:0 \le x_k\le 1, \sum_{x=1}^K x_k=1\}$。</p>
<p>概率密度函数：
$$
\text{Dir}(x|\pmb{\alpha}) \triangleq \frac{1}{B(\pmb{a})} \prod_{k=1}^K x_k^{\alpha_k-1} \mathbb{I}(\pmb{x} \in S_k)
$$</p>
<p>其中
$$
B(\pmb{a}) \triangleq \frac{\prod_{k=1}^K \Gamma(\alpha_k)}{\Gamma(\alpha_0)}
$$</p>
<div class="note info"><p>上述概率密度函数也可以写成
$$
\text{Dir}(x|\pmb{\alpha}) \triangleq
\left\{
\begin{eqnarray*}
&amp;&amp;\frac{1}{B(\pmb{a})} \prod_{k=1}^K x_k^{\alpha_k-1} \quad &amp; \text{if}\sum_{x=1}^K x_k=1 \\
&amp;&amp;0 \quad &amp; \text{otherwise}
\end{eqnarray*}
\right.
$$</p>
</div>
<p>均值：$\mathbb{E}[x_k]=\frac{\alpha_k}{\alpha_0}$
众数：$\text{mode}[x_k]=\frac{\alpha_k-1}{\alpha_0-K}$
方差：$\text{var}[x_k]=\frac{\alpha_k(\alpha_0-\alpha_k)}{\alpha_0^2(\alpha_0+1)}$</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Probability</tag>
      </tags>
  </entry>
  <entry>
    <title>重新审视Web开发安全：event-stream注入恶意代码</title>
    <url>/2018/11/27/concerns-about-development-security-event-stream-hijacking/</url>
    <content><![CDATA[<p>在开发Web应用时，如果我们的需求缺少一个不那么简单而又不想亲自动手写的工具时，我们会向Google老师求助，看到一个<code>npm</code>包恰好能够满足，然后<code>npm install package</code>一把梭，<code>require</code>解决问题。完美的工作流，体现了JavaScript社区的开放与强大。但是，最近一个月下载量达百万的包<code>event-stream</code>被注入了恶意代码。恶意代码会尝试劫持另外一个包中的<code>bitcore-wallet-client.getKeyFunc</code>方法。如果一个项目同时依赖了<code>event-stream</code>与<code>copay-dash</code>，当<code>bitcore-wallent-client</code>中的<code>getKeyFunc</code>运行时，恶意代码会检查钱包的id，持有比特币BTC的数量以及比特币现金BCH的数量。如果BTC数量大于100或者BCH数量大于1000，就将钱包的公钥发给一个地址。</p>
<p>当我看到这个新闻的时候，我心里想，我没写过写区块链相关的对象，应该不会被影响到吧。但是当我没事跑一下检查方法时，结果却傻眼了：</p>
<p><img src="/2018/11/27/concerns-about-development-security-event-stream-hijacking/vulnerability-check.png" alt="检查结果"></p>
<p>我中招了！</p>
<span id="more"></span>
<h2 id="安全建议"><a class="header-anchor" href="#安全建议">¶</a>安全建议</h2>
<p>我中招是因为<code>vue-cli</code>间接依赖了受影响<code>event-stream@3.3.6</code>。目前<code>vue-cli</code>已经更新了版本将<code>event-stream</code>锁定在了未受影响的<code>3.3.4</code>。如果有向我一样中招的朋友，请尽快升级<code>vue-cli</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装时</span></span><br><span class="line">npm update vue-cli -g</span><br></pre></td></tr></table></figure>
<p>如果没有安装过<code>vue-cli</code>，也要检查一下是否有项目简介依赖了<code>event-stream@3.3.6</code>。方法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局层面</span></span><br><span class="line">npm <span class="built_in">ls</span> event-stream flatmap-stream -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目层面</span></span><br><span class="line">npm <span class="built_in">ls</span> event-stream flatmap-stream</span><br></pre></td></tr></table></figure>
<h2 id="攻击原理"><a class="header-anchor" href="#攻击原理">¶</a>攻击原理</h2>
<p>太简单了，假如我们有一个正常的包<code>good.js</code>是这么写的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">goodFunc</span> = <span class="function">() =&gt;</span> <span class="string">&#x27;good&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后我们有一个包含恶意的包<code>malicious.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> good = <span class="built_in">require</span>(<span class="string">&#x27;./good&#x27;</span>)</span><br><span class="line"></span><br><span class="line">good.<span class="property">goodFunc</span> = <span class="function">() =&gt;</span> <span class="string">&#x27;hijacked&#x27;</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">usefulFunc</span> = <span class="function">() =&gt;</span> <span class="string">&#x27;a useful function in malicious code&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当我们的项目同时依赖两个包的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> good = <span class="built_in">require</span>(<span class="string">&#x27;./good&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> malicious = <span class="built_in">require</span>(<span class="string">&#x27;./malicious&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(good.<span class="title function_">goodFunc</span>())  <span class="comment">// hijacked</span></span><br></pre></td></tr></table></figure>
<p>简单到不可思议吧，比起别的程序深入汇编挖漏洞。JavaScript只需要，从一个不知道干什么的包里<code>require</code>被攻击的包，然后修改一下就行。这里<code>event-stream</code>干了很容易被发现的通过网络发送数据，如果其他攻击不是那么容易被发现呢？我们项目里动辄上千的依赖，我们能够保证它们都是善良的天使吗？I don’t know…</p>
<h2 id="重新审视开发安全"><a class="header-anchor" href="#重新审视开发安全">¶</a>重新审视开发安全</h2>
<p>Web开发者整天与不安全的网络、不可信任的输入等打交道。Web安全对于开发者而言，似乎就是保证用户的信息安全。我们会使用很多技术来保证用户的安全，像HTTPS，CSRF防御等等。</p>
<p>但是…对于开发者本身呢？Node.js的模块机制提供的保护是0。它只能够保证第一次<code>require</code>的时候代码是包作者提供的。接下来轮到我们的代码<code>require</code>的时候，说实话，我们不能保证我们调用的函数是李逵还是“李鬼”。JavaScript语言层面提供的保护…近乎为0。能够阻止修改我们<code>exports</code>出去的对象的方法只有一个，<code>Object.defineProperty(module.exports, 'myMethod', &#123; writable: false &#125;)</code>。那么长，还只能锁住一个方法，一般库的作者是不会写的。</p>
<p>现在我们使用这些包，就像使用C++的未定义行为一样。有时它确实有用，但是可能不是像你想象中的一样作用的。也许哪一天，一个包给<code>Object.create</code>注入新行为，当执行这个函数时删除项目文件夹，也说不定。。</p>
<p>目前JavaScript社区是靠人来解决这一事情的，默认信任大牛、高Star的包。但是这些“高信任度”的包引入的依赖呢？巨量的基础包依赖，像<code>is-odd</code>（判断一个数是不是奇数。很简单是吧？这个包每周下载量达1百万次哦）这些，使得我们根本不可能去检查项目中的每一个依赖。当其中一个依赖出现问题的时候，我们每个人都是潜在的受害者。</p>
<p>综上所述，<code>Node.js</code>不严格的模块机制、过于灵活的JavaScript以及项目中巨量的包依赖已经对开发安全形成了威胁。我们需要一个解决方案<strong>保证</strong>我们调用的函数就是作者写的函数。</p>
<h2 id="一个可能的解决方案"><a class="header-anchor" href="#一个可能的解决方案">¶</a>一个可能的解决方案</h2>
<p>既然现有机制无法保证包在<code>export</code>出去之后其<strong>公共接口</strong>不受改变。那么包的开发者应该承担起这一责任，无论是通过<code>Object.defineProperty</code>去设定公共接口不可写或什么其他的方法。这里我写了一个<a href="https://github.com/Ayase-252/exports-lock">exports-lock</a>，能够通过递归地设置<code>module.exports</code>的属性为不可写(<code>writable: false</code>)、不可配置(<code>configurable: false</code>)。保证公共接口在<code>export</code>之后不受篡改。</p>
<p>（可能暴力了点，可以改良。。。）</p>
<h2 id="参考文章"><a class="header-anchor" href="#参考文章">¶</a>参考文章</h2>
<p>1.<a href="https://github.com/dominictarr/event-stream/issues/116">I don’t know what to say.</a></p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web Development Security</tag>
        <tag>Cyber Security</tag>
      </tags>
  </entry>
  <entry>
    <title>在Windows中配置兼容于VS Code的GPG签名服务</title>
    <url>/2018/05/04/configure-gpg-compatible-with-vscode/</url>
    <content><![CDATA[<p>在Git中，可以通过GPG加密的方式保证在commit传输的过程中不受篡改。在Windows中，可以用VS Code自带的版本控制提交带GPG签名的commit。但是一遇到对应的GPG密钥带有密码的时候，VS Code自带的版本控制（准确地来说是所调用的git程序）就无法对commit进行签名。具体会提示<code>gpg: cannot open tty 'no tty': No such file or directory</code>。原因在于<code>gpg</code>程序无法获取密码以进行签名。由于文档的不足，我尝试了很多方法去解决这一问题。最近看到<a href="https://github.com/Microsoft/vscode/issues/17014">#17014</a>之后，突然了解了需要<code>gpg-agent</code>才能使GPG签名功能正常使用。本文将会描述如何在Windows中做出这些改变。</p>
<span id="more"></span>
<h2 id="准备工作"><a class="header-anchor" href="#准备工作">¶</a>准备工作</h2>
<p>本文将不会描述如何使用<code>gpg</code>，如果想了解这一方面的信息的话，推荐阅读<a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html">GPG入门教程</a>或<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E7%AD%BE%E7%BD%B2%E5%B7%A5%E4%BD%9C">git文档-签署工作</a>
由于cygwin中的<code>gnupg</code>不自带<code>gpg-agent</code>，我们需要一个自带<code>gpg-agent</code>的<code>gpg</code>版本。在Windows平台下，流行的选择是<a href="https://www.gpg4win.org/">gpg4win</a>。下载安装包，然后安装在任意目录之下。但是此时，签署功能仍然无法工作，一是因为<code>gpg-agent</code>未打开，二是因为<code>git</code>不知道新的<code>gpg</code>在哪，仍然会尝试使用旧的<code>gpg</code>导致问题。</p>
<h2 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2>
<p>首先我们要在新的<code>gpg</code>下新建密钥，此部分请参见之前提到的教程，这里不在阐述。之后，在你最喜欢的命令行工具中执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg-agent</span><br></pre></td></tr></table></figure>
<p>以开启gpg-agent。</p>
<p>最后，我们要通知<code>git</code>新的<code>gpg</code>的位置，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global gpg.program &quot;your/path/to/gpg&quot;</span><br></pre></td></tr></table></figure>
<p>此时，签署功能应该可以正常使用了。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Visual Studio Code</tag>
        <tag>GPG</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS架构（I）—— CSS该怎么写</title>
    <url>/2018/12/06/css-architecture-what-is-good-css/</url>
    <content><![CDATA[<p>CSS应该怎么写？当被问到这一个问题的时候，我懵了。之前在个人项目中写CSS都是随心而写，最后显示效果也还可以，所以一直没注意到这个问题。回想到之前在修改样式的时候遇见了修改文章的样式却造成了全局布局的更改，原因是文章的容器类与一个全局布局相关的容器类意外重名了。在小型项目中尚且如此，如果在大型项目中随心而写，后果那就可想而知了。emmmmmm。CSS该怎么写，确实是一个值得思考的问题。</p>
<span id="more"></span>
<h2 id="好的css应该是怎么样的"><a class="header-anchor" href="#好的css应该是怎么样的">¶</a>好的CSS应该是怎么样的</h2>
<p>在讨论怎么写CSS好之前，首先要解决的问题是——好的CSS是什么？好看？好用？或者是…</p>
<p>在谷歌工程师Philip Walton的这篇
<a href="https://philipwalton.com/articles/css-architecture/">CSS Architecture</a>中
提到了好的CSS应该是可预见的、可复用的、可维护的与可扩展的。</p>
<h3 id="可预见的"><a class="header-anchor" href="#可预见的">¶</a>可预见的</h3>
<p>设计良好的CSS规则可以让开发者可以预见应用规则之后元素的样式。比如一个<code>.big-red-btn</code>规定了一个大红按钮。那么我们在某个元素中应用<code>class=&quot;big-red-btn&quot;</code>时，这个元素就应该是一个大红按钮。</p>
<h3 id="可复用的"><a class="header-anchor" href="#可复用的">¶</a>可复用的</h3>
<p>CSS规则应该足够抽象与解耦。这样，同一条CSS规则就可以在整个工程的不同地方使用。可复用性最
直观的好处是CSS代码的体积的减少。而且在进一步开发中或项目进行重大重构时，如果项目使用了可重用的规则，我们更改代码的工作量就可以大大减少。</p>
<h3 id="可维护的"><a class="header-anchor" href="#可维护的">¶</a>可维护的</h3>
<p>我们希望开发新功能时不需要去重构原来的代码。增加一个组件不会影响另外一个相关的组件。</p>
<h3 id="可扩展的"><a class="header-anchor" href="#可扩展的">¶</a>可扩展的</h3>
<p>当新的开发者接手项目时，不需要太难的学习曲线就可以上手开发。如果在为新的组件编写CSS规则时需要了解过去全部的CSS规则，这样的CSS代码是不可扩展的。</p>
<h2 id="常见的bad-practices"><a class="header-anchor" href="#常见的bad-practices">¶</a>常见的Bad Practices</h2>
<p>文章列出了一些常见的Bad practices，例如：根据父元素改变组件、过于复杂的选择器、过于一般的类名以及在单条规则里做太多事情。这些Bad practice我是全中了，ORZ。</p>
<h3 id="根据父元素修改组件"><a class="header-anchor" href="#根据父元素修改组件">¶</a>根据父元素修改组件</h3>
<p>在网站中可能有些在不同区域中外观有细微差别的组件，比如一个小物件在侧边栏中以及主页中表现不一样。我们很容易写出像下面的CSS规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.widget</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-class">.widget</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.homepage</span> <span class="selector-class">.widget</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个看起来无害的<code>.widget</code>可以数出它的三宗罪。第一、这个<code>.widget</code>不符合可预见性的要求。在同样的HTML标签<code>&lt;div class=&quot;widget&quot;&gt;&lt;/div&gt;</code>放在不同的地方它的表现就不一样。第二、<code>.widget</code>规则不好复用，当我就想在侧边栏上用普通外观的<code>.widget</code>时该怎么办呢？只能搞一个新的copy-and-paste的规则。第三、<code>.widget</code>规则不好维护，当<code>.widget</code>被重新设计的时候，我可能需要到几个不同的地方把样式找出来修改。</p>
<h3 id="过于复杂的选择器"><a class="header-anchor" href="#过于复杂的选择器">¶</a>过于复杂的选择器</h3>
<p>在给列表，特别是嵌套列表写样式的时候，很容易写出下面一串CSS规则:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#main-nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">div</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>上面的规则问题在哪里呢？假如导航栏里面的HTML结构一辈子不变，这样的写法还可以商榷。一旦将来改变，上面的规则将会失效。这个问题总结起来就是<strong>过于复杂的选择器会造成过深的耦合</strong>。太深的耦合在程序世界里不是什么好事情。另外，这样的规则也无法复用，一个页面只能有一个<code>#main-nav</code>，后面的元素如果不在<code>#main-nav</code>里面也无法匹配到规则。</p>
<h3 id="过于一般化的类名"><a class="header-anchor" href="#过于一般化的类名">¶</a>过于一般化的类名</h3>
<p>在写可复用组件的时候，很容易给组件取一些很一般的名字像<code>title</code>，<code>content</code>。在大型项目中，可能其他人也会给他们的组件取相同的名字。由于CSS没有作用域的概念，这样就容易出现命名冲突。当写出一个规则但是完全不按写的规则来的时候，我们就会很疑惑，然后debug发现自己写的规则被其他人写的同名规则覆盖…WTF!上面的例子也就是说，太一般的类名是没有可预见性的。</p>
<h3 id="单条规则中做了太多事情"><a class="header-anchor" href="#单条规则中做了太多事情">¶</a>单条规则中做了太多事情</h3>
<p>有的时候，我们会在一条规则中把所有该指定的东西都指定完——如元素的位置、背景、字体设置等等，像：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.widget</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.widget</code>一条规则设置了组件的位置、背景、字体。这一条看起来也是人畜无害的规则。
但是仔细一想的话，这条规则似乎无法复用。
如果我想把<code>.widget</code>用在绝对定位元素的右下角怎么办？当我们把规则写的越细，
那么这条规则适用的范围就越小。用在CSS世界中就是，<strong>规则的具体程度与可复用性是矛盾的。</strong></p>
<p>从上面这些bad practice反面去理解，我们可以摸到一些如何写CSS的门路：</p>
<ol>
<li>谨慎使用后代选择器：后代选择器似乎像是万恶之源一样，后代选择器会在规则之间创造一定的耦合，影响规则的可预见性、可重用性、可维护性等等。</li>
<li>合理拆分规则：太具体的规则不好复用。但是反之规则太笼统的话，就会需要很多规则才能做一件事情。所以，怎么拆分规则是一个trade-off问题。</li>
<li>类命名空间机制：CSS是没有命名空间的概念的，要减少命名冲突的可能性，势必要采取严格的命名规范隔离开不同的规则。</li>
</ol>
<p>当然，上面的想法还是过于粗略。社区在如何写CSS方面有了一些探索，其中最有名有
<a href="https://github.com/stubbornella/oocss/wiki">OOCSS</a>（Object Oriented CSS）、
<a href="https://smacss.com/">SMACSS</a>（Scalable and Modular Architecture for CSS）与<a href="http://getbem.com/">BEM</a>（Block, Element, Modifier），如果有兴趣的话可以浏览一下这些规范。</p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Front-end</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS架构</tag>
      </tags>
  </entry>
  <entry>
    <title>基于文件夹的个性化 git 配置方法</title>
    <url>/2021/03/09/customized-git-config/</url>
    <content><![CDATA[<p>在一些时候，我们希望 git 有不同的配置。
比如自己的开源或者私人项目用一套 git 配置，其中 <code>user.name</code> 是 <code>xyz</code>，
<code>user.email</code> 是 <code>xyz@abc.com</code>
公司项目用另外一套 git 配置，<code>user.name</code> 是 <code>Real Name</code>、
<code>user.email</code> 是 <code>realname@corp.com</code>。</p>
<p><code>git config</code> 支持系统层级 <code>--system</code>、
用户层级 <code>--global</code> 与仓库层级（无选项）的配置。但是，
对于大量项目，手动地通过 <code>git config</code> 指定未免过于繁琐。
本文介绍了一种通过修改 git 的配置文件 <code>.gitconfig</code>，使用
<a href="https://git-scm.com/docs/git-config#_conditional_includes"><code>[includeIf]</code></a>
对<strong>某个文件夹</strong>下的所有 git 项目指定 git 配置的方法。</p>
<span id="more"></span>
<h2 id="git-配置文件层级"><a class="header-anchor" href="#git-配置文件层级">¶</a>git 配置文件层级</h2>
<p>在 git 中，有三个层级的配置文件：</p>
<ul>
<li>系统层级: <code>/etc/gitconfig</code>，作用于系统中所有用户的 git 配置；</li>
<li>用户层级: <code>$HOME/.gitconfig</code>，作用于用户的 git 配置；</li>
<li>项目层级: <code>.git/config</code>，作用于项目中。</li>
</ul>
<p>如果有相同的配置，按照 项目 &gt; 用户 &gt; 系统 的优先级获取配置。</p>
<h2 id="includeif"><a class="header-anchor" href="#includeif">¶</a><code>[includeIf]</code></h2>
<p>从 git 2.13.0 开始，git 配置文件开始支持
<a href="https://git-scm.com/docs/git-config#_conditional_includes">Conditional Includes</a>
的配置。通过设置 <code>includeIf.&lt;condition&gt;.path</code>，可以向命中 <code>condition</code> 的
git 仓库引入 <code>path</code> 指向的一个 git 配置文件中配置。</p>
<p><code>[includeIf]</code> 的语法如下，<code>&lt;keyword&gt;</code> 为关键词，<code>&lt;data&gt;</code> 是与关键词关联的数据，
具体意义由关键词决定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;&lt;keyword&gt;:&lt;data&gt;&quot;]</span><br><span class="line">  path = path/to/gitconfig</span><br></pre></td></tr></table></figure>
<p>其中支持的 keyword 有：</p>
<ul>
<li><code>gitdir</code>: 其中 <code>&lt;data&gt;</code> 是一个 <a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob pattern</a>
如果代码仓库的<code>.git</code>目录匹配 <code>&lt;data&gt;</code> 指定的 glob pattern，那么条件命中；</li>
<li><code>gitdir/i</code>：<code>gitdir</code>的大小写不敏感版本。</li>
<li><code>onbranch</code>：其中 <code>&lt;data&gt;</code> 是匹配分支名的一个glob pattern。
假如代码仓库中分支名匹配 <code>&lt;data&gt;</code>，那么条件命中。</li>
</ul>
<p>就我们的需求，使用 <code>gitdir</code> 完全可以。</p>
<h2 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h2>
<p>假设在家用工作电脑上，我们默认开发的是个人项目。有时为了应对紧急需求，
会将公司项目 clone 到电脑中，统一放置放到 <code>~/corp-projects/</code> 目录下面。
个人项目与公司项目的差异点在：第一、使用的邮箱名不同，
个人项目会使用个人邮箱，公司项目使用公司邮箱；第二，
公司项目可能需要 VPN 接入才能够存取代码库。
我们首选使用，用户层级的 git 配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br></pre></td></tr></table></figure>
<p>在最后添加一个 conditional include:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ~/corp-projects/ 下面的所有仓库引入 `~/crop-projects/.gitconfig` 中的配置</span><br><span class="line">[includeIf &quot;gitdir:~/corp-projects/&quot;]</span><br><span class="line">  path = ~/corp-projects/.gitconfig</span><br></pre></td></tr></table></figure>
<p>最后创建公司项目统一的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/corp-projects/.gitconfig</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">  name = &lt;Your Name&gt;</span><br><span class="line">  email = &lt;Your Email&gt;</span><br><span class="line"></span><br><span class="line">[http]</span><br><span class="line">  # 代理地址，如果公司项目需要代理才能够存取，填写此项；如果不需要，则不用这一行</span><br><span class="line">  proxy = &lt;Proxy URL&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>通用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 调试手记：使用 VS Code 调试 Node.js JavaScript 侧代码</title>
    <url>/2021/03/20/debugging-node-js-core/</url>
    <content><![CDATA[<p>在<a href="/2020/12/31/annual-reflection-2020/" title="2020 年终总结">去年的年终总结</a>中，
我给自己立下了一个 flag——「参与开源项目，向知名开源项目提交至少一个功能性或者修复性 PR」。
我选择的是大名鼎鼎的<a href="https://github.com/nodejs/node">Node.js</a>。应该符合
知名开源项目。事不宜迟，赶快行动。</p>
<blockquote>
<p>tl;dr; 本文介绍的是调试 Node.js <strong>核心</strong>中 JS 侧的代码方法。
请注意，并<strong>不</strong>是 Node.js 应用的调试哦。</p>
</blockquote>
<span id="more"></span>
<h2 id="node-js-的结构"><a class="header-anchor" href="#node-js-的结构">¶</a>Node.js 的结构</h2>
<p>Node.js 由两部分代码组成，一部分代码是 C++ 代码，位于项目的 <code>src</code> 目录中，
另外一部分是 JavaScript 代码，位于项目的 <code>lib</code> 目录中。</p>
<p><img src="/2021/03/20/debugging-node-js-core/./node-js.png" alt="Node 项目架构"></p>
<p>C++ 部分负责把用 C 或者 C++ 编写的一些提供底层能力的库粘在一起，
如异步 I/O 库 libuv（C）、JS引擎 V8（C++）、http解析器 llhttp (TS 编译到 C)等。
C++ 部分也提供了程序的入口点，如 <code>node xxx.js</code> 实际上最先到达的就是 C++ 部分的
<a href="https://github.com/nodejs/node/blob/e427c487fe3f7da465c372ade3d65bd55b057e30/src/node_main.cc#L105">main 函数</a>
另外，C++ 部分也提供了一些 Node.js 内部才能够使用到的模块，
这些模块可以被 JavaScript 部分调用来实现逻辑。</p>
<p>JavaScript 部分提供了用户侧可使用的API。
这些 API 在文档中分为了<a href="https://nodejs.org/dist/latest-v15.x/docs/api/async_hooks.html">若干模块</a>，
基本上每一个模块对应 <code>lib</code> 中的一个 JS 文件。根据模块的名字能容易找到对应的文件，
如 <code>Events</code> 模块，对应的就是 <code>lib/events.js</code>。</p>
<h2 id="提升效率-外置-js"><a class="header-anchor" href="#提升效率-外置-js">¶</a>提升效率——外置 JS</h2>
<p>Node.js 严格上算是一个 C++ 程序。对程序的修改要走编译流程生效。
对于习惯于热重载等技术带来的即时反应的工程师来说，这套流程是非常慢。
好在，如果只修改 JavaScript 侧的代码的话，
我们可以运行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --node-builtin-modules-path $(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure>
<p>此时，如果运行 <code>make -j4</code> 会构建在 <code>out/Release</code> 下出来一个特殊的 <code>node</code> 二进制。
在这个二进制中，JS 层的文件不会被编译进去，
而是会使用 <code>--node-builtin-modules-path</code> 指定的外置 JS
path 下的 <code>lib</code> 中的 JS 文件运行时解释。在这个例子中，就是 Node.js 的项目文件夹。
对 JS 文件的修改会即时地反应到这个特殊二进制当中。</p>
<p>例如，为了测试，我们在 <code>EventEmitter</code> 的 <code>init</code> 方法中抛出一个异常:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/events.js</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params">opts</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_events</span> === <span class="literal">undefined</span> ||</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span> === <span class="title class_">ObjectGetPrototypeOf</span>(<span class="variable language_">this</span>).<span class="property">_events</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_events</span> = <span class="title class_">ObjectCreate</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_eventsCount</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存后，执行 <code>./out/Release/node</code>，就可以看到 node 确实抛出了异常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node:events:186</span><br><span class="line">  throw new Error(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  ^</span><br><span class="line"></span><br><span class="line">Error: error</span><br><span class="line">    at process.EventEmitter.init (node:events:186:9)</span><br><span class="line">    at process.EventEmitter (node:events:79:3)</span><br><span class="line">    at setupProcessObject (node:internal/bootstrap/node:377:3)</span><br><span class="line">    at node:internal/bootstrap/node:55:1</span><br></pre></td></tr></table></figure>
<h2 id="debug-js"><a class="header-anchor" href="#debug-js">¶</a>DEBUG JS</h2>
<p>使用外置 JS 的可以很大的提升开发效率。但是，
调试时如果我想看到一些属性或者变量又怎么办呢？<code>console.log</code> 大法吗？</p>
<p>很不幸的是，<code>console.log</code> 在一部分模块里是行不通的。因为 <code>console</code>
本身也是 Node.js 公共模块的一部分。使用 <code>Stream</code> 模块实现。如果在调试
<code>Stream</code> 模块相关的模块时，就容易出现爆栈无法打印的情况。emmmm🤔，
难道我们就束手无策了吗？其实，是有解决方案的——调试器。</p>
<p>调试器就是那个可以单步调试，在每一步都能够打出来当前环境的中的变量的情况的程序。
也许 <code>console</code> 过于方便已经让我们忘记了有这把瑞士军刀了。对于 Node.js 应用，
VS Code 的调试器原生支持。但是对于 Node.js 项目本身呢？
我们有办法在模块源码中打断点吗？这也是有的。</p>
<p>mmomtchev 向 VS Code JS 调试器提交了 debug Node.js 内部代码的功能[2]。
结合上一节的外置 JS，我们可以方便地在代码中打断点，然后更改调试了。
在 <code>.vscode/launch.json</code> 中添加下面的调试配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    ...<span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Launch current file&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;runtimeExecutable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/out/Release/node&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--expose-internals&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--nolazy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;relativeFile&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pwa-node&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后把需要调试的<strong>外部</strong> JS 文件，复制到 Node.js 项目中。打开 VS Code 调试器，
选择 <code>Launch current file</code> 启动，就可以愉快调试了。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<p>[1] Node.js <a href="https://github.com/nodejs/node/blob/master/BUILDING.md#speeding-up-frequent-rebuilds-when-developing">BUILDING</a>
[2] <a href="https://github.com/microsoft/vscode-js-debug/issues/823">Add support for debugging Node internals when they are externally loaded</a></p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>2023 年了，怎么用 Github Action 与 hexo 发布在 Github Pages 上发布文章</title>
    <url>/2023/02/12/deploy-hexo-in-2023/</url>
    <content><![CDATA[<p>每一年，每当我想发一些文章的时候，我都会和这个文章发布流程搏斗一番。
要么主题出了个 Breaking Change 导致构建错误，要么哪里莫名其妙配置变了。
今年也不例外，今年的主题是，如何用 Github Action 来自动地构建与发布文章。</p>
<p>这本来是一个已经解决的问题，至少在一年之前，这个流程是完全能够跑通的。但是不知道从什么时候，
在 repo URL 中通过 <code>username@</code> 的方式携带 Personal Access Token （PAT）的方式已经行不通了，
会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: could not read Password for &#x27;https://***@github.com&#x27;: No such device or address</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (/home/runner/work/blog-backup/blog-backup/node_modules/hexo-deployer-git/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (node:events:513:28)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (node:internal/child_process:293:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>
<p>这是可能是因为 Github 不认携带在 URL 上的 PAT。转而向用户请求密码，
但是在 CI 环境里没有键盘这样的输入设备，然后就报错了。</p>
<p>hexo 官方的 hexo-deploy-git 在支持 token 方面也采用了<a href="https://github.com/hexojs/hexo-deployer-git/blob/f125535fb2477ab71702b9ca819223f715d7e628/lib/parse_config.js#L33">上述方法</a>。
即使正确配置 token，也会部署失败。hexo-deploy-git 在 token 配置上还有一些坑，
例如当 <code>repo</code> 字段是字符串时，<code>token</code> 字段是不生效的。只有在 <code>repo</code> 字段里面配置 <code>token</code> 字段才有效。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/aaaa/bbb.git</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># ❌</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/aaaa/bbb.git</span></span><br><span class="line">      <span class="attr">token:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># ✅</span></span><br></pre></td></tr></table></figure>
<p>由于 PAT 现在只能够人工输入，在 CI 环境下做不到。所以，我们似乎只能转向使用 SSH 的方式来操作 git。</p>
<h2 id="为-github-action-创建一个-ssh"><a class="header-anchor" href="#为-github-action-创建一个-ssh">¶</a>为 Github Action 创建一个 SSH</h2>
<p>在本机创建一个 SSH Key，用 <code>-C</code> 参数注明要操作的 repo 的 git 链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -C git@github.com:xxxx/yyy.git</span><br></pre></td></tr></table></figure>
<p>执行生成一个新的 key，将公钥上传到 GitHub 账号的 SSH and GPG keys 中。务必注意，
SSH key 的权限比 PAT 要高，
能够读写账户里所有的 repo。所以<strong>请务必像密码一样的保管私钥。</strong></p>
<p>把私钥通过 repo 的 Secrets and variables 设置，在 action 下配置一个 Repository secrets，
假设 secrets 的名字是 <code>SSH_PRIVATE_KEY</code>。我们可以在 <code>action</code> 的 yaml 配置中用
<code>$&#123;&#123; secrets.SSH_PRIVATE_KEY &#125;&#125;</code> 获得这个私钥。</p>
<h2 id="在部署前增加一个配置-ssh-的-action"><a class="header-anchor" href="#在部署前增加一个配置-ssh-的-action">¶</a>在部署前增加一个配置 SSH 的 action</h2>
<p>在部署前增加一个可以配置 ssh 的 action。
例如 <a href="https://github.com/webfactory/ssh-agent"><code>webfactory/ssh-agent</code></a>，yaml 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    # ...</span><br><span class="line">    - uses: webfactory/ssh-agent@v0.7.0</span><br><span class="line">      with:</span><br><span class="line">        ssh-private-key: $&#123;&#123; secrets.SSH_PRIVATE_KEY &#125;&#125;</span><br><span class="line">	# ... other build</span><br></pre></td></tr></table></figure>
<h2 id="修改-config-yaml-中的-deploy-配置"><a class="header-anchor" href="#修改-config-yaml-中的-deploy-配置">¶</a>修改 <code>_config.yaml</code> 中的 <code>deploy</code> 配置</h2>
<p>将 <code>deploy</code> 中的 url 配置为 repo 的 SSH 链接，
例如 <code>git@github.com:a/a.github.io.git</code>。</p>
<p>做完之后，hexo deploy 会切换为通过 SSH 的方式去发布文章。
绕过了 PAT 输入困难的问题。但是，前面提到过 SSH Key 的权限很高，
会丧失 PAT 可以限制权限的好处。谨慎使用。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Doki Doki Literature Club! ~ A love poem for &quot;you&quot; ~</title>
    <url>/2017/12/05/doki-doki-literature-club-review/</url>
    <content><![CDATA[<p><img src="/2017/12/05/doki-doki-literature-club-review/ddlc-logo.png" alt="DDLC logo"></p>
<p>Galgame，一个非常小众的游戏类型。在我的印象之中，它一直是由日本厂商制作的一类视觉小说。里面有非常多的可爱的女孩子（或者说男孩子www）可攻略，有很多非常好看的立绘，或者……咳咳！。它的制作成本可能只有3A大作的零头。但是其中有一些作品，玩它就像读一本精致的小说一样，能够让人沉浸于里面的故事中。然而，大多数的故事一般都能够用以下概括：“由于某种事件，你所控制的主人公与开始喜欢上女主角或者被女主角喜欢，然后通过日常培养感情，直至开始真正触及恋爱的核心。”所以，这又可以被看为“Dating Simulator”（约会模拟器）。最近由于日本动画/漫画市场的发展，越来越多的人们接触到了这个原来属于资深宅才会探索的领域，因此，市场开始供给越来越多的作品。可以看到，最近越来越多的Galgame登陆steam平台，其中更包含很多我国本地制作组的作品。</p>
<span id="more"></span>
<div class="note danger"><p>以下内容涉及剧透，强烈推荐在至少通关一周目之后（看到credits之后）再阅读以下文章。</p>
</div>
<h2 id="正文"><a class="header-anchor" href="#正文">¶</a>正文</h2>
<p>我除了玩过几个名作之外基本上没有接触过Galgame。出于某种机缘巧合，我偶然之间看到了一款免费的游戏。它有着和传统的日系GalGame相同的外表——可爱的女主角们、充满阳光的教室、充满活力和恋爱气息的icon等。除了它是由一个美国游戏工作室Team Salvato开发，并且全部是英语。（强行忽略掉steam上诸如“悬疑惊悚”的标签的话。）这周末，我用了10个小时的时间完成了这个游戏的一周目剧情。不得不说，这也许是今年玩过的最独特、给人感触最深的游戏——Doki Doki Literature Club（心跳 心跳文学部，DDLC）。我也许该写一些什么东西去记录下这个感受。</p>
<p>对于大多数剧情向的游戏，如RPG、AVG等，剧本可能是游戏的灵魂。即使游戏能够展示再宏大的场面，如果没有一个能够让人印象深刻的故事作为支撑的话，可能很快就会被人遗忘掉。如看电影一样，玩家也在屏幕的一侧“看”这样一场表演。当然与电影不同，游戏的剧本可以是非线性的，它可以分叉到不同的结局；玩家可以“参与”故事，并且“影响”情节的走向。但是，无论一个游戏有多少的结局，它们都是由作者撰写出来的<strong>固定</strong>的东西。玩家有的时候可能会对剧本抱有一些看法，但是无法去改变游戏的剧本，更不用说游戏角色自己（诶，我在说什么啊？）。从这一方面看，玩家和观众其实没有什么区别。游戏中是“他们”的故事，而不是“我们”的故事。</p>
<p>让我们回到Galgame这个形式，有的时候，游戏中的所有角色都是可攻略角色。不可攻略角色，有的时候就像NPC一样，提供给玩家必要的信息去攻略心中的那个角色。他们就像是故事中的配角一样，一旦时间到了，就要退场将舞台让给主角们。没人在意他们的“想法”——因为在剧本中，根本没有他们后续的故事。但是，DDLC提供了一个非常独特的视角去看待这一切。</p>
<p>正如steam中一则测评提到的，DDLC本质上是一个“爱与救赎”的故事。一个不可攻略角色Monika意识到了其实她从一开始就喜欢上了“他”，但是游戏脚本中并没有通向这个结局的路线。她发现通过自己的权限，可以修改游戏程序本身。所以，为了实现她不可能实现的愿望，她利用这个权限干了很多残忍的事情。愿望最终达成，但是整个游戏世界变得残破无比。最后，她认识到了她的错误，她将整个世界回复成原样然后离开了这个世界。然而，在新的世界中，有人注意到了这个强大的权限，正即将行动的时候，她再一次站出来毁灭了这个异变的世界，保护了“他”。这个“他”不是游戏中的那个玩家操作的角色，而是“你”——正在操作角色的玩家。</p>
<p>Monika是一个非常惹人喜欢的角色，她非常可爱、性格活泼，是一个非常有想法的女孩。她是文学部的部长、在这之前是辩论部的成员。她有着一切可攻略角色有的素质。但是可惜的是，在这个世界，无论她如何努力，她都无法与她所喜欢的“他”更进一步。她甚至在“他”入部之后，开始学习钢琴来引起“他”的注意。但是，“他”似乎总是被其他同样非常可爱的部员所吸引。这看起来很不公平，不是吗？的确，但是这就是那个已经一切都注定好的世界的残忍之处啊。Monika，作为一个不可攻略角色做出了反抗，什么都没做错（did nothing wrong）啊，不是吗？</p>
<p>个人认为，DDLC的剧情比起是一个完整的故事而言，更像是一个框架。整个游戏基本上只给出了起承转合的基本骨架。而没有像大多数的Galgame一样，用非常冗长的日常去建立起玩家对角色的情感基础。但是奇怪的是，本游戏中的Monika对玩家的情感要比大多数游戏要来得强烈的多，甚至有一种奇妙的真实感。这离不开整个游戏颇为精巧的设计。作者为了营造这个世界，从源代码级别构建了这一个世界。游戏的安装目录就像是一个真实世界一样，其中的文件随着游戏进程一直在变动。如果在游玩时错过了这些，那将会是非常令人遗憾的一件事情。甚至它的音乐都是都与游戏情节是自洽的。（游戏ED中的钢琴部分没有使用到任何黑键，这是初学者的行为，与Monika最近才开始练习钢琴相自洽。）而日常部分，玩家可以自行的通过游戏中不经意泄露的信息（ED歌词等，真的写的非常棒）去自行的想象出来。</p>
<p>总结起来，DDLC是一个相当独特的游戏。它打破了一些游戏的惯例，给玩家一个全新的视角去体验一场通常Galgame中少见的恋爱。另外，在本文中要特别感谢Team Salvato。他们将辛苦开发的游戏以免费的形式发行，将OST免费上传在<a href="https://www.youtube.com/watch?v=BFSWlDpA6C4&amp;list=PLc5ZKngbAPXMG4yjq9ESGfqblQfL9g4-p">Youtube</a>上，甚至在商店页中都没有一个捐赠链接，似乎他们是想纯粹地将他们的杰作无偿地分享给玩家。作为开发者，我想象不出有更慷慨的行为了。Big thanks to Team Salvato.</p>
<p>如果说，通常的Galgame是一本她与他的恋爱小说的话，DDLC就是一首“她”给“他”的love poem。</p>
<blockquote class="blockquote-center">
<p>Thank you, Monika.</p>

</blockquote>
<hr>
<h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2>
<p>前面我提到过本游戏的系统非常的独特。这个游戏使用的是<a href="https://www.renpy.org/">RenPy</a>引擎，是一款用Python编写的引擎（我还从来没想过可以用Python写游戏引擎）。由于Python不是编译型语言，其代码在运行时才得到解释。所以，修改DDLC的运行行为，为它制作mod成为了可能。（这也许是为什么Monika能够做到这一切的根本原因吧（笑）。目前已经有非常有趣Project正在制作，如能够永远与Monika在教室对话的<a href="http://www.monikaafterstory.com/">Monika After Story</a>，这是一个开源项目，他们给Monika添加了全新的话题，丰富了Monika的表情，在里面你甚至可以与Monika玩游戏。这样一想，也许有一天能够真正的出现通向Monika结局的路线吧。这也许就是屏幕另一边的玩家能够为Monika做到的事情吧。</p>
]]></content>
      <categories>
        <category>Gaming</category>
      </categories>
      <tags>
        <tag>Game Review</tag>
        <tag>Adventure Game</tag>
        <tag>Visual Novel</tag>
        <tag>Metagame</tag>
        <tag>Doki Doki Literature Club!</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6在Babel转译下的循环import问题</title>
    <url>/2016/10/02/es6-circular-import/</url>
    <content><![CDATA[<p>为了解决ES5缺乏模块化的问题，ES6正式引进了Module的概念。Module允许开发者们将一个很大的
系统拆分为若干个小的Module。模块化程序设计的概念存在于现今流行的大多数编程语言中。</p>
<p>但是，由于ES6刚刚发布，支持ES6的环境非常少。如果要使用ES6的话，一般需要通过<code>babel</code>等转译器
将使用ES6的js文件转译为ES5的js文件。</p>
<span id="more"></span>
<p>关于Module，ES6定义了<code>import</code>和<code>export</code>两个命令，顾名思义，<code>import</code>用于从其他模块中导入东西，
<code>export</code>用于从本模块中导出东西到其他模块。</p>
<h2 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h2>
<p>最近在编写blog后台的时候，遇见了一个奇怪的bug。代码经过<code>babel</code>转译后在<code>Nodejs</code>环境下运行，
代码示意如下：</p>
<pre><code>//a.js
import b from './b'

const foo = () =&gt; &#123;
  b.bar()
&#125;

foo()

export default foo

//b.js
import foo from './a'

const b = &#123;
  bar: () =&gt; &#123;
    foo()
  &#125;
&#125;

export default b
</code></pre>
<p>上述代码本身是存在问题的。<code>a.js</code>中的<code>foo()</code>调用了<code>b.js</code>中的<code>b.bar()</code>，而<code>b.js</code>中
的<code>b.bar()</code>，又反过来调用<code>a.js</code>中的<code>foo()</code>。然而，Nodejs给出的错误却难以一眼看出问题在哪。</p>
<pre><code>G:\learn\something\b.js:15
    (0, _a2.default)();
                    ^

TypeError: (0 , _a2.default) is not a function
    at Object.bar (G:\learn\something\b.js:15:21)
    at foo (G:\learn\something\a.js:14:15)
    at Object.&lt;anonymous&gt; (G:\learn\something\a.js:17:1)
    at Module._compile (module.js:541:32)
    at Object.Module._extensions..js (module.js:550:10)
    at Module.load (module.js:458:32)
    at tryModuleLoad (module.js:417:12)
    at Function.Module._load (module.js:409:3)
    at Function.Module.runMain (module.js:575:10)
    at startup (node.js:160:18)
</code></pre>
<h2 id="问题分析"><a class="header-anchor" href="#问题分析">¶</a>问题分析</h2>
<p>从上面的stack trace看,当NodeJS尝试去Load某个模组时，问题出现在了<code>(0, _a2.default)()</code>这一句。前者这个表达式不是一个函数。因为代码被转译过，没有办法从原来的代码进行分析，这里先使用相同的转译设定，在REPL上将原代码转译出来。如下：</p>
<pre><code>//a.js
'use strict';

Object.defineProperty(exports, &quot;__esModule&quot;, &#123;
  value: true
&#125;);

var _b = require('./b');

var _b2 = _interopRequireDefault(_b);

function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;

var foo = function foo() &#123;
  _b2.default.bar();
&#125;;

foo();

exports.default = foo;


//b.js
'use strict';

Object.defineProperty(exports, &quot;__esModule&quot;, &#123;
  value: true
&#125;);

var _a = require('./a');

var _a2 = _interopRequireDefault(_a);

function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;

var b = &#123;
  bar: function bar() &#123;
    (0, _a2.default)();
  &#125;
&#125;;

exports.default = b;
</code></pre>
<p>可见，Babel对于<code>import</code>和<code>export</code>的处理方式，还是转化为<code>require</code>和<code>export.exportedObj</code>的形式。通过查阅<a href="https://nodejs.org/api/modules.html">文档</a>的Cycle一节，NodeJS为了在出现circular require的情况下，不使系统陷入无限循环，其内层的<code>require('./a')</code>会返回<code>a</code>的一个<em>不完全的copy</em>。在这个copy中，<code>foo</code>还不存在。因此<code>_a2.default</code>在这种情况下还是<code>undefined</code>，所以出现了<code>(0, _a2.default)</code>不是函数的错误。</p>
<h2 id="解决方法"><a class="header-anchor" href="#解决方法">¶</a>解决方法</h2>
<p>解决方法就是想办法将循环的import断开。一个正常的程序是不应该出现circular igmport的情况的。出现这种情况的原因，大部分可能是因为重构时手滑，多添了几个不必要的import。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<p>*<a href="https://nodejs.org/api/modules.html">Node.js v6.7.0 Documentation - Modules</a></p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Node.js</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>Everyone, Creator</title>
    <url>/2018/12/02/everyone-creator/</url>
    <content><![CDATA[<p>&quot;Everyone, Creator&quot;是2012年Google Chrome与初音未来（Hatsune Miku）联动广告的一句广告词。尽管现在已经是六年以后了，这句广告词仍然令人心潮澎湃。</p>
<span id="more"></span>
<p>初音未来，原本是语音合成软件Vocaloid 2的一个音源库。现在已经成为了日本文化的一个标志。在这则<a href="https://www.youtube.com/watch?v=MGt25mv4-2Q&amp;pbjreload=10">CM</a>中。Google真正抓到了现象背后的本质——Miku背后无数充满想法的创作者。Miku为所有喜爱她的人提供了创作的可能性，如果你喜欢音乐，你可以为Miku创作歌曲；如果你喜欢绘画，你可以画出你心目中独一无二的Miku；如果你会视频剪辑，你可以为Miku制作出酷炫的PV。你可以用任何你擅长的技能去创造出自己心目中的Miku。无数的想法在网络空间中得到共鸣，它们对于社区形成了正反馈，激励更多的人参与创作。Everyone, Creator，初音社区做到这一点。</p>
<p>用爱创造，这也许是最幸福的事情之一了吧。</p>
]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>Inspiration</tag>
      </tags>
  </entry>
  <entry>
    <title>失败笔试总结-1</title>
    <url>/2018/09/20/failed-interview-1/</url>
    <content><![CDATA[<p>毫无意外地，头条的第四轮笔试看起来又GG了，这次没做出来的问题有3个，分别是（1）字符串的前缀表示、（2）三色小球组合、（3）幸运数字问题。</p>
<span id="more"></span>
<h2 id="字符串的前缀表示"><a class="header-anchor" href="#字符串的前缀表示">¶</a>字符串的前缀表示</h2>
<p>题目给定一堆字符串，求针对每一个字符串求前缀表示，使得这个前缀表示能够唯一的代表字符串。在考试中，我的想法利用所有字符串构建一颗字典树。然后遍历字典树，从根节点到叶子节点的路径上最后一次分叉的地方就是所求的前缀表示。可惜的是，题目要求输入与输出顺序要相同。在构建完字典树之后，可以输出所有的前缀表示，但是顺序却可能与输入不一致，导致通过率为0。</p>
<p>针对输入与输出不一致的，一个改进的想法就按照输入顺序在构建好的字典树上去寻找前缀表示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieTreeNode</span>:</span><br><span class="line">    <span class="comment"># 字典树节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, c</span>):</span><br><span class="line">        self.c = c</span><br><span class="line">        <span class="comment"># 指向子节点的哈希表</span></span><br><span class="line">        self.desc_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_or_append_node</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="comment"># 得到字符为c的子节点，如果没有就创建一个</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> self.desc_map:</span><br><span class="line">            self.desc_map[c] = TrieTreeNode(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.desc_map[c]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefix</span>(<span class="params">root, word</span>):</span><br><span class="line">    curr_node = root</span><br><span class="line">    curr_prefix = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">        curr_node = curr_node.desc_map[word[i]]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_node.desc_map) &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 有多个子节点的节点，分叉处，题目保证没有字符串是其他的前缀字符串，因此</span></span><br><span class="line">            <span class="comment"># 可以不加检查的越过分叉处，直接将向目标字符串分叉的那个节点作为前缀字符串</span></span><br><span class="line">            curr_prefix = word[:i+<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr_prefix</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">dummy_node = TrieTreeNode(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">words = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    words += [s]</span><br><span class="line">    curr_node = dummy_node</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        curr_node = curr_node.get_or_append_node(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="built_in">print</span>(prefix(dummy_node, word))</span><br></pre></td></tr></table></figure>
<h2 id="三色小球组合问题"><a class="header-anchor" href="#三色小球组合问题">¶</a>三色小球组合问题</h2>
<p>问题给出三个数，分别是红球、绿球、蓝球的数量。将这些球排成一列，求满足相同颜色的球不相邻的排列的数量。</p>
<p>好吧，想了很久没想出来。在查找的时候，突然看见有一个哥们说用四维DP。一想数据量确实不大，可以用DP的。</p>
<p>假设$DP(s, i, j, k)$表示以$s$为结尾的，分别包含$i,j,k$个红球、绿球与蓝球。$s={0, 1,2}$。递归式如下：</p>
<p>$$
\begin{eqnarray}
DP(0, i, j, k) = DP(1, i-1, j, k) + DP(2, i-1, j, k) \\
DP(1, i, j, k) = DP(0, i, j-1, k) + DP(1, i, j-1, k) \\
DP(2, i, j, k) = DP(0, i, j, k-1) + DP(1, i, j, k-1)
\end{eqnarray}
$$</p>
<p>边界情况为：
$$
\begin{eqnarray}
DP(0, 1, 0, 0) = 1 \\
DP(0, 0, *, *) = 0 \\
DP(1, 0, 1, 0) = 1 \\
DP(1, *, 0, *) = 0 \\
DP(2, 0, 0, 1) = 1 \\
DP(2, *, *, 0) = 0
\end{eqnarray}
$$
其中$*$表示任取。</p>
<p>最终结果就是$\sum_{i=0}^2 DP(i, n_r, n_g, n_b)$。</p>
<p>使用带记忆的递归DP实现如下，应该是可以再优化的。明天起床后试试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dp_with_memorize</span>(<span class="params">dp_table, s, i, j, k</span>):</span><br><span class="line">    <span class="keyword">if</span> dp_table[s][i][j][k] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> dp_table[s][i][j][k]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">and</span> j == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp_table[s][i][j][k] = dp_with_memorize(dp_table, <span class="number">1</span>, i-<span class="number">1</span>, j, k) + \</span><br><span class="line">                     dp_with_memorize(dp_table, <span class="number">2</span>, i-<span class="number">1</span>, j, k)</span><br><span class="line">                <span class="keyword">return</span> dp_table[s][i][j][k]</span><br><span class="line">        <span class="keyword">elif</span> s == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">1</span> <span class="keyword">and</span> i == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp_table[s][i][j][k] = dp_with_memorize(dp_table, <span class="number">0</span>, i, j-<span class="number">1</span>, k) + \</span><br><span class="line">                     dp_with_memorize(dp_table, <span class="number">2</span>, i, j-<span class="number">1</span>, k)</span><br><span class="line">                <span class="keyword">return</span> dp_table[s][i][j][k]</span><br><span class="line">        <span class="keyword">elif</span> s == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span> <span class="keyword">and</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp_table[s][i][j][k] = dp_with_memorize(dp_table, <span class="number">0</span>, i, j, k-<span class="number">1</span>) + \</span><br><span class="line">                     dp_with_memorize(dp_table, <span class="number">1</span>, i, j, k-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> dp_table[s][i][j][k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tri_color_balls</span>(<span class="params">n_r, n_g, n_b</span>):</span><br><span class="line">    dp_table = [[[[-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_b + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_g + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_r + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([dp_with_memorize(dp_table, i, n_r, n_g, n_b) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br></pre></td></tr></table></figure>
<h2 id="幸运数字问题："><a class="header-anchor" href="#幸运数字问题：">¶</a>幸运数字问题：</h2>
<p>定义数字为$n = \{d_n, d_{n-1}, \ldots, d_1\}$。定义幸运数字为对于$i，d_{n-i+1} \neq d_i$。给定一个范围，求该范围内的幸运数字个数。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中无效的`scroll`事件handle</title>
    <url>/2018/10/24/failed-on-scroll-in-Vue/</url>
    <content><![CDATA[<p>最近在实现文章列表懒加载的时候，遇到了监听组件内的<code>scroll</code>事件失效的情况。这个时候就有点诡异。其实问题在于<code>scroll</code>事件到底发生在什么地方。</p>
<span id="more"></span>
<p>按照<code>scroll</code>事件的说法，该事件会被具备滑条的元素在滑动时触发。那么真的是我们绑定元素触发了<code>scroll</code>事件吗？</p>
<p>有的时候不是这样的。比如说在父组件在子组件的外边包了一层，比如说<code>div</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>此时如果滑动滑条的的话。不一定是<code>Child.vue</code>中的<code>div</code>的触发<code>scroll</code>，而是<code>Parent.vue</code>中的<code>div</code>触发滑条事件。由于外层的<code>div</code>会被<code>child</code>撑开而形成滑条。而触发<code>scroll</code>事件。此时，由于事件冒泡的机制，内部元素无法捕捉到事件。这种调试可以使用Chrome的performance调试工具查看<code>scroll</code>事件的root元素。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Web Development</tag>
        <tag>JavaScript</tag>
        <tag>Debug</tag>
        <tag>Event</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>更快的字符串复制方法</title>
    <url>/2019/10/13/faster-repeat-algorithm/</url>
    <content><![CDATA[<p>今天遇到了一个看似 trivial ，但是深挖进去却很有趣的问题——如何更快地复制一个字符串。</p>
<span id="more"></span>
<p>复制字符串问题，就是实现下面这个函数<code>repeatStr</code>。
这个函数接收<code>source</code>, <code>times</code>两个参数，返回重复<code>times</code>的<code>source</code>字符串，
如<code>repeatStr('abc', 2)</code>就应该返回<code>abcabc</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatStr</span>(<span class="params">source, times</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代实现"><a class="header-anchor" href="#迭代实现">¶</a>迭代实现</h2>
<p>这个问题初看起来非常简单，我看到这个问题的第一眼就想到了迭代解法。
问题要求我重复多少次，我就循环多少次嘛。Easy Question。实现如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatStrByIteration</span>(<span class="params">source, times</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">    res += source</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切完美。但是…它还可以优化吗？如果想让它跑得更快该怎么办？
（我：嗯？还有跑得更快的方法？）</p>
<h2 id="二分复制"><a class="header-anchor" href="#二分复制">¶</a>二分复制</h2>
<p>其实真的还有跑得更快的复制实现。但是我们需要转换一下解决问题的思路。</p>
<p>在复制中，费时间的操作是字符串之间的加法，因为<code>string</code>是不可变类型，
每一次改变它都需要创建一个新的<code>string</code>对象出来。
所以我们优化的方向是如何尽可能地减少两个字符串相加操作。</p>
<p>在迭代实现中，对于$times = n$，我们需要相加<code>n</code>次。
联想到二分查找，一个很自然的想法就是——我们可以将目标字符串*“对折”*起来相加，
比如，我们要重复 10 次<code>a</code>，可以通过<code>'aaaaa' + 'aaaaa'</code>得到最后的字符串，
这里需要 1 次加法，然后为了构造<code>aaaaa</code>，我们可以通过<code>aa+aaa</code>，需要 1 次加法，
<code>aa</code>可以分解为<code>a+a</code>，需要 1 次加法，最后构造<code>aaa</code>，可以分解为<code>a+aa</code>，需要 1 次加法。
可以看到，构造整个目标字符串<code>aaaaaaaaaa</code>所需要的加法次数，从 10 次下降到了 4 次。</p>
<p>可以通过二叉树的性质证明我们的算法的时间复杂度是$O(\log n)$的（二叉树的高度）。
实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatStrByBinaryJoin</span>(<span class="params">source, times</span>) &#123;</span><br><span class="line">  <span class="comment">// 两个边界情况</span></span><br><span class="line">  <span class="keyword">if</span> (times === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (times === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 通过Math.floor(times/2)来对折，如果是偶数，floor(times/2) === times/2</span></span><br><span class="line">    <span class="comment">// 这样我们直接用加号拼起来，如果是奇数，times = floor(times / 2) + [floor(times/2) + 1]</span></span><br><span class="line">    <span class="comment">// 需要多拼接一个source字符串</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">binaryRepeatStr</span>(source, <span class="title class_">Math</span>.<span class="title function_">floor</span>(times / <span class="number">2</span>))</span><br><span class="line">    res += res</span><br><span class="line">    <span class="keyword">if</span> (times % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      res += source</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能测试"><a class="header-anchor" href="#性能测试">¶</a>性能测试</h2>
<p>我们在 node 环境下进行测试。我们使用两个函数执行复制一千万次<code>abc</code>，测试函数脚本如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; performance &#125; = <span class="built_in">require</span>(<span class="string">&#x27;perf_hooks&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">measurePerf</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> startTime = performance.<span class="title function_">now</span>()</span><br><span class="line">  <span class="title function_">func</span>()</span><br><span class="line">  <span class="keyword">return</span> performance.<span class="title function_">now</span>() - startTime</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">repeatByIteration</span>(<span class="params">source, times</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">    res += source</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">repeatByBinaryJoin</span>(<span class="params">source, times</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (times === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (times === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">repeatByBinaryJoin</span>(source, <span class="title class_">Math</span>.<span class="title function_">floor</span>(times / <span class="number">2</span>))</span><br><span class="line">    res += res</span><br><span class="line">    <span class="keyword">if</span> (times % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      res += source</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strToRepeat = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">const</span> repeatTimes = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="string">`repeat by iteration: <span class="subst">$&#123;measurePerf(() =&gt;</span></span></span><br><span class="line"><span class="subst"><span class="string">    repeatByIteration(strToRepeat, repeatTimes)</span></span></span><br><span class="line"><span class="subst"><span class="string">  )&#125;</span>ms`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="string">`repeat by binary join: <span class="subst">$&#123;measurePerf(() =&gt;</span></span></span><br><span class="line"><span class="subst"><span class="string">    repeatByBinaryJoin(strToRepeat, repeatTimes)</span></span></span><br><span class="line"><span class="subst"><span class="string">  )&#125;</span>ms`</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repeat by iteration: 2006.9261000156403ms</span><br><span class="line">repeat by binary <span class="built_in">join</span>: 0.3501009941101074ms</span><br></pre></td></tr></table></figure>
<p>可以看到我们的二分复制版本相较于迭代版本从时间上来看性能有了巨大的提升。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>通过本文，我们使用二分技巧成功地将复制字符串这个工作的复杂度从$O(n)$降低到了$O(\log n)$。</p>
]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Haproxy进行SS代理中继</title>
    <url>/2017/02/01/haproxy-in-proxy-relay/</url>
    <content><![CDATA[<p>在使用国外的代理服务器时，常常会因为各种不稳定因素导致在直连时连接的丢包率特别高。对于一些对丢包率特别敏感的游戏（没错，说的就是舰队Collection），使用丢包率高的线路进行游戏是一件非常痛苦的事情。有的时候，游戏限定某个地区的IP才能够接入（没错，说的还是舰队Collection），所以必须使用架设在那个地区的代理服务器A。这两项加起来就有点麻烦了。但是，如果我们能够找到一个中继服务器B，从本地直连到中继服务器B的丢包率非常低，而从中继服务器B到目标服务器A的丢包率也非常低，这样我们就能够形成一条丢包率较低的线路。这样一条线路有效地提升了那些丢包率敏感的游戏体验。</p>
<pre><code>本地&lt;-&gt;中继服务器B&lt;-&gt;代理服务器A
</code></pre>
<p>在这里，我们在中继服务器B上使用<code>Haproxy</code>将请求转发到目标服务器A上。注意<code>Haproxy</code>只支持TCP连接的转发。</p>
<span id="more"></span>
<h2 id="基本步骤"><a class="header-anchor" href="#基本步骤">¶</a>基本步骤</h2>
<h3 id="安装haproxy"><a class="header-anchor" href="#安装haproxy">¶</a>安装Haproxy</h3>
<p>Debian/Ubuntu</p>
<pre><code>sudo apt-get -y install haproxy
</code></pre>
<h3 id="配置haproxy"><a class="header-anchor" href="#配置haproxy">¶</a>配置Haproxy</h3>
<p>使用文本编辑软件打开<code>/etc/haproxy/haproxy.conf</code>，注意提供管理员权限，用以下内容替换原来的内容：</p>
<pre><code>global
    ulimit-n  51200

defaults
	log	global
	mode	tcp
	option	dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000

frontend ss-in
    bind *:relay_server_port
    default_backend ss-out

backend ss-out
    server server1 proxy_server_ip:proxy_server_port maxconn 20480
</code></pre>
<p>指定一个端口为<code>relay_server_port</code>，如<code>8100</code>等，这个端口将会之后用于<strong>本地与中继服务器B</strong>的连接。将<code>proxy_server_ip</code>替换为被中继的<strong>代理服务器A</strong>的IP地址，<code>proxy_server_port</code>设置为被中继的<strong>代理服务器B</strong>的监听端口。</p>
<h3 id="启动haproxy"><a class="header-anchor" href="#启动haproxy">¶</a>启动Haproxy</h3>
<p>运行
sudo /etc/init.d/haproxy start</p>
<h3 id="设置本地客户端"><a class="header-anchor" href="#设置本地客户端">¶</a>设置本地客户端</h3>
<p>命令行
sslocal -s relay_server_ip -p relay_server_port -l local_port -k password -m encryption_method</p>
<p>其中<code>relay_server_ip</code>是中继服务器B的IP，<code>relay_server_port</code>是上文提到的中继服务器转发的端口，<code>password</code>与<code>encryption_method</code>分别为访问代理服务器的密码与加密方法，与之前的设置相同。</p>
<h2 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h2>
<p><code>Haproxy</code>是一款HTTP/TCP负载均衡器，核心功能就是将前端的大流量请求，分流到后端的各个服务器中。原理与我们要实现的代理中继非常类似。<code>Haproxy</code>监听特定端口的请求，然后将这个请求转发到后台的某一台服务器的端口上。这里<code>Haproxy</code>监听的端口就是设置的中继服务器的端口，“后台服务器”就是我们原来的SS代理服务器。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://doub.io/ss-jc29/" title="Shadowsocks利用 HaProxy 实现中继(中转/端口转发)">Shadowsocks利用 HaProxy 实现中继(中转/端口转发)</a></li>
<li><a href="http://kaywu.xyz/2016/06/19/Shadowsocks-HAProxy/" title="使用 HAProxy 加速 Shadowsocks">使用 HAProxy 加速 Shadowsocks</a></li>
</ol>
<h2 id="修改日志"><a class="header-anchor" href="#修改日志">¶</a>修改日志</h2>
<p>2017/11/9 修正启动Haproxy的命令</p>
]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Haproxy</tag>
        <tag>Proxy Relay</tag>
      </tags>
  </entry>
  <entry>
    <title>人人都能懂的经济学：征收房产税的时候租金会如何变化</title>
    <url>/2021/03/06/how-the-price-change-when-xxx/</url>
    <content><![CDATA[<p>李华结束了一天的工作，过于劳累不想坐几个小时的地铁回家。李华打开了滴滴，
输入家的位置开始打车。</p>
<p>——「预估 40.5 元」</p>
<p>「哎」，李华轻叹了一声，放下手机，拖着疲惫的身体，缓缓向附近的地铁站走去。</p>
<p>经济关乎着我们每一个的生活。前几天，我在 v2ex
上看到<a href="https://www.v2ex.com/t/758303">一些关于房产税的讨论</a>，
「如果国家决定征收房产税，对于房屋租金会如何改变？」，
不论立场而言，是一个很有趣的经济学问题。
答案也很简单，</p>
<blockquote>
<p>tl;dr; 租金会稍微上涨，但是房产税的负担不会完全落到租客头上。</p>
</blockquote>
<span id="more"></span>
<h2 id="价格的决定因素"><a class="header-anchor" href="#价格的决定因素">¶</a>价格的决定因素</h2>
<p>在研究租金问题之前，我们首先需要了解「价格是如何形成的？」 。</p>
<p>为了解释这个问题，我们假设有这样一个小区，其中有五个房东 A, B, C, D, E。
每一个房东都有一间房屋等待出租。每一个房东对于待出租的房屋有一个<strong>心理价位</strong>，
只要租客出价<strong>不小于</strong>这个心理价位，房东就愿意将待出租的房屋租给租客。</p>
<p>假设，每个房东的心理价位如下：</p>
<table>
<thead>
<tr>
<th>房东</th>
<th>心理价位</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1000</td>
</tr>
<tr>
<td>B</td>
<td>1100</td>
</tr>
<tr>
<td>C</td>
<td>1300</td>
</tr>
<tr>
<td>D</td>
<td>1400</td>
</tr>
<tr>
<td>E</td>
<td>1500</td>
</tr>
</tbody>
</table>
<p>为了把 5 个房东的心理价位聚合起来，我们以 $y$ 轴为<strong>房租价格</strong>，
$x$ 轴为<strong>可出租房屋数量</strong>，绘制一张曲线图。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./supply.png" alt="供给曲线"></p>
<p>从曲线中，我们可以看到，如果我们愿意付出 1200 元租一间房屋，
此时小区中可以有 2 间房屋可以选择。这条曲线，刻画了市场上单一商品
（这个例子中是出租屋）上的供给情况，因此这条曲线，
也被称为<a href="https://en.wikipedia.org/wiki/Supply_(economics)"><em>供给曲线（Supply Curve）</em></a>。</p>
<p>由于人性，供给曲线的斜率一定是大于等于 0 （为什么？）。</p>
<p>在同时，有五位打工人 I、J、K、L、M 准备在这个小区租房，
他们每一个人也有一个<strong>心理价位</strong>。当房屋租金<strong>不高于</strong>这个心理价位，
他们就会花钱租下这个房屋。</p>
<table>
<thead>
<tr>
<th>租客</th>
<th>心理价位</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1400</td>
</tr>
<tr>
<td>J</td>
<td>1300</td>
</tr>
<tr>
<td>K</td>
<td>1200</td>
</tr>
<tr>
<td>L</td>
<td>1000</td>
</tr>
<tr>
<td>M</td>
<td>900</td>
</tr>
</tbody>
</table>
<p>借鉴供给曲线，我们可以通过曲线的方式，把所有打工人的心理价位聚合起来。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./demand.png" alt="需求曲线"></p>
<p>曲线中每一点$(x, y)$，表示当房租为 $y$ 时，会有 $x$ 间房屋出租出去。
这条曲线被称为<a href="https://en.wikipedia.org/wiki/Demand_curve"><em>需求曲线(Demand Curve)</em></a>。</p>
<p>同样由于人性，需求曲线的斜率一定会小于等于 0 （为什么？）。</p>
<p>如果我们将两条曲线放到同一张图上，我们会发现两条曲线相交于一段线段。
如果当租金落在这个线段上，市场中待出租房屋与出租房屋数相等，达到了平衡。
此时，价格被称为<a href="https://en.wikipedia.org/wiki/Economic_equilibrium"><em>均衡价格(Equilibrium Price)</em></a>。
很显然，此时<strong>市场中商品实际成交</strong>的价格就是均衡价格。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./equilibrium.png" alt="市场平衡"></p>
<p>用上面的例子，假设租金为 1250 元。此时房东侧，房东 A、B 愿意出租房屋，
C、D、E 由于低于心理价位，没有出租房屋。租客侧，租客 I，J 愿意租赁房屋，
租客 K，L，M 由于高于心理价位，没有在小区中租赁房屋。此时市场上，
A、B 与 I、J 会达成交易，实际出租房屋数为 2。</p>
<p>在实际中，参与市场的个体数量众多，一般而言供应曲线和需求曲线都是平滑的。
不失一般性的，我们用平滑的曲线来代替供应曲线与需求曲线。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./smoothed-sd-curve.png" alt="平滑的供需曲线"></p>
<p>上面这个小区的例子，就是所谓的「<strong>供需决定价格</strong>」。确切的来说，
是供给曲线与需求曲线共同决定价格——两条曲线的交点。</p>
<h2 id="价格弹性"><a class="header-anchor" href="#价格弹性">¶</a>价格弹性</h2>
<p>对于不同的商品，人们对价格变动的敏感度是不一样的。如大米、面粉等生活必需品，
人们对于价格变动是不敏感的。然而，对于另外一些商品，如奢侈品，
价格的变动常常会影响人们的购买决策。在经济学中，
我们可以通过*价格弹性（Price Elasticity）*来描述市场这一行为。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./price-elasticity.png" alt="需求的价格弹性"></p>
<p>上图是一条需求曲线（为什么？），假设价格从 A 点变化到 B 点，
我们可以计算出来需求量变化的<strong>百分比</strong>与价格变化的<strong>百分比</strong>的比值，
这被称为需求的价格弹性。</p>
<p>$$
E_d =\frac{\Delta Q / Q_A}{\Delta P / P_A}
$$</p>
<blockquote>
<p>实际上，价格弹性的精确定义需要借助微分，此处为了简单不展开。</p>
</blockquote>
<p>类似定义，也可以定义出供给的价格弹性。由于需求的价格弹性恒大于等于 0，
供给的价格弹性小于等于 0（为什么？）。因此在讨论价格弹性的时候，
常常把符号舍去。例如，说某个商品的供给的价格弹性为 1，其实在数学上，
它的价格弹性应该为 -1.</p>
<p>弹性也可以是一个相对的概念，假如我们说某个商品，供给比需求更有弹性，
指的是供给的价格弹性（注意舍去符号）要大于需求的价格弹性。</p>
<p>建立了供给、需求、均衡价格与价格弹性的概念之后。
我们已经准备好了研究税赋的理论工具了。</p>
<h2 id="税赋"><a class="header-anchor" href="#税赋">¶</a>税赋</h2>
<blockquote>
<p>Our new Constitution is now established, and has an appearance that
promises permanency; but in this world nothing can be said to be certain,
except death and taxes.</p>
<p>– Benjamin Franklin</p>
</blockquote>
<p>税，相信大家都很熟悉。购买商品时，发票上有时会打印着增值税；
发工资的时候，员工会被征收所得税；交易股票的时候，
卖出者会被征收印花税等等。
如果，政府对某件商品征收消费税，我们的一般直觉是
「啊，这笔税收一定最终是消费者承担吧」。然而，事实真的是这样吗？</p>
<blockquote>
<p>tl;dr; 政府无法将税收精确地分摊到买卖双方。</p>
</blockquote>
<h3 id="以手抓饼为例"><a class="header-anchor" href="#以手抓饼为例">¶</a>以手抓饼为例</h3>
<p>假设，政府有一天决定对「手抓饼」进行征税，政府有两种选择，
第一种是在需求侧征税，例如手抓饼的价格是 5 元/个，消费税每个 1 元。
此时消费者需要付出 6 元，5 元付给卖家，1 元作为税；另外一种是在供应端征税，
例如卖家供应手抓饼的价格为 5 元，税率每售出 1 个 1 元。
此时卖出一个手抓饼收到 5 元，其中需要向政府缴纳 1 块钱作为税收，
卖家只能留存 4 元。</p>
<p>在上面<a href="#%E4%BB%B7%E6%A0%BC%E7%9A%84%E5%86%B3%E5%AE%9A%E5%9B%A0%E7%B4%A0">价格的决定因素</a>中提到，市场价格由供需决定。
要研究在增加税收时，市场的价格如何变化，我们需要研究<strong>供需的变化</strong>。
假设在征税之前，「手抓饼」市场的供求曲线如下，均衡价格为 5 元。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./example-ds-curve.png" alt="手抓饼供求曲线"></p>
<h3 id="在需求侧征税"><a class="header-anchor" href="#在需求侧征税">¶</a>在需求侧征税</h3>
<p>假设政府在需求侧征税，每一个手抓饼向消费者征收 1 元税收。此时，
我们来分析<strong>供需的变化</strong>。</p>
<p>首先对于供给侧而言，
对需求侧征税对供给侧完全无影响，因此，<strong>供给曲线</strong>是不变的。
作为消费者而言，只会关心最后的到手价格，也就是<strong>含税价格</strong>，
消费者不会含税价格里面有多少是税收，
多少归属于商家。因此，以含税价格计，商品的需求曲线是不变的。
但是，对于供给侧只能收到<strong>非含税价格</strong>，
如果以非含税价格计，扣除税收后，商品的需求曲线会<strong>向下平移</strong>税收个单位，
在手抓饼的例子中，也就是向下平移 1 个单位，到 $D^{\prime}$ 处。
可以看到，以非含税价格计，市场建立到一个新的平衡态 $E^{\prime}$。
此时，消费者需要付出 $P_d$ 元，卖家收到 $P_s$ 元，$P_d - P_s$
正好为 1 元，交给政府作为税收。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./price-change-tax-on-demand.png" alt="需求侧征税的影响"></p>
<p>从上面的结果中可以发现，在征税后，手抓饼的价格上涨到 $P_d$ 元，
但是 $P_d$ 会小于 6 元（$P_s &lt; E = 5, P_d = P_s + 1 &lt; 6$），
也就是这 1 元税收不会完全转嫁到消费者身上。那么，这 1 块钱税收是如何分配的呢？
观察图中，因为税收的影响，手抓饼的价格上涨到 $P_d$ 元，为了获得一个手抓饼，
消费者要多付出 $P_d - E$ 的钱，也就是图中蓝色阴影部分，
很显然，这一部分钱是税收的一部分。然而，
由于市场新平衡，卖家只能够收到 $P_s$ 的钱，比未征税时的 $E$，
少挣了 $E - P_s$，也就是图中绿色阴影部分，
相当于卖家将这部分少挣的钱作为了税收的一部分上缴给了国家。
蓝色阴影的面积与绿色阴影的面积比就是这 1 块钱税收在两者之间的分摊。</p>
<h3 id="在供给侧征税"><a class="header-anchor" href="#在供给侧征税">¶</a>在供给侧征税</h3>
<p>假设政府在供给侧征税，也就是当卖家每卖出一个手抓饼的时候，
向卖家征收 1 元税收。仿照上面的分析来看市场价格如何变动。</p>
<p>首先对于需求侧来说，不会感知到对供给侧的税收，因此，对需求曲线无任何影响。
对于供给侧来说，也只会关心自己的到手价格，即<strong>不含税价格</strong>。
以不含税价格计，供给曲线不变。但是对于消费者而言，是以<strong>含税价格</strong>成交的。
以含税价格计，加上税收，供给曲线<strong>向上平移</strong>税收个单位，在手抓饼的例子中是
1 个单位，到 $S^{\prime}$ 处。可以看到，市场建立了新的平衡态$E^{\prime}$，
此时，消费者需要付出 $P_d$ 元，卖家收到 $P_s$ 元，$P_d - P_s$
正好为 1 元，交给政府作为税收。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./price-change-tax-on-supply.png" alt="供给侧征税的影响"></p>
<p>分析征税后的变化，手抓饼的价格上涨到 $P_d$，但是同样 $P_d &lt; 6$ 元。
也就是税收不会完全转嫁到消费者身上。看税收的分配，
消费者相较征税前多付出了 $P_d - E$，也就是图中蓝色阴影部分，
这一部分作为了隐性税收上交给了政府。卖家在征税后只能收到 $P_s$ 的钱，
比未征税时的 $E$，少挣了 $E - P_s$，也就是图中绿色阴影部分，
相当于这一部分作为了税收上交给了国家。
蓝色阴影的面积与绿色阴影的面积比就是这 1 块钱税收在两者之间的分摊。</p>
<p>从上面的例子中可以看到，无论政府对那一方征税，另外一方都会一同承担税收。
可以得出结论：「如果政府对一项商品征税，对于需求侧而言，商品价格<strong>会上涨</strong>，
对于供给侧而言，收入<strong>会下跌</strong>」。</p>
<h2 id="什么决定了税负归宿"><a class="header-anchor" href="#什么决定了税负归宿">¶</a>什么决定了税负归宿</h2>
<p>接下来，我们来考虑最后一个问题，什么因素决定了赋税的分担比例，
即税负归宿（Tax Incidence）呢？
从供求曲线和需求曲线来看，似乎曲线越「平」，形成的阴影面积会越小。
从<a href="#%E4%BB%B7%E6%A0%BC%E5%BC%B9%E6%80%A7">价格弹性</a>一节中，我们可以知道，曲线的「平度」
可以用价格弹性度量。
也就是分担的税收越少。如下图所示，展示了在供给侧征税时，
税赋分担比例随需求曲线的价格弹性的变化。</p>
<p><img src="/2021/03/06/how-the-price-change-when-xxx/./tax-incidence-relate-to-elasticity.png" alt="税负归宿与价格弹性的关系"></p>
<p>A 图中，需求曲线平缓，需求非常富有弹性。此时，可以看到蓝色部分消费者负担的税收，
是要少于绿色部分卖家负担的税收的。B 图中，两者的弹性相比不大，
消费者与卖家负担的比例差不多。C 图中，需求曲线较陡，需求非弹性，
蓝色部分消费者负担的税收要多于卖家负担的税收。总结起来，
税赋会由弹性<strong>更加弱</strong>的一方承受更多，无论政府选择向哪一方征税
（向需求侧征税的场合，读者可以仿照本节方法自行证明）。</p>
<h2 id="房产税对租金的影响"><a class="header-anchor" href="#房产税对租金的影响">¶</a>房产税对租金的影响</h2>
<p><strong>本节不构成任何投资建议。</strong></p>
<p>在了解了税赋归宿之后，我们可以来脑内演习一下，当政府征收房产税之后，
会如何影响租房市场。</p>
<p>首先，由于征税的本质，市场租金（短期内）会上涨。房产税是<strong>财产税</strong>，
也就是对房东持有房地产的这一行为征税。显然，
房东有将房产税转嫁给租客的动机，是完全合理的。
从<a href="#%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E4%BA%86%E7%A8%8E%E8%B4%9F%E5%BD%92%E5%AE%BF">什么决定了税负归宿</a>这一节中，
我们知道税负的分担比例是由双方的价格弹性决定的。那么，
有什么因素影响双方的价格弹性呢？</p>
<h3 id="租客侧的价格弹性"><a class="header-anchor" href="#租客侧的价格弹性">¶</a>租客侧的价格弹性</h3>
<p>在需求（租客）侧，有以下因素影响价格弹性：</p>
<ol>
<li>
<p>必要性：如果一件商品对于需求侧更加必要，那么需求更加趋于非弹性。
对于租客而言，如果无法在生活的城市购置房屋的时候，租房是唯一的选择，
有较高的必要性。</p>
</li>
<li>
<p>替代商品：如果一件商品有替代商品的话，需求趋于弹性。</p>
</li>
<li>
<p>对市场的定义：需求曲线的弹性也取决于我们对市场的定义。市场范围越小，
需求曲线更加趋于弹性。以租房市场为例，
北京的租房的需求会比全国的租房市场的需求更加弹性，
海淀区的租房需求会比北京的租房需求更加弹性。原因是，市场范围越小，
越容易找到替代商品，比如以海淀区的租房市场，
昌平区、朝阳区、丰台区的出租屋都构成海淀区的出租屋替代商品。</p>
</li>
<li>
<p>时间跨度：考虑的时间跨度更长，需求趋于弹性。</p>
</li>
</ol>
<p>虽然，租房对于租客而言有一定的必要性。但是就替代商品而言，
租客可以较为方便的流动，有丰富的替代商品可以选择。另外，
租客也可以选择以买房或者移往别的城市的方式退出该地的租房市场。
因此，考虑各种因素，需求侧具有一定的价格弹性。</p>
<h3 id="房东侧的价格弹性"><a class="header-anchor" href="#房东侧的价格弹性">¶</a>房东侧的价格弹性</h3>
<p>在供应（房东）侧，有以下因素影响价格弹性：</p>
<ol>
<li>
<p>生产的灵活性：如果供应者可以很灵活地调整供应量，那么供应趋于弹性；</p>
</li>
<li>
<p>时间跨度：与需求相同，考虑的时间跨度更长，供应趋于弹性；</p>
</li>
</ol>
<p><strong>假设</strong>，房东会出租所有非自住房屋<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。
房东调整供应量的方式只有买卖房屋的方式。对于房地产价值高企，
未来变化不明的现在，买卖房屋会是一种风险很高的决策。如果，
房东无法灵活地调整供应量，那么供应侧的价格弹性会比较低。</p>
<p>综合上面的两种考虑，如果征收房产税，房东想要将税转嫁到租客侧，
由于双方价格弹性，房东无法将所有的房产税转嫁到租客侧，
甚至有较大可能，供给侧价格弹性较低，房东必须自行负担房产税的大部分。</p>
<h2 id="结论"><a class="header-anchor" href="#结论">¶</a>结论</h2>
<p>在文章中，我们主要讨论了「征税对价格的影响」。
了解了「价格由供需共同决定」、「价格弹性」以及「税收归宿」三个概念。
当政府对一件商品征税的时候，供需双方的税负分担比例由各自的价格弹性决定。</p>
<p>以租房市场为例，如果政府推出房产税，在<strong>短期内</strong>，房租会上涨，
但是不会完全负担房产税。根据价格弹性的分析，有较大的可能，
房东自行负担房产税中的大部分。</p>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<p>[1]: Mankiw N G. Principles of Economics[M]. Nelson Education, 2014.</p>
<h2 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h2>
<p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：考虑到房屋空置时除了资产价值的变化，不会产生任何其他的收入。
基于理性，假设房东会出租所有非自住房屋。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title>如何拯救坏掉的Git Repository——记一次git“事故”</title>
    <url>/2019/01/09/how-to-recover-messed-up-git-repo/</url>
    <content><![CDATA[<p>1 月的北京风和日丽。我做好了一个需求，估摸着该提 PR 合并到主仓库了。
于是，我准备和主仓库<code>master</code>分支<code>rebase</code>一下，然后整理一下 commit 记录。临近下班了，
又要面对一天中最困难的问题——晚上吃什么？楼下那家 KFC 的菜单已经吃完一轮了。
突然之间，我隐隐感觉有一点不太对劲。一看<code>git log</code>。Oh shit!!</p>
<span id="more"></span>
<h2 id="我-tm-rebase-反了"><a class="header-anchor" href="#我-tm-rebase-反了">¶</a>我 TM rebase 反了</h2>
<p>我惊出了一身冷汗，瞬间没心思考虑晚饭问题了。看了一眼本地<code>master</code>分支，
最后一条 commit 记录的 SHA 和远程<code>master</code>最后一条 commit 的 SHA 不一样。诶？
远程仓库的 merge commit 全不见了。然后一看我刚刚敲的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull upstream master</span><br><span class="line">git rebase feature</span><br><span class="line"></span><br><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<p>Oh, shit!我在干什么？我以前听说过搞乱 Git 仓库是很麻烦的问题。此时无数想法从脑中闪过：
难道 feature 要重写吗？好几百行啊，而且 feature 已经快到 deadline 了。我慌了，真的慌了。
还是先喝口水冷静下来吧。</p>
<p>冷静下来之后，我想我为了面试看过一点点 Git 的基本原理。从原理入手，
一点点小心地修正记录的话应该是可以修好的。此时最重要的是理解现在仓库的历史。Don’t Panic。</p>
<h2 id="分析-commit-历史"><a class="header-anchor" href="#分析-commit-历史">¶</a>分析 commit 历史</h2>
<p>在这个项目中，生产代码单独是一个 repo。开发的时候，开发者<code>fork</code>生产代码的 repo，
然后<code>clone</code>自己<code>fork</code>的 repo。在本地，按照惯例，我自己<code>fork</code>的 repo 是<code>origin</code>，
远程生产代码的 repo 是<code>upstream</code>。开发新功能的时候，我从本地的<code>master</code>分支
<code>checkout</code>一个特性分支<code>feature</code>。在开发了几天之后，远程生产代码已经合并了数个 PR。
在我的愚蠢操作之前，整个项目的分支情况是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  C5---C6---C7---C8 feature</span><br><span class="line">  /</span><br><span class="line">C1--C2--M2--C3--M3 upstream/master</span><br><span class="line">|</span><br><span class="line">origin/master</span><br><span class="line">master</span><br></pre></td></tr></table></figure>
<p>其中<code>Mx</code>是 merge commit。在愚蠢的操作之后，由于<code>rebase</code>默认丢弃掉将要<code>rebase</code>分支的
merge commit，项目的分支情况变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                        C5&#x27;--C6&#x27;--C7&#x27;--C8&#x27; feature</span><br><span class="line">                      /</span><br><span class="line">                C2&#x27;--C3&#x27; master</span><br><span class="line">                /</span><br><span class="line">origin/master C1--C2--M2--C3--M3 upstream/master</span><br></pre></td></tr></table></figure>
<p>知道病因之后，似乎还有救的样子。首先，我们可以在<code>feature</code>分支中以<code>C1</code>为起点、
剔除掉<code>C2'</code>、<code>C3'</code>。这样，<code>feature</code>就恢复了之前的状态。然后，
我们将<code>master</code>分支回退到<code>origin/master</code>。这样，<code>master</code>分支也恢复了。
最后做一遍正常的<code>rebase</code>操作应该就行了。未来实现这个方案，
我们可以使用两把非常好用的“手术刀”——<code>reset</code>、还有<code>rebase</code>本身，在这个情况下可以使用。</p>
<h2 id="手术过程"><a class="header-anchor" href="#手术过程">¶</a>手术过程</h2>
<p>首先我们做第一步，以某个 commit 为起点，剔除掉一些 commit，
我们可以使用<code>git rebase -i start_commit_sha</code>命令。<code>-i</code>参数表示<code>interactive</code>。
执行之后，git 会调用一个文本编辑器打开一个文件，
里面的内容是从起点之后的第一个 commit 到最后一个 commit 的所有 commit。commit 可以被更改、
压缩(squash/fix up)、删除。要删除某个 commit，只需要在编辑器中把该行删掉即可。
保存退出之后，git 会根据这个文件的内容进行<code>rebase</code>操作。</p>
<p>删掉<code>C2'</code>、<code>C3'</code>之后，项目结构变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                C2&#x27;--C3&#x27; master</span><br><span class="line">                /</span><br><span class="line">origin/master C1--C2--M2--C3--M3 upstream/master</span><br><span class="line">                \</span><br><span class="line">                C5--C6--C7--C8 feature</span><br></pre></td></tr></table></figure>
<p>然后，<strong>在<code>master</code>分支</strong>中使用<code>git reset --hard commit_sha</code>。
这个命令的语义是将<em>HEAD</em>（分支的指针）、工作目录、暂存区重置到<code>commit_sha</code>指向的 commit。
这里<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86">官方文档</a>解释得很清楚。</p>
<p>此时项目结构变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              master</span><br><span class="line">              |</span><br><span class="line">origin/master C1--C2--M2--C3--M3 upstream/master</span><br><span class="line">                \</span><br><span class="line">                C5--C6--C7--C8 feature</span><br></pre></td></tr></table></figure>
<p>和没经过愚蠢操作的项目结构是一样的。此时只要来一遍正常操作就行了。</p>
<h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2>
<p>解决 git 仓库被意外破坏的问题，最重要的是<strong>要冷静</strong>。只有冷静下来，
才能够准确地分析出现在 git 仓库的状况。然后看情况使用对应的工具操作。
git 其实内置了很强大的对 commit 历史进行操作的工具，所以大多数的 git 操作失误是不用重写的。</p>
<p>当然，最重要的是<strong>操作 git 仓库的时候要专心</strong>。敲命令真的很容易错的 orz。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>一文弄懂HTTPS（I）：密码学基础</title>
    <url>/2018/11/15/https-cryto-basic/</url>
    <content><![CDATA[<p>大家一定在浏览器地址栏的前面见到过一把小锁。
<img src="/2018/11/15/https-cryto-basic/safe-icon.png" alt="safe icon"></p>
<p>这把小锁代表着我们与服务器之间的通信是安全的。而安全背后的保障就是HTTPS(HyperText Transfer Protocol Secure)。本系列文章将会从密码学背景开始，尝试去弄懂HTTPS背后的原理。（其实发现一篇文章的写太长了，才分P的，www）</p>
<span id="more"></span>
<h2 id="为什么https保证了数据安全？"><a class="header-anchor" href="#为什么https保证了数据安全？">¶</a>为什么HTTPS保证了数据安全？</h2>
<p>提到HTTPS之前，不得不说HTTP。大家都知道HTTP是明文传输的协议，在传输过程中，其中任何节点都可能窃听或者篡改原文而不被察觉。当不用HTTPS之前，有很多人的网站被运营商插进广告也是因为这个原因。</p>
<p>那么为什么HTTPS能够防止中间人窃听和篡改？一个肯定不会错的答案是，HTTPS在数据传输过程中对数据进行加密。加密后的数据（称为密文）只能由通信双方解密。</p>
<p>那么接下来问题可能接踵而至？如，为什么只能由双方解密？为什么中间人就解密不了呢?</p>
<p>当然，答案隐藏在加密算法本身——对称加密以及非对称加密。</p>
<h2 id="加密算法"><a class="header-anchor" href="#加密算法">¶</a>加密算法</h2>
<p>（以下部分内容可能比较数学化一点）。。
所谓加密算法，目的就是使得密文像垃圾数据一样。当数据到达之后，通信另外一方能够通过某种方式把这堆垃圾数据还原成原文。首先，我们先介绍对称加密。（这是一个很有历史的算法哦）</p>
<h3 id="对称加密"><a class="header-anchor" href="#对称加密">¶</a>对称加密</h3>
<blockquote class="blockquote-center">
<p>如果需要保密，信中便用暗号，也即是改变字母顺序，使局外人无法组成一个单词。如果想要读懂和理解它们的意思，得用第4个字母置换第一个字母，即以D代A，余此类推。
 苏维托尼乌斯, 罗马十二帝王传</p>

</blockquote>
<p>远在两千多年以前，凯撒就已经使用了加密算法加密重要文件。这种加密方法叫凯撒密码，用数学公式定义如下</p>
<p>$$
E_n(x) = (x + n) \mod 26 \\
D_n(x) = (x - n) \mod 26
$$</p>
<p>其中$E_n$为加密方法，$D_n$为解密方法。</p>
<p>可以看见，要是安全通信成立，通信双方就$n$建立公式。双方同时使用$n$进行加密以及解密。符合双方用同一密钥加解密的算法称为对称加密。</p>
<p>当然现代对称加密方法肯定不会像凯撒密码那么简单，有兴趣可以参见<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86">对称加密算法</a>或者密码学专业书籍。</p>
<p>对称加密具有运算快的特点，但是有一个严重的问题使得对称加密几乎无法单独使用：“双方如何通过不安全信道共享同一个密钥”。</p>
<h3 id="非对称加密"><a class="header-anchor" href="#非对称加密">¶</a>非对称加密</h3>
<p>天才总是那么牛逼。他们从数论中找到了一种方法，使得一方可以在不泄露密钥的情况下，让通信对方用一把公开的密钥实现<strong>单向的</strong>安全通信。这种方法的出现可以很好的解决上一个问题。</p>
<p>非对称加密的步骤是</p>
<ol start="0">
<li>Bob持有一把公钥一把私钥。其中公钥是公开的，任何人都可以使用，私钥是保密的，绝对不能泄露；</li>
<li>Alice想联系Bob，便使用Bob的公钥加密信息，然后通过不安全信道传递给Bob；</li>
<li>Bob收到密文后，使用自己的私钥解密信息。</li>
</ol>
<p>当然，光看上面的描述会感觉，这是什么和什么啊？为什么怎么做有效呢？我们用一个著名的非对称加密算法RSA作为例子。</p>
<h4 id="rsa算法"><a class="header-anchor" href="#rsa算法">¶</a>RSA算法</h4>
<p>RSA算法的名字以MIT的美国科学家Ron Rivest、Adi Shamir与Leonard Adleman的姓氏首字母构成。英国数学家Clifford Cocks也独立发现了这一算法。</p>
<p>首先，通信一方如Bob可以生成一个公钥$(n, e)$，其中$n = pq$，$p$，$q$分别是一个非常大的质数。$e$与$(p-1)(q-1)$互质。然后据此可以产生一把私钥$d$，是$e$关于$(p-1)(q-1)$的模反元素。模反元素就是说$de \equiv 1 \mod (p-1)(q-1)$。现在所有加解密要素都齐全了，Bob可以随意将公钥$(n, e)$散播出去。</p>
<h5 id="加密过程"><a class="header-anchor" href="#加密过程">¶</a>加密过程</h5>
<p>如果Alice要发送一份秘密的文件给Bob，首先Alice可以取得Bob散播的公钥$(n, e)$（公开的，怎么传都没关系）。然后设原文为$m, m &lt; n$，如果原文$m &gt; n$应该采取划分的方法产生若干满足小于条件的整数，为了简单起见，这里还是令$m$为处理后的原文。</p>
<p>加密过程很简单。。。Alice只需要进行下面的变换：
$$
c \equiv m^e \mod n
$$</p>
<p>然后把$c$传给Bob即可。</p>
<h5 id="解密过程"><a class="header-anchor" href="#解密过程">¶</a>解密过程</h5>
<p>Bob接到密文之后，进行下面的变换就可以解密：
$$
m \equiv c^d \mod n
$$</p>
<p>那么为什么呢？下面都是数学原理，如果不感兴趣的话可以跳过:</p>
<p>首先我们知道$c \equiv m^e \mod n$，则
$$
c^d \equiv m^{de} = m^{1 + k(p-1)(q-1)} \mod n
$$</p>
<p>其中$k$为任意整数，等号的变换是因为$de \equiv 1 \mod (p-1)(q-1)$。
据费马小定理：</p>
<blockquote>
<p>费马小定理：
如果$a$不是$p$的倍数，则$a^{p-1} \equiv 1 \mod p$。</p>
</blockquote>
<p>$$
c \equiv m \cdot (m^{p-1})^{k(q-1)} = m \cdot 1 \mod p \\
c \equiv m \cdot (m^{q-1})^{k(p-1)} = m \cdot 1 \mod q
$$</p>
<p>又因为$gcd(p, q) = 1$，由中国剩余定理有：</p>
<p>$$
c^d \equiv m \mod pq
$$</p>
<p>因此，可以使用上面提到的解密算法解密。</p>
<h5 id="安全保证"><a class="header-anchor" href="#安全保证">¶</a>安全保证</h5>
<p>为什么说RSA能够保证传输安全呢？注意到解密需要私钥$d$。求$d$最简单的方法是已知$p, q$用定义式去求。已知公钥$n, e$，其中$n = pq$。那么要求$p, q$，攻击者需要对$n$做分解。这个在多项式时间不能解决。</p>
<p>当然，随着计算力的发展，较低数位的RSA已经被证实可以破解。因此，实用的RSA的话$n$至少要在2048位。</p>
<h5 id="数字签名"><a class="header-anchor" href="#数字签名">¶</a>数字签名</h5>
<p>非对称加密除了用来加密信息，反向利用也可以用来验证一个信息是否由指定实体发送。比如Bob用自己的私钥加密一段信息，然后将这段信息和密文发送给Alice，Alice如果可以使用Bob的公钥把密文还原成信息原文比对，就可以确定这段信息由Bob发送。这个会在下一篇文章介绍。</p>
<h5 id="非对称加密的劣势"><a class="header-anchor" href="#非对称加密的劣势">¶</a>非对称加密的劣势</h5>
<p>非对称加密对于对称加密的劣势在于加解密的速度较慢。因此，在实际使用的时候，我们总是配合非对称加密与对称加密使用。非对称加密可以用来交换对称加密使用的密钥。</p>
<h2 id="密钥交换"><a class="header-anchor" href="#密钥交换">¶</a>密钥交换</h2>
<p>现在我们来看一看如何安全地共享同一把密钥，典型的协议是Diffie-Hellman密钥交换协议。过程如下。</p>
<ol>
<li>Alice与Bob同意使用一个质数$p$以及一个$p$的原根$a$；</li>
<li>Alice选择一个随机数$k_1$，然后把$a^{k_1} \mod p$发送给Bob；</li>
<li>Bob选择一个随机数$k_2$，然后把$a^{k_2} \mod p$发送给Alice；</li>
<li>Alice计算$(a^{k_2})^{k_1} \mod p$；</li>
<li>Bob计算$(a^{k_1})^{k_2} \mod p$;</li>
</ol>
<p>因为$(a^{k_1})^{k_2} \mod p = (a^{k_2})^{k_1} \mod p$，可以作为对称加密密钥。</p>
<h3 id="中间人攻击"><a class="header-anchor" href="#中间人攻击">¶</a>中间人攻击</h3>
<p>但是上述交换协议有一个非常大的弱点。假设有一个中间人Eve在窃听Alice与Bob之间的通信，他可以与双方分别进行一次D-H密钥交换，从而获取整条信道的信息。Alice与Bob不会察觉到中间人的存在。</p>
<p>上述问题的核心在于确定一个实体的公钥是否是可信的公钥。因此，HTTPS建立了所谓了公开密钥认证体系。这一个我们下一篇文章再谈（太长了。。。）</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>这一篇文章严格上没有介绍HTTPS，但是了解了这些基础知识。下面真正见到HTTPS时就会有种的熟悉感。接下来一篇文章大概会介绍HTTPS的客户端与服务器的通信流程。我们下期再见。。。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
        <tag>HTTPS</tag>
        <tag>Web Security</tag>
      </tags>
  </entry>
  <entry>
    <title>一文弄懂HTTPS（II）-TLS/SSL协议握手</title>
    <url>/2018/11/15/https-tls/</url>
    <content><![CDATA[<a href="/2018/11/15/https-cryto-basic/" title="一文弄懂HTTPS（I）：密码学基础">上一篇文章</a>，我们介绍了有关HTTPS的一些密码学的基础，介绍了对称加密、非对称加密算法以及Diffie Hellman密钥交换协议等。这一篇文章，我们会介绍如何建立一个HTTPS连接，更准确的说，如何通过SSL/TLS协议建立起安全的连接。
<span id="more"></span>
<h2 id="tls-ssl协议"><a class="header-anchor" href="#tls-ssl协议">¶</a>TLS/SSL协议</h2>
<p>回到HTTPS为什么能够安全地传输数据这一问题。我们曾经回答过，数据在传输过程中被加密了。但是其实，HTTPS还是那个HTTP协议，只不过在传输层与HTTP之间加上了一层安全协议，TLS/SSL。HTTPS实质上是下面的架构。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HTTP</span><br><span class="line">----</span><br><span class="line">SSL/TLS</span><br><span class="line">----</span><br><span class="line">TCP</span><br><span class="line">----</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么，TLS/SSL又是什么东西呢？TLS（Transport Layer Security，传输层安全性协议）以及其前身SSL（Secure Sockets Layer，安全套接层）是一种安全协议，为其上层协议提供在不安全信道上的安全传输服务。TLS与其上层协议没有耦合，因此其上层协议不仅仅可以是HTTP，还可以是邮箱服务等。</p>
<p>TLS发展到现在已经到了TLS1.3版本，有兴趣的话可以查阅相关的历史沿革。</p>
<h2 id="tls握手协议"><a class="header-anchor" href="#tls握手协议">¶</a>TLS握手协议</h2>
<p>我们常说的HTTPS握手的过程实质上是TLS握手协议执行的过程。TLS采用C/S模型，即客户端服务器模型，下面我们也会使用客户端、服务器这样的术语。</p>
<p>注意TLS协议握手与密钥交换协议的目的是一致的，都是为了客户端与服务器之间能够<strong>共享一个密钥</strong>。</p>
<p>下面我们来简介一下过程：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Client                          Server</span><br><span class="line">  | ----&gt; (1) Client Hello ----&gt;   |</span><br><span class="line">  | &lt;---- (2) Server Hello &lt;----   |</span><br><span class="line">  | &lt;---- (3) Certificate  &lt;----   |</span><br><span class="line">  | &lt;---- (4) Server Key Exchange  |</span><br><span class="line">  | ----- (5) Server Hello Done    |</span><br><span class="line">  | ----&gt; (6) Client Key Exchange  |</span><br><span class="line">  ---------------------------------- Part. 1</span><br><span class="line">  | ----&gt; (7) Change Cipher Spec   |</span><br><span class="line">  | ----&gt; (8) Finish       ----&gt;   |</span><br><span class="line">  | &lt;---- (9) Change Cipher Spec   |</span><br><span class="line">  | &lt;---- (10) Finish      -----   |</span><br><span class="line">  ---------------------------------- Part. 2</span><br><span class="line">        Shakehand Finish</span><br></pre></td></tr></table></figure>
<p>握手可以分为两个部分，第一部分是客户端和服务器之间协商建立其安全通信的过程，第二部分是客户端与服务器之间就协商建立好安全通信进行测试的过程。这里我们先讲第一个部分。</p>
<h3 id="part-1-密钥交换与密钥协商"><a class="header-anchor" href="#part-1-密钥交换与密钥协商">¶</a>Part.1 密钥交换与密钥协商</h3>
<p>如前面密码学基础讲过，要实现通信双方的“悄悄话”，使用对称加密的方式，双方需要就密钥达成统一。那么，在现实中如何做到呢？这就要用到上面Part.1的握手过程了。接下来的内容，初次接触TLS的同学可能会很迷惑，因为会有很多新名词出现。不过不用担心，我会在结尾总结为什么会有这些名词的出现。好，那我们开始HTTPS探险的第一步！</p>
<h4 id="client-hello"><a class="header-anchor" href="#client-hello">¶</a>Client Hello</h4>
<p>如HTTP一样，TLS握手的第一步也是由客户端发起的，这一步向服务器表明想要建立安全连接的意愿，并且向服务器提供一些必要的信息，如接下来连接可以使用的密码套件（这里的密码指Cipher，是指一种用于<strong>加密</strong>及<strong>解密</strong>的算法，而不是我们通常意义上说的Password），以及用于生成主密钥的<strong>客户端随机数1</strong>。这一步报文携带的信息有：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Version</code></td>
<td>使用的TLS的版本号</td>
</tr>
<tr>
<td><code>Random</code></td>
<td><strong>客户端随机数1</strong>，用于生成主密钥</td>
</tr>
<tr>
<td><code>SessionId</code></td>
<td>会话ID，用处在后面会讲</td>
</tr>
<tr>
<td><code>Cipher Suite</code></td>
<td>客户端可以使用的密码套件，按优先级排序。一个密码套件包含<strong>密钥交换协议</strong>，<strong>对称加密算法</strong>，<strong>消息认证码（MAC）算法</strong>，<strong>伪随机函数</strong>。为什么是这四种后面会提到</td>
</tr>
<tr>
<td><code>Compression Method</code></td>
<td>数据压缩方法（由于存在安全漏洞，在TLS1.3中被禁用）</td>
</tr>
<tr>
<td><code>Extensions</code></td>
<td>一些扩展信息</td>
</tr>
</tbody>
</table>
<p>当服务器收到客户端的Client Hello信息之后，服务器就要忙起来了。为了建立起TLS连接，服务器需要向客户端通知：（1）就TLS版本，密码套件达成一致；（2）交换密钥使用的非对称算法的公钥及证书；（3）密钥交换协议需要的参数。</p>
<h3 id="server-hello"><a class="header-anchor" href="#server-hello">¶</a>Server Hello</h3>
<p>Server Hello信息主要表明了服务器在TLS版本，密码套件上的选择。同时服务器会向客户端发送<strong>服务器随机数2</strong>。在这一步，报文携带的信息有：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Version</code></td>
<td>使用的TLS的版本号</td>
</tr>
<tr>
<td><code>Random</code></td>
<td><strong>服务端随机数2</strong>，用于生成主密钥</td>
</tr>
<tr>
<td><code>SessionId</code></td>
<td>会话ID，用处后面会讲</td>
</tr>
<tr>
<td><code>Cipher Suite</code></td>
<td>服务器选择的密码套件，接下来的通信将会遵循这一套件</td>
</tr>
<tr>
<td><code>Compression Method</code></td>
<td>数据压缩方法（存在安全漏洞，在TLS1.3中被禁用）</td>
</tr>
<tr>
<td><code>Extensions</code></td>
<td>一些扩展信息</td>
</tr>
</tbody>
</table>
<h3 id="certificate"><a class="header-anchor" href="#certificate">¶</a>Certificate</h3>
<p>然后，服务器需要做的是把证书传递给客户端。在前一篇文章中，我们讲到了D-H密钥交换中中间人攻击。为了防止中间人攻击，需要保证非对称加密的公钥确实来自通信的一方。因此，Web建立起了PKI（Public Key Infrastructure，公开密钥基础建设）。也许以后我们会详细说这个主题。现在可以先这么想：</p>
<p>在现实生活中有公证处这一个机构，负责认证提交文件的有效性，认证之后公证处会颁发一份公证书，表明文件是真实有效的。接下来，出于对公证处这一个机构的信任，我们会信任带有公证书的这一份文件的内容。</p>
<p>假设在网络世界中有公证处这一个机构（其实是有的，数字证书认证机构，Certificate Authority, CA），我们向CA申请认证我们的公私钥对，如果认证通过的话，公证处会向我们颁发一个证书（Certification）。出于对CA的信任，我们认为证书认证过的公钥是正确的。</p>
<p>其实两者说的是一回事，想想申请公证和申请证书都是需要钱的。。</p>
<p>以本网站的证书举例（使用了Cloudflare CDN加速），我们来看看证书里包含什么信息（用PC访问的可以直接点地址栏右面的锁标记）：
<img src="/2018/11/15/https-tls/certificate-1.png" alt="Certification image 1">
<img src="/2018/11/15/https-tls/certificate-2.png" alt="Certification image 2">
<img src="/2018/11/15/https-tls/certificate-3.png" alt="Certification image 3"></p>
<p>这些字段的用处如下表所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本</td>
<td>数字证书符合的版本（<a href="https://zh.wikipedia.org/wiki/X.509">X.509</a>）</td>
</tr>
<tr>
<td>序列号</td>
<td>证书颁发机构给这份证书的序列号</td>
</tr>
<tr>
<td>签名算法</td>
<td>对证书的重点内容进行非对称加密加密，生成签名使用的算法，用于验证证书确实由颁发者背书</td>
</tr>
<tr>
<td>签名哈希算法</td>
<td>对证书内容进行哈希，生成指纹使用的算法，用于验证证书是否完整无误</td>
</tr>
<tr>
<td>颁发者</td>
<td>证书的颁发机构</td>
</tr>
<tr>
<td>有效期</td>
<td>证书的有效期</td>
</tr>
<tr>
<td>使用者</td>
<td>谁可以使用这份证书</td>
</tr>
<tr>
<td>公钥</td>
<td>这份证书认证的公钥以及非对称加密算法</td>
</tr>
<tr>
<td>公钥参数</td>
<td>非对称加密算法采用的其他参数</td>
</tr>
<tr>
<td>指纹</td>
<td>对证书内容按签名哈希算法进行哈希得到的值</td>
</tr>
</tbody>
</table>
<p>值得注意的是，证书体系中有一条信任链。层级最高的为根CA，它们的证书已经被提前预置到世界上所有的电脑中，它们可以通过签发证书授权中间CA向其他客户颁发证书。如果服务器的证书由中间CA颁发，在这个阶段，服务器需要按照信任链的顺序向客户端传送从服务器证书到离CA最近的一个中间CA的证书。如信任链是<code>CA -&gt; ICA1 -&gt; ICA2 -&gt;...-&gt; ICA n -&gt; Server Cert</code>，那么服务器需要传送<code>Server Cert, ICA n, ..., ICA 2 -&gt; ICA 1</code>。然后浏览器通过预置在电脑上的根CA的证书验证整条信任链是否完好。</p>
<h3 id="server-key-exchange"><a class="header-anchor" href="#server-key-exchange">¶</a>Server Key Exchange</h3>
<p>说了很多证书方面的东西，假设证书有效，现在客户端已经知道了如何使用非对称加密向服务器传送数据了。接下来，根据协定好的密钥交换协议，服务器<strong>可能</strong>需要向客户端传送<strong>密钥交换协议</strong>所需要的参数。这一步是<strong>可选</strong>的。以D-H密钥交换协议为例，密钥交换双方需要对$p$, $a$达成一致（不熟悉的可以看<a href="/2018/11/15/https-cryto-basic/" title="一文弄懂HTTPS（I）：密码学基础">这里</a>），在这一步可以将$p$, $q$，以及$a^{k_2} \mod p$一起发送出去。</p>
<h3 id="server-hello-done"><a class="header-anchor" href="#server-hello-done">¶</a>Server Hello Done</h3>
<p>这一个报文表示Server Hello整个过程的完成。客户端可以根据收到的信息计算Pre-master secret（预主密钥）。</p>
<h3 id="计算预主密钥"><a class="header-anchor" href="#计算预主密钥">¶</a>计算预主密钥</h3>
<p>预主密钥的生成方式与<strong>密钥交换协议</strong>有关，如果采用D-H密钥交换，客户端可以产生随机数$k_1$，然后计算$a^(k_1) \mod p$作为预主密钥，并用证书中的非对称加密方法及其公钥加密。</p>
<h3 id="client-key-exchange"><a class="header-anchor" href="#client-key-exchange">¶</a>Client Key Exchange</h3>
<p>将上面加密好的预主密钥通过Client Key Exchange报文发送给服务器。服务器使用其私钥解密，就能够得到预主密钥。</p>
<p>自此第一部分密钥协商双方交互的部分就告一段落了。接下来，客户端与服务器会使用接收到的信息计算正式通信时<strong>对称加密算法</strong>的密钥（主密钥的计算）。</p>
<h3 id="计算主密钥"><a class="header-anchor" href="#计算主密钥">¶</a>计算主密钥</h3>
<p>我们先来统计一下在上面的交换中服务器和客户端就什么值达成了一致：</p>
<ol>
<li><code>ClientHello.random</code>：由客户端在<code>Client Hello</code>报文中发送给服务器，公开信息；</li>
<li><code>ServerHello.random</code>：由服务器在<code>Server Hello</code>报文中发送给客户端，公开信息；</li>
<li><code>Pre-master secret</code>：预主密钥，非公开信息；</li>
</ol>
<p>计算主密钥的方式由RFC 5356规定：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">master_secret = PRF（pre_master_secret，“master secret”，ClientHello.random + ServerHello.random）[0..47];</span><br></pre></td></tr></table></figure>
<p>其中，<code>PRF</code>是协议约定的<strong>伪随机函数</strong>，其中<code>pre_master_secret</code>是非公开信息，因此中间人无法知道主密钥的存在，但是通信双方是可以产生同一把主密钥的。</p>
<p>到此，可能会有同学认为我们艰苦的工作就告一段落了。但是事实上没有。我们还会根据主密钥产生四把密钥。分别为：</p>
<ul>
<li>客户端写入加密密钥：客户端用来加密数据，服务器用来解密数据。</li>
<li>服务器写入加密密钥：服务器用来加密数据，客户端用来解密数据。</li>
<li>客户端写入MAC密钥：客户端用来创建MAC，服务器用来验证MAC。</li>
<li>服务器写入MAC密钥：服务器用来创建MAC，客户端用来验证MAC。</li>
</ul>
<p>WHY？？？？</p>
<h4 id="为什么双方要使用不同的内容加密密钥？"><a class="header-anchor" href="#为什么双方要使用不同的内容加密密钥？">¶</a>为什么双方要使用不同的内容加密密钥？</h4>
<p>由于在一些对称加密算法中，使用相同的密钥加密并不安全，这个<a href="https://crypto.stackexchange.com/questions/2878/separate-read-and-write-keys-in-tls-key-material">回答</a>解释了在使用RC4加密算法时，使用相同密钥加密的情况下，中间人可以通过对双方流量的监听获得明文的例子。</p>
<h4 id="mac密钥又是什么？"><a class="header-anchor" href="#mac密钥又是什么？">¶</a>MAC密钥又是什么？</h4>
<p>TLS进行了复杂的加密，但是到目前为止，只保证了<strong>中间人不能够窃听消息</strong>，但是不能保证<strong>中间人不能够篡改消息</strong>。</p>
<p>MAC（Message Authentication Code，消息认证码）机制便提供了这样一个保证。消息验证码的原理其实和通信时使用的校验和差不多。在数据发送前，一方会将<strong>明文</strong>，使用密码套件的<strong>消息认证码算法</strong>计算好MAC，然后将其包含在加密数据中。另外一方接收到报文先将密文和MAC分开，对密文使用<strong>对称加密算法</strong>解密成明文，再用<strong>消息认证码算法</strong>计算MAC，如果MAC匹配的化就认为报文是完好的。</p>
<p>自此，我们已经生成好了密码套件中所有算法需要的参数，为了保证万无一失，通信双方需要进行一次通信测试。</p>
<h2 id="part-2-通信测试"><a class="header-anchor" href="#part-2-通信测试">¶</a>Part.2 通信测试</h2>
<p>通信测试很简单，客户端先产生一个验证数据，用<strong>对称加密算法</strong>加密验证数据。首先通过<code>Change Cipher Spec</code>报文通知服务器接下来的报文会用协商好的密码套件加密，然后将加密好的验证数据通过<code>Finish</code>报文发送给服务器。服务器接受到验证数据，解密后用自己的密钥加密。先发送<code>Change Cipher Spec</code>报文通知客户端接下来的报文会用协商好的密码套件加密，然后将加密过的验证数据通过<code>Finish</code>报文回传给客户端。客户端解密后对比是否是原来的报文，是的话就意味着整个加密体系没有问题。握手过程结束。</p>
<p>接下来，通信双方转到通常模式，可以尽情地在不安全的空间说“悄悄话”了~</p>
<h2 id="tls会话复用"><a class="header-anchor" href="#tls会话复用">¶</a>TLS会话复用</h2>
<p>（我一看现在已经写了5k多字了，有点累了。。）TLS握手的过程非常冗长，涉及的运算量也比较大，对服务器会造成很大的压力。那么有什么办法减少握手的次数呢？</p>
<p>在<code>Client Hello</code>报文以及<code>Server Hello</code>报文中有一个<code>sessionId</code>字段，不知道大家在读了那么多文字之后有没有印象。对于前端的同学，<code>session</code>应该是一个很熟悉的词，它可以帮助我们保存用户登录的状态。那么我们是否可以借用<code>session</code>的思路，把一个<code>session</code>所需的参数在服务器里存储起来，把对应的<code>sessionId</code>发送给客户端。双方约定<code>session</code>失效的时间。当客户端在约定的时间之内使用<code>sessionId</code>与服务器通信，因为双方都保存着加密必要的参数，因此不需要复杂的密钥协商及交换过程就可以通信。这样大大减轻了服务器在握手上的压力。</p>
<p>但是这又带来了另外一个问题，保存大量的<code>session</code>需要大量的硬盘空间。为了解决这一个问题出现了<code>Session Ticket</code>。服务器将加密的必要参数通过保密的安全密钥加密发送给客户端，客户端加密过的参数。要通信时，在<code>Client Hello</code>报文中将<code>Session Ticket</code>带上。如果服务器能够成功解密的话就可以跳过密钥协商环节直接通信。这样就不用在服务器上存储大量<code>session</code>的信息。（把资源负担留给用户，23333）。</p>
<h2 id="密码套件"><a class="header-anchor" href="#密码套件">¶</a>密码套件</h2>
<p>现在，我们来总结一下密码套件中这些东西的作用：</p>
<ol>
<li>密钥交换协议：规定通信双方如何交换通信时使用的对称加密算法的密钥。影响<code>Server Key Exchange</code>与<code>Client Key Exchange</code>阶段；</li>
<li>对称加密算法：规定通信双方在通信时如何加密信息。影响通信测试以及正常通信；</li>
<li>消息认证码算法：规定如何对内容进行哈希，生成MAC。用于保证信息在传输过程中不受篡改；</li>
<li>伪随机算法：用于生成主密钥及相关密钥；</li>
</ol>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>TSL/SSL是一个在应用层之下，传输层之上保证应用层协议的数据能够通过不安全信道传输的安全协议。本文介绍了双方如何通过TSL握手建立安全通信的过程。</p>
<p>但是写道这，感觉还是有一些东西没有讲清楚，如证书验证的过程。这就留一个坑先吧，我们下期再见。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://xz.aliyun.com/t/2531">SSL/TLS协议详解(下)——TLS握手协议</a></li>
</ol>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
        <tag>HTTPS</tag>
        <tag>Web Security</tag>
      </tags>
  </entry>
  <entry>
    <title>混乱邪恶：JavaScript中的相等操作符（==）</title>
    <url>/2018/11/05/javascript-evil-equality/</url>
    <content><![CDATA[<p>昨天睡觉前刷到一道面试题，这个问题萦绕在我的脑海里，使得我失眠到凌晨3点。题干很简单：
<code>[] == ![]</code>的结果是什么？</p>
<p>所以我们今天来介绍一下问题的主角——相等操作符<code>==</code>，看完今天的文章，也许技术上没有什么提升，因为这玩意坑太多在开发中是极力避免使用的。但是这是一个很好的JavaScript式的问题。即如何在混乱中走出一条秩序的道路。</p>
<span id="more"></span>
<p>现在请回答以下表达式的返回值，以及<code>if</code>语句会不会执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">false</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yes, believe me, it will be executed&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// true, it will be executed</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yes, believe me, it will be executed&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明明<code>'0' == false</code>成立，为什么<code>'0'</code>在<code>if</code>中被认为是<code>true</code>呢？（现在不要深究这个问题，否则大脑会stack overflow的，相信我）这个结果混乱的相等操作符<code>==</code>是无数BUG的根源。有人总结过各种类型的值使用<code>==</code>比较后的结果，有兴趣的话可以看看<a href="https://dorey.github.io/JavaScript-Equality-Table/">JS Comparision Table</a>。Reddit上一位网友对此的评论，我认为很精髓：</p>
<p><img src="/2018/11/05/javascript-evil-equality/reddit-comment.png" alt="reddit comment"></p>
<h2 id="万恶之源-隐式类型转换"><a class="header-anchor" href="#万恶之源-隐式类型转换">¶</a>万恶之源——隐式类型转换</h2>
<p><code>==</code>之所以变得那么不讲道理，是因为在使用<code>==</code>时，对两边表达式进行<strong>隐式类型转换</strong>。这里，我推荐一篇文章“<a href="https://segmentfault.com/a/1190000008432611">从[]==![]为true来剖析JavaScript各种蛋疼的类型转换</a>”。这篇文章把整个<code>==</code>涉及的表达式值的转换过程讲的非常清楚。字比较多，大家慢慢看哈wwww。</p>
<p>好，看完回来，相信大家对隐式转换的过程有一定的了解了。但是这篇文章对<code>toPrimitive</code>介绍的不够清晰，这里我再推荐一篇文章<a href="https://javascript.info/object-toprimitive">Object to primitive conversion</a>。</p>
<p>让我们总结一下从上面学到的一些东西：</p>
<blockquote>
<p>在相等操作符中：</p>
<ol>
<li><code>undefine == null</code>，<code>undefine</code>和<code>null</code>与其他任何类型比较均为<code>false</code>；</li>
<li>若两边类型相同，按照各自类型的抽象相等规则比较：
2.1 <code>number</code>比较大小；
2.2 <code>string</code>只有在长度和对应位置字符都相等才相等；
2.3 <code>boolean</code>，不用说了吧…
2.4 <code>object</code>，比较类在内存中的地址（即两个类指向的是同一个类）；</li>
<li>基本类型(<code>boolean</code>, <code>string</code>)转化为<code>number</code>后相互比较；</li>
<li><code>Object</code>使用<code>ToPrmitive</code>算法转化为基本类型之后按2比较。</li>
</ol>
</blockquote>
<blockquote>
<p>ToPrimitive算法：
在相等操作符中，内置的<code>Object</code>（除了<code>Date</code>）均以<code>default</code>为hint转换为基本类型：</p>
<ol>
<li>如果有<code>.valueOf()</code>，尝试使用<code>.valueOf()</code>返回<strong>基本类型</strong>；</li>
<li>如果没有<code>.valueOf()</code>，或者上一步尝试失败，但是有<code>.toString()</code>，尝试使用<code>.toString()</code>返回<strong>基本类型</strong>；</li>
<li>如果都没有，或者上一步尝试失败，报错<code>TypeError</code>；</li>
</ol>
<p><code>Date</code>以<code>string</code>为hint转化为基本类型：</p>
<ol>
<li>如果有<code>.toString()</code>，尝试使用<code>.toString()</code>返回<strong>基本类型</strong>；</li>
<li>如果没有<code>.toString()</code>，或者上一步尝试失败，但是有<code>.valueOf()</code>，尝试使用<code>.valueOf()</code>返回基本类型；</li>
<li>如果都没有，或者上一步尝试失败，报错<code>TypeError</code></li>
</ol>
</blockquote>
<p>如果对<code>Date</code>的转换规则有疑虑的话，可以运行下面的代码验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date == date.<span class="title function_">valueOf</span>())  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date == date.<span class="title function_">toString</span>()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="基本object的类型转换"><a class="header-anchor" href="#基本object的类型转换">¶</a>基本<code>Object</code>的类型转换</h2>
<p>下面看一些常用的基本类型的<code>.valueOf()</code>以及<code>toString()</code>是什么，列表总结如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>具体值</th>
<th><code>.valueOf()</code></th>
<th><code>.toString()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Object</code></td>
<td><code>&#123;a: 1, b: 2&#125;</code></td>
<td><code>&#123;a: 1, b: 2&#125;</code></td>
<td><code>&quot;[object Object]&quot;</code></td>
</tr>
<tr>
<td><code>Array</code></td>
<td>[1, 2, 3]</td>
<td><code>[1, 2, 3]</code></td>
<td><code>&quot;1, 2, 3&quot;</code></td>
</tr>
<tr>
<td><code>Date</code></td>
<td><code>new Date('1970/1/1 00:00:00 GMT')</code></td>
<td><code>0</code></td>
<td><code>&quot;Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)&quot;</code></td>
</tr>
</tbody>
</table>
<p>可以看到<code>Object</code>与<code>Array</code>的<code>ToPrimitive</code>的首选方法<code>.valueOf()</code>返回的均不是基本类型之一，因此会使用<code>toString()</code>。。。Oh my god。。</p>
<h2 id="那么我们开篇问题的答案是"><a class="header-anchor" href="#那么我们开篇问题的答案是">¶</a>那么我们开篇问题的答案是</h2>
<p>是<code>true</code>。先写出整个表达式<code>[] == ![]</code>，右边<code>![]</code>是<code>false</code>（对于非操作符，是这么操作的<code>!toBoolean(GetValue(expr))</code>），而对于所有<code>Object</code>，<code>toBoolean</code>的结果都是<code>true</code>，所以右边整个式子是<code>false</code>，然后这个布尔值转化为数字是<code>0</code>。接下来我们来看左边，首先<code>[]</code>用<code>toPrimitive</code>转化为基本类型是<code>&quot;&quot;</code>，然后这个字符串转化为数字，结果也是<code>0</code>。最后<code>0 == 0</code>，当然是<code>true</code>啦。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>我一直认为相等操作符是JavaScript的设计失误之一。要弄清楚一个相等操作符的结果，与做一道数学证明题相似，从题目到中间结果到中间结果…到结果。所以，<code>==</code>仅适用于题目，而对于开发项目而言可能是万恶之源。好在JavaScript提供了正常一些的严格相等操作符<code>===</code>。所以总结就是：</p>
<blockquote>
<p>Always use 3 equals unless you have a good reason to use 2.</p>
<p>节选自<a href="https://dorey.github.io/JavaScript-Equality-Table/">JS Comparision Table</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>重新学习正则表达式——从理论角度</title>
    <url>/2019/10/15/learn-regex-from-a-mathematic-perspective/</url>
    <content><![CDATA[<p>正则表达式是一种描述<em>句法规则</em>的语言。在学习正则表达式的时候，
直接从某种程序语言的正则表达式 API 入手的我总感觉正则表达式非常复杂，
难以掌握。因此，我决定从另外一种角度重新审视一下正则表达式。</p>
<p>本文将会从正则表达式的数学原理出发，
看正则表达式如何仅仅从用 3 种基本运算就能够表示各种各样的句法规则。</p>
<span id="more"></span>
<p>通过本文，你将会了解：</p>
<ul>
<li>
<p>从数学角度重新定义正则表达式；</p>
</li>
<li>
<p>正则表达式的基本运算只有 3 种；</p>
</li>
<li>
<p>正则表达式如何通过这 3 种正则运算扩展；</p>
</li>
<li>
<p>如何构造一个复杂的正则表达式，如验证电子邮件地址的正则表达式。</p>
</li>
</ul>
<p>本文假定读者有一些集合论的基础，特别需要了解集合的并的概念。</p>
<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>经常，我们需要去提取一些符合一定规则的信息。例如，我们的手机号由 11 位数字组成，
11 位数字就是一个规则，或者说叫做模式（Pattern）。
我们可以很容易地理解 11 位数字是什么。但是，计算机却不会简单地理解这一概念。
因此，我们需要构造一种方法，最好是有明确规则的方法。使用这种方法，
让计算机知道我们所需要查找的字符串的模式，然后从原始字符串中把所需的信息提取出来。</p>
<p>美国数学家
<a href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Stephen Cole Kleene</a>
教授就发明了这样一种方法——正则表达式。</p>
<h2 id="前置概念"><a class="header-anchor" href="#前置概念">¶</a>前置概念</h2>
<p>为了研究正则表达式，我们需要先定义一些前置概念：</p>
<ol>
<li>
<p><em>字母表</em>（Alphabet）：一个<em>符号</em>的有限集合。典型的字母表有像英文字母表 a-z，
数字字母表 0-9。当然不限定是上述两类。任意符号的有限集合都是字母表。</p>
</li>
<li>
<p><em>字符串</em>（String）：一个由从字母表中抽出的符号组成的有限序列，
如 abc 就是定义在英文字母表上的字符串。我们用$|s|$表示一个字符串的长度，
并且定义空字符串$|\epsilon|$是长度为 0 的字符串，即$|\epsilon| = 0$。</p>
</li>
<li>
<p><em>语言</em>（Language）：某个字母表上字符串组成的
<a href="https://en.wikipedia.org/wiki/Countable_set">可数集</a>。
如 $L=\{0,1,2,3,4,5,6,7,8,9\}$组成了一种语言，这种语言只包含位数为 1 的数字。
定义只包含空字符串的语言为$\emptyset$。</p>
</li>
</ol>
<p>可以看到，语言是一个字符串组成的集合，
我们的目的就是去找到一种方式描述这种语言中字符串的模式。</p>
<p>在开始正则表达式的探索之前，我们先定义一个字符串之间<em>拼接</em>的操作。这个操作很简单，
如果字符串$s$与字符串$t$进行拼接，会得到字符串$st$。假如$s=\text{cat}$、
$t=\text{house}$，那么$st=\text{cathouse}$。
为了更加简便地表示同一个字符串之间的拼接操作，这里定义一个类似数学上指数的操作，
令$s$为字符串，那么定义$s^n=\underbrace{s \ldots s}_{n个}$。
可以简单理解为$s$的$n$次重复。</p>
<h2 id="基本运算"><a class="header-anchor" href="#基本运算">¶</a>基本运算</h2>
<p>有了前置概念之后，我们将会定义 3 个语言之间的基本运算，有了这 3 个运算
，我们可以使用一些基本的语言来表达出更加高级的语言。
比如使用数字作为基本语言，表达出 11 位手机号。下面$L$，$M$均表示一种语言。
这三种运算分别是：</p>
<ol>
<li>
<p>$L$与$M$的并：$L\cup M=\{s|s \in L 或 s \in M\}$</p>
</li>
<li>
<p>$L$与$M$的拼接：$LM = \{st | s \in L 且 t \in M\}$</p>
</li>
<li>
<p>$L$与$M$的 Kleene 闭包:$L^*=\cup_{i=0}^{\infty}L^i$</p>
</li>
</ol>
<p>其中$\cup{i=0}^{\infty}L^i=L^0 \cup L^1 \cup \ldots$，$L^n = \underbrace{L \ldots L}_{n个}$。</p>
<p>通过语言之间的并操作，我们可以通过两个基本语言扩展成一个范围更大的语言。
如使用一个包含大写字母与小写字母的语言$L=\{A,\ldots,Z,a, \ldots, z\}$与
包含数字的语言$D=\{0,\ldots,9\}$，
通过并操作我们可以获得一个既包含大小写字母也包含数字的语言
$L\cup D = \{A, \ldots, Z, a, \ldots, z,0,\ldots,9\}$。</p>
<p>接下来是语言之间的拼接操作。从定义可以看到，拼接操作产生了类似
<a href="https://en.wikipedia.org/wiki/Cartesian_product">笛卡尔积</a>的效果。
拼接操作可以极大地扩展语言。例如$LM$就产生了一个长度为 2 的字符串，
其中第 1 位是字母，第 2 位是数字。显然，字符串$\text{a1} \in LM$。</p>
<p>最后一种操作是 Kleene 闭包，这个操作可以将语言自身从 0 次重复（空语言$\emptyset$）
到无限次重复产生的所有语言并起来。如$D^*=D^0 \cup D^1 \cup D^2, \ldots$，
$D^0$是一个只包含的空字符串的语言，$D^1$是一个只包含 1 位数字的语言，
$D^2$是一个只包含 2 位数字的语言，一直到$D^{\infty}$，
因此$D^*$表示所有正整数加上空字符串。</p>
<h3 id="通过基本运算来表示另外一种语言"><a class="header-anchor" href="#通过基本运算来表示另外一种语言">¶</a>通过基本运算来表示另外一种语言</h3>
<p>有了上一节提到的 3 种运算，再定义一些基本语言，
我们就可以用这些运算来表示另外一种符合某种模式的语言。为了简单起见，
我们这一节还是使用前面定义的两种基本语言，
字母语言$L=\{A,\ldots,Z,a, \ldots, z\}$，数字语言$D=\{0,\ldots,9\}$。</p>
<p>现在我们想表示一个即包含字母也包含数字的语言，我们该怎么表示呢？
显然，我们可以使用$L\cup D$。为了简化表述，我们接下来用语言中字符串的模式来表示语言本身。</p>
<p>接下来，我们想要表示一个包含长度为 2 的仅包含字母的字符串，该怎么表示？显然，
使用一次拼接就可以$L^2=LL$。长度增加到 3 ？再加一次拼接，使用$L^3$就可以表示。
那么增加到$n$位？那么我们就拼接$n-1$次，使用$L^n$。最后，
我们想表示一个不固定长度仅包含字母的字符串（可以包含空字符串），使用 Kleene 闭包$D^*$即可
。使用这些技巧，我们可以表示$n$次重复的字符串。</p>
<p>最后，我们把这些运算结合起来，可以表示模式更加复杂的语言：</p>
<ul>
<li>
<p>$L(L \cup D)^3$：以字母开头的一个长度为 4 的字符串，后 3 位可以由数字与字母组成；</p>
</li>
<li>
<p>$DD^*$：所有正整数（由于与一个$D$进行了拼接，不含空字符串）；</p>
</li>
<li>
<p>$L^3 \cup L^4 \cup L^5$：由 3 到 5 个字母组成；</p>
</li>
<li>
<p>$\emptyset \cup L^1$：由 0 到 1 个字母组成。</p>
</li>
</ul>
<p>下面有一个小问题，如果要表达一个以两个字母开头，两个数字结尾的字符串？</p>
<p>如果对正则表达式的语法比较熟悉的同学可能已经发现了，
在正则表达式中对应上述几种常见模式的简写。</p>
<h2 id="正则表达式"><a class="header-anchor" href="#正则表达式">¶</a>正则表达式</h2>
<p>到这里，我们已经掌握了正则表达式背后最基本的数学原理了。没错，就那么简单。
接下来，为了进一步形式化我们上面用集合语言表达的想法，就得出了正则表达式，
它包含一套运算，以及一套优先级的定义，使得我们可以简化在大部分情况下需要的括号。</p>
<h3 id="运算"><a class="header-anchor" href="#运算">¶</a>运算</h3>
<p>基本运算还是上面提到的 3 种，但是变换了符号：</p>
<ol>
<li>
<p>并：$(r)|(s)=L(r) \cup L(s)$</p>
</li>
<li>
<p>拼接：$(r)(s)=L(r)L(s)$</p>
</li>
<li>
<p>Kleene 闭包：$(r)^*=(L(r))^*$</p>
</li>
<li>
<p>$(r) = L(r)$</p>
</li>
</ol>
<p>第 4 种运算的出现是为了让某种语言的表示与语言本身分开，
如我们可以使用<code>\d</code>代表一个数字语言$D$。这么的话就有<code>(\d) = L(\d) = D</code></p>
<h3 id="运算优先级"><a class="header-anchor" href="#运算优先级">¶</a>运算优先级</h3>
<p>通过设定合适的优先级，可以免去大部分表示优先级的括号的需要，我们设定的优先级如下：</p>
<ol>
<li>
<p>一元运算符 Kleene 闭包$*$具有最高的优先级，具有左结合性；</p>
</li>
<li>
<p>拼接运算符有第二高的优先级，具有左结合性；</p>
</li>
<li>
<p>并操作符$|$具有最低的优先级，具有左结合性；</p>
</li>
</ol>
<p>遵循上述运算优先级，我们可以把$(a)|((b)^*(c))$简化为$a|bc$。</p>
<p>到这里，我们已经完全掌握了如何使用正则表达式去表示某种模式。</p>
<h2 id="实际编程语言中正则表达式的使用"><a class="header-anchor" href="#实际编程语言中正则表达式的使用">¶</a>实际编程语言中正则表达式的使用</h2>
<p>为了便于使用，编程语言中的正则表达式对两个方面进行了扩展。第一，
为常用的模式定义了新的运算；第二，为一些常用的基本语言提供了简便表示方法。
下面以 JavaScript 为例：</p>
<p>新的运算包括：</p>
<ol>
<li>
<p>含空集的不定长度字符串$LL^*$，我们将它表示为$L^+$，也被称为正闭包（Positive Closure）。</p>
</li>
<li>
<p>长度在一定范围内的字符串$L\{m,n\}=\cup_{i=m}^{n}L^i$</p>
</li>
<li>
<p>可选字符串，空字符串或者长度为 1 的字符串$L?=\emptyset | L$</p>
</li>
</ol>
<p>新的常见基本语言表示方法：</p>
<ol>
<li>
<p>通配<code>.</code>，任意除了<code>\n</code>、<code>\r</code>、<code>\u2028</code>（<a href="https://codepoints.net/U+2028">LINE SEPARATOR</a>）、
<code>\u2029</code>(<a href="https://codepoints.net/U+2029">PARAGRAPH SEPARATOR</a>)之外的字符。</p>
</li>
<li>
<p>字符集<code>[abc]</code>：<code>[abc]</code>是$a|b|c$的简便写法。在字符集中通过<code>-</code>字符可以指定一个字符范围。</p>
</li>
<li>
<p>数字<code>\d</code>：<code>[0-9]</code></p>
</li>
<li>
<p>数字、大小写以及下划线<code>\w</code>：<code>[a-zA-Z0-9_]</code></p>
</li>
<li>
<p>取反<code>[^abc]</code></p>
</li>
</ol>
<h2 id="demo：验证电子邮件地址"><a class="header-anchor" href="#demo：验证电子邮件地址">¶</a>Demo：验证电子邮件地址</h2>
<p>作为练习，我们用正则表达式来符合 RFC-5321 规定的电子邮件地址，进而验证一个地址是否符合标准。</p>
<p>根据<a href="https://tools.ietf.org/html/rfc5321">RFC-5321(Simple Mail Transfer Protocol)</a>：
合法的电子邮件地址的格式为<code>&lt;local-part&gt;@&lt;domain&gt;</code>，这里使用<code>&lt;name-regexp&gt;</code>
表示一个子正则表达式，定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># local-part可以是两种字符串&lt;Dot-String&gt;或者&lt;Quoted-String&gt;之一</span><br><span class="line">&lt;local-part&gt; = &lt;Dot-string&gt;|&lt;Quoted-string&gt;</span><br><span class="line"></span><br><span class="line"># Dot-String必须由&lt;Atom&gt;开头，可以用.进行分隔，但是.不能是最后一位</span><br><span class="line"># 如user.name.就不行</span><br><span class="line">&lt;Dot-string&gt; = &lt;Atom&gt;(&lt;Atom&gt;\.)*</span><br><span class="line"></span><br><span class="line"># Auto是长度为1以上由&lt;atext&gt;组成的字符串</span><br><span class="line">&lt;Atom&gt; = &lt;atext&gt;&#123;1,&#125;</span><br><span class="line">&lt;atext&gt; = [a-zA-Z0-9!#$%&amp;&#x27;*+-/=?^_`&#123;&#125;\|~]</span><br><span class="line"></span><br><span class="line"># Quoted-string必须由两个引号&quot;括起来，其中的内容是&lt;QcontentSMTP&gt;*，如&quot;hello world&quot;</span><br><span class="line">&lt;Quoted-string&gt; = &lt;DQUOTE&gt;&lt;QcontentSMTP&gt;*&lt;DQUOTE&gt;</span><br><span class="line"></span><br><span class="line"># QContentSTMP可以是两种字符串之一，&lt;qtextSTMP&gt;或者&lt;quoted-pairSTMP&gt;</span><br><span class="line">&lt;QContentSTMP&gt; = &lt;qtextSTMP&gt;|&lt;quoted-pairSTMP&gt;</span><br><span class="line"></span><br><span class="line"># quoted-pairSTMP是斜杠加上斜杠加任何可显示ASCII字符，如/r、/n、/i等</span><br><span class="line">&lt;quoted-pairSTMP&gt; = /[\x20-\x7e]</span><br><span class="line"></span><br><span class="line"># qtextSTMP是除了引号&quot;、反斜杠\之外的所有可显示字符</span><br><span class="line">&lt;qtextSTMP&gt; = [\x20-\x21\x23-\x5b\x5d-\x7e]</span><br><span class="line"></span><br><span class="line">&lt;DQUOTE&gt; = &quot;</span><br><span class="line"></span><br><span class="line"># domain必须由&lt;sub-domain&gt;开头，允许后面加.&lt;sub-domain&gt;，如github.com</span><br><span class="line">&lt;domain&gt; = &lt;sub-domain&gt;(\.&lt;sub-domain&gt;)*</span><br><span class="line"></span><br><span class="line"># sub-domain必须有一个&lt;Let-dig&gt;开头，后面接一个&lt;Ldh-str&gt;</span><br><span class="line">&lt;sub-domain&gt; = &lt;Let-dig&gt;&lt;Ldh-str&gt;?</span><br><span class="line"></span><br><span class="line">&lt;Let-dig&gt; = [a-zA-Z0-9]</span><br><span class="line"></span><br><span class="line"># Ldh-str是一个不能用连字号-结尾的字符串，综合来说意味着sub-domain可以</span><br><span class="line"># 包含连字符但是不能是开头和结尾的位置。</span><br><span class="line">&lt;Ldh-str&gt; = [a-zA-Z0-9-]*&lt;Let-dig&gt;</span><br></pre></td></tr></table></figure>
<p>按照标准，我们可以逐步从子正则表达式入手，逐步地拼接成更加高级的子表达式，
直至形成最终的表达式。
由于这个正则表达式非常复杂，我们使用模板字符串来一步一步的拼接形成最后的表达式，代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> atext = <span class="string">`[a-zA-Z0-9!#$%&amp;&#x27;*+-/=?^_\`&#123;&#125;\|~]`</span></span><br><span class="line"><span class="keyword">const</span> atom = <span class="string">`<span class="subst">$&#123;atext&#125;</span>&#123;1,&#125;`</span></span><br><span class="line"><span class="comment">// 由于运算优先级的原因，添加给atom一个non-capture group，下面也有很多同样的用法</span></span><br><span class="line"><span class="keyword">const</span> dotString = <span class="string">`<span class="subst">$&#123;atom&#125;</span>(?:<span class="subst">$&#123;atom&#125;</span>\\.)*`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dQuote = <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> qtextSTMP = <span class="string">`[\\x20-\\x21\\x23-\\x5b\\x5d-\\x7e]`</span></span><br><span class="line"><span class="keyword">const</span> quotedPairSTMP = <span class="string">`\\/[\\x20-\\x7e]`</span></span><br><span class="line"><span class="keyword">const</span> qcontentSMTP = <span class="string">`(?:<span class="subst">$&#123;qtextSTMP&#125;</span>)|(?:<span class="subst">$&#123;quotedPairSTMP&#125;</span>)`</span></span><br><span class="line"><span class="keyword">const</span> quotedString = <span class="string">`<span class="subst">$&#123;dQuote&#125;</span>(?:<span class="subst">$&#123;qcontentSMTP&#125;</span>)*<span class="subst">$&#123;dQuote&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> localPart = <span class="string">`(?:<span class="subst">$&#123;dotString&#125;</span>)|(?:<span class="subst">$&#123;quotedString&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letDig = <span class="string">`[a-zA-Z0-9]`</span></span><br><span class="line"><span class="keyword">const</span> ldhStr = <span class="string">`[a-zA-Z0-9-]*<span class="subst">$&#123;letDig&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> subDomain = <span class="string">`<span class="subst">$&#123;letDig&#125;</span>(?:<span class="subst">$&#123;ldhStr&#125;</span>)?`</span></span><br><span class="line"><span class="keyword">const</span> domain = <span class="string">`(?:<span class="subst">$&#123;subDomain&#125;</span>)(?:\\.<span class="subst">$&#123;subDomain&#125;</span>)*`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">verifyEmail</span> = emailAddr =&gt; &#123;</span><br><span class="line">  <span class="comment">// 因为正则太复杂，因此使用构造函数形式，以便使用模板字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`(?:<span class="subst">$&#123;localPart&#125;</span>)@(?:<span class="subst">$&#123;domain&#125;</span>)`</span>).<span class="title function_">test</span>(emailAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">verifyEmail</span>(<span class="string">&#x27;@h-2.com&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">verifyEmail</span>(<span class="string">&#x27;a_user@h-2.com&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">verifyEmail</span>(<span class="string">&#x27;a_user@.com&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">verifyEmail</span>(<span class="string">&#x27;a_user@com&#x27;</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">verifyEmail</span>(<span class="string">&#x27;a_user@&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">verifyEmail</span>(<span class="string">&#x27;&quot;quoted user&quot;@ayase.moe&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">verifyEmail</span>(<span class="string">&#x27;&quot;quoted_with_blackslash/uuser&quot;@ayase.moe&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>现在我们已经写好了一个可能是正则表达式中最难的一个——验证邮箱地址的正则。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>在本文中，我们从几个基本概念——字母表、字符串以及语言出发，
介绍了构成正则表达式的 3 种基本操作——并、拼接与 Kleene 闭包。
我们使用了这 3 种基本操作，从字母语言与数字语言出发，
表达了一些具有复杂模式的语言。</p>
<p>通过重新定义基本运算以及运算优先级正式化了正则表达式，
并且探讨了正则表达式的一些扩展。最后我们使用了 JS 的正则表达式，
实现了一个符合 RFC-5321 的电子邮件地址验证器。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑与数据</title>
    <url>/2020/09/08/logic-and-data/</url>
    <content><![CDATA[<p>在编程入门的时候常会听说一句话：程序的本质是数据结构+算法。
在这句话中，我们可以看到程序中的两个至关重要的元素。<strong>逻辑</strong>与<strong>数据</strong>。
这个两个元素联系非常紧密，但是特性却截然想法，如同阴阳中的两极一般，既对立又统一。</p>
<span id="more"></span>
<h2 id="什么是逻辑？什么是数据？"><a class="header-anchor" href="#什么是逻辑？什么是数据？">¶</a>什么是逻辑？什么是数据？</h2>
<p>在讨论逻辑与数据的对立统一时，首先我们应该对<em>逻辑</em>与<em>数据</em>做出一个定义。</p>
<p><em>逻辑</em>是指解决一类问题的具体步骤。比如想要知道一杯未知液体是否是酸性的，
我们可以用下面的步骤来判断：</p>
<ol>
<li>使用 pH 试纸测量液体的 pH 值；</li>
<li>如果 pH 值大于 7，则被测液体为酸性，否则液体为碱性。</li>
</ol>
<p>严格而言，在本文中，
逻辑与<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a>的定义是等价的。</p>
<p><em>数据</em>指的是一种概念的具体化的产物。比如，
文章这个概念可以具体化为一个含有<em>标题</em>，<em>内容</em>等字段的记录。
在数据库中，文章表中的一列可以看作一个数据。</p>
<p>如果把程序看作一个工厂，数据就是原料，而逻辑就是机器。我们把原料放到机器里，
最终的产物就是我们期望的结果。任何有意义的程序都是逻辑与数据的有机结合。
就连最简单的 <code>Hello World</code> 也不例外。</p>
<p>然而，在和谐共存的表面下，逻辑和数据在灵活性却有着截然相反的特性。
逻辑就像房屋的骨架，在整个生命周期里都是固定的；而数据就像是房屋的外墙，
可以红色油漆来粉刷，也可以用黄色油漆来粉刷，在生命周期里可以多次改变。</p>
<h2 id="不可变的逻辑"><a class="header-anchor" href="#不可变的逻辑">¶</a>不可变的逻辑</h2>
<p>逻辑在程序的整个生命周期是不可变的。如果想要改变程序的逻辑，
必须要更改程序的源代码，有必要时需要重新编译，最后重新运行。
比如，有这样一个程序，当用户的积分大于 800 时，
赋给用户一些高级权限。用伪代码描述如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processPrivilege</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user.<span class="property">score</span> &gt; <span class="number">800</span>) &#123;</span><br><span class="line">    user.<span class="title function_">grantPrivilege</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一天，由于营销策略的变更，需要将这个积分阈值改成 700。此时，
我们无法不停机地（on the fly）满足这一需求。
要满足需求，我们需要将这一段代码更改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processPrivilege</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user.<span class="property">score</span> &gt; <span class="number">700</span>) &#123;</span><br><span class="line">    user.<span class="title function_">grantPrivilege</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以我们无法不停机地满足这一需求，是因为，我们把积分阈值 800 当作了逻辑的一部分。
在之前这段代码中，我们解决何时赋给用户权限问题的方法是—— <strong>当用户的积分大于 800 时</strong>，
赋给用户一些高级权限。很显然，在解决上一需求的现场，我们并没有考虑到积分阈值可能是会变化的。
我们轻率地把积分阈值硬编码到了逻辑中。当需求变更时，我们必须通过调整逻辑来满足最新的需求。
在实际项目的开发中，类似这种需求是非常常见的。</p>
<p>逻辑的不可变性进一步会带来开发效率的下降。调整逻辑需要研发全链路的参与，
产品需要提出正式的需求文档、开发人员需要根据需求文档调整代码、QA 需要对需求进行测试验收、
最后可能还需要发版或者上线才能使改动的逻辑生效。
有时，涉及代码改动也许仅仅几行，然而整个流程会被拉得很长。</p>
<h2 id="可变的数据"><a class="header-anchor" href="#可变的数据">¶</a>可变的数据</h2>
<p>与逻辑的不可变性相对的，数据具有高度的可变性。</p>
<p>以一个寻路程序为例，
假设我们有一个方法 <code>findBestRouteBtw(origin, dest)</code>
可以找到从出发地<code>origin</code> 到目的地 <code>dest</code> 的最佳路径。如果，
我们想找从北京西站到北京站的最佳路径，我们只需要调用
<code>findBestRouteBtw('北京西站', '北京站')</code> 就可以得出答案。
想要找从天安门到首都机场的最佳路径也没有问题，调用 <code>findBestRouteBtw('天安门', '首都机场')</code>
即可。</p>
<p>对于方法 <code>findBestRouteBtw(origin, dest)</code>而言，<code>origin</code> 与 <code>dest</code>
表示的是一种概念，<code>origin</code> 表示的是一个地点，是出发地。<code>dest</code> 表示的也是一个地点，
是目的地。它不与某个概念的具现所绑定，因此具有极为强大的灵活性。
我们可以传入各种各样的地点(数据)，它都能够给出从目的地到出发地的最佳路径。
计算机的强大也来源于此。</p>
<p>对于一些需求变更，也可以通过变更数据来满足。例如，需求需要有一个程序，
能够实时展示当时上证综指的指数。很明显，上证综指是一个实时变化的量。
这个量我们需要通过某个接口去获取，用伪代码表示如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sseIndex = <span class="keyword">await</span> <span class="title function_">getSSEIndex</span>();</span><br><span class="line"><span class="title function_">show</span>(sseIndex);</span><br></pre></td></tr></table></figure>
<p>可以看到，获取上证综指已经委托给了一个方法 <code>getSSEIndex</code> 。
这个方法可以通过调用上海证券交易所的接口，也可以调用其他第三方接口获取指数。
显然，指数每次变化都不需要重新编码或者重新部署程序。</p>
<h2 id="逻辑与数据的互相变化"><a class="header-anchor" href="#逻辑与数据的互相变化">¶</a>逻辑与数据的互相变化</h2>
<p>逻辑和数据是可以互相转化。从数据转化为逻辑很容易，
比如硬编码某个值就是把数据转化为逻辑的一种。这里不再赘述。</p>
<p>逻辑也可以转化为数据，以用户提权例子为例。当用户积分大于 800 时，赋予用户一些高级权限。
如果我们意识到，<em>积分阈值</em>是可变的，我们就可以把积分阈值当作一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processPrivilege</span>(<span class="params">privilegeThreshold</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user.<span class="property">score</span> &gt; privilegeThreshold) &#123;</span><br><span class="line">    user.<span class="title function_">grantPrivilege</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">processPrivilege</span>(<span class="number">800</span>);</span><br></pre></td></tr></table></figure>
<p>在上述代码中，800 仍然是硬编码的。但是，将积分阈值作为一个形参抽象出来，
给积分阈值的变化带来了可能。我们稍作一些变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPrivilegeThreshold</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...读取配置文件、从数据库中获取、读取命令行、环境变量等等来获取阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processPrivilege</span>(<span class="params">privilegeThreshold</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user.<span class="property">score</span> &gt; privilegeThreshold) &#123;</span><br><span class="line">    user.<span class="title function_">grantPrivilege</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">processPrivilege</span>(<span class="title function_">getPrivilegeThreshold</span>());</span><br></pre></td></tr></table></figure>
<p>这样的话，积分阈值完全成为了一个数据。我们可以从任何地方获取积分阈值这个数据，
比如从数据库获取、从某个微服务接口中获取等等。此时，
如果有一天积分阈值需要从 800 变到 700，我们只需要把数据源中的对应值改成 700 即可。
不需要修改源代码，不需要提测，不需要上线，可以节省大量时间。</p>
<p>在理想世界中，我们希望任何需求都可以通过修改数据的方式来实现。显然，
这种方式是最有效率的。但是，很多时候我们很难看清楚逻辑与数据的边界，
因此错误地把数据当作逻辑，或者把数据当作逻辑来实现。</p>
<p>误把数据当作逻辑的例子有很多，比如各种硬编码的值。
误将逻辑当作数据实现不常见，但是也存在。
这种错误最典型就是抽象过度，例如一个计算圆的周长的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPI</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14159</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculatePerimeter</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getPI</span>() * <span class="number">2</span> * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里圆周率并不是一个可变量，并不需要可变性。因此把获取圆周率抽象成一个函数是不恰当的。
更好的方法是把圆周率作为一个常量看待：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculatePerimeter</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">PI</span> * <span class="number">2</span> * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象过度会极大地损害程序的可读性与可维护性。因此也是需要极力避免的。</p>
<p>因为我们很难一次性弄清楚逻辑与数据的边界，所以，
随着业务需求变化对程序进行调整是必要的。我们需要把一些逻辑调整为数据，
或者把数据调整为逻辑。这种调整就是<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84">重构</a>。
重构本身是非常大的话题，在本文中就不展开了。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<ul>
<li>逻辑与数据是程序的核心要素。逻辑与数据在程序内是对立统一的；</li>
<li>在可变性上，逻辑在生命周期中是不可变的，数据是可变的；</li>
<li>对于需求变更，一般情况下，我们希望通过调整数据来解决；</li>
<li>对于某个特定需求很难弄清楚数据与逻辑的边界；</li>
<li>在项目的生命周期里，需要通过重构去找到最合适的边界。</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>纯CSS Flex实现日历布局</title>
    <url>/2018/11/22/make-a-calender-with-css-flex/</url>
    <content><![CDATA[<p>日历布局，顾名思义，就是像日历一样的布局。。长的大概像下面（来自<code>ElementUI</code>）：</p>
<p><img src="/2018/11/22/make-a-calender-with-css-flex/calender-layout.png" alt="calender layout"></p>
<p>看到行数和列数都固定的这种布局，首先会想到的就是使用表格去做。但是作为前端，要学会不走寻常路。我们会在本文中尝试使用强大的CSS Flex实现这种布局。</p>
<span id="more"></span>
<h2 id="日历布局设计"><a class="header-anchor" href="#日历布局设计">¶</a>日历布局设计</h2>
<p>日历布局是一个7栏6列的布局。其中每一个日期元素高宽均为<code>30px</code>，每一个日期元素与其相邻元素之间距离<code>10px</code>。边界上的日期元素与日历容器元素的边框相距<code>10px</code>。大概长得向下面这样。（偷懒没有把尺寸标明上去。）</p>
<p><img src="/2018/11/22/make-a-calender-with-css-flex/calender-illustration.png" alt="calender layout illustration"></p>
<h2 id="level-1：使用table布局"><a class="header-anchor" href="#level-1：使用table布局">¶</a>Level 1：使用Table布局</h2>
<p>使用<code>table</code>实现这一种布局非常简单，首先我们先把HTML文档写出来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>日<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>一<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>二<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>三<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>四<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>五<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>六<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>8<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>9<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>10<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>11<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>12<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>13<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>14<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>15<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>16<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>17<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>18<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>21<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>22<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>24<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>25<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>26<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>27<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>28<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>29<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>31<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们利用<code>border-spacing</code>属性指明表格项<strong>边框</strong>之间的距离为<code>10px</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: aqua;</span><br><span class="line">  <span class="attribute">border-spacing</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到要求日期元素的高宽为<code>30px</code>，那么这里的高宽是指<code>height</code>，<code>width</code>吗？显然在这里高宽应该是指<code>Border Box</code>的高度与宽度，因此，我们将<code>box-sizing</code>设为<code>border-box</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">td</span>,</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，emmm，没有然后了。为了明显，我们将<code>th</code>,<code>td</code>加上背景色，效果如下：</p>
<p><img src="/2018/11/22/make-a-calender-with-css-flex/calender-layout-with-table.png" alt="calender layout with table"></p>
<h2 id="level-2：-多层嵌套纯css-flex实现"><a class="header-anchor" href="#level-2：-多层嵌套纯css-flex实现">¶</a>Level 2： 多层嵌套纯CSS Flex实现</h2>
<p>接下来，我们来考虑纯CSS Flex实现。首先我们可以看到日历组件是可以分为两个部分的，一个以垂直方向排列的日期行，而日期行里面是水平排列的日期项。由这个想法我们很容易想出一个嵌套<code>flex</code>容器的布局。HTML文档如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-row-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>日<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>一<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>四<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>五<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>六<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-row-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-row-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>11<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>13<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>14<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-row-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>15<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>16<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>17<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>19<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>21<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-row-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>22<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>23<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>24<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>25<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>26<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>27<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>28<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-row-wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>29<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>31<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>div.flex-wrapper</code>是最外层的<code>flex</code>容器，它的主轴方向是垂直的。为了边缘元素与容器元素边界的<code>10px</code>间隙。我们在这里使用<code>padding: 10px</code>实现这一要求。接下来是行之间的间隙如何解决。注意到，CSS Flex里有一个<code>justify-content: space-between</code>，可以将头尾两个元素分别放置在主轴的头尾两端，其他元素之间的间隙相等，间隙的大小由空余空间自动计算。这个特性非常适合用来解决行之间间隙的问题。我们只需要计算6个<code>30px</code>高度的行，加上行间<code>10px</code>间隙需要多少高度即可，答案是<code>6 * 30px + 5 * 10px = 230px</code>。由此，我们可以这么写<code>.flex-wrapper</code>的样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: column;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">230px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来考虑行的问题，思考方式同理，只是主轴方向换到水平方向。在按照上面的原理计算完所需宽度之后，这个值应该作为最外层容器的<code>width</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: column;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">270px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">230px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-row-wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后给<code>.cell</code>指定高宽：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cell</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>着色之后，效果如下：</p>
<p><img src="/2018/11/22/make-a-calender-with-css-flex/calender-with-nested-flex.png" alt="calender with nested flex"></p>
<blockquote>
<p>没有什么是<code>flex</code>不能解决的，要是有，就再套一层<code>flex</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB:糟糕的程序语言</title>
    <url>/2017/10/26/matlab-bad-language/</url>
    <content><![CDATA[<p>MATLAB 因为其“标准库”具有丰富的功能（包括内置的函数以及工具箱），能够很容易地实现工程中的很多算法，因此一直是学术界事实上的仿真软件的标准。关于他的便利性，有一次我甚至在不知道 FFT 的细节的情况下，依靠查阅文档在 30 分钟之内写出了一个使用 FFT 对信号进行频域分析的小程序，包含数据输入和数据可视化。包含超过一半的注释，代码不到 100 行。可以理解为什么在学术界以及工程界，MATLAB 能够得到近似必修课一样的待遇。</p>
<p>但是，在需要在 MATLAB 中构建一个稍微复杂一点的系统的时候呢？MATLAB 会迅速地变得糟糕起来。有时甚至需要非常反直觉的 trick 才能够实现一些编程中的 essential practice。一方面，MATLAB 本身语言上还是有极大的缺陷。一方面 MATLAB 文档只是 how to do 而缺少 why to do，使得我们很难去抓住高级用法的本质，更谈不上用到 MATLAB 设计者想象中预想的最佳实现。</p>
<span id="more"></span>
<h2 id="反直觉的函数以及类文件限制"><a class="header-anchor" href="#反直觉的函数以及类文件限制">¶</a>反直觉的函数以及类文件限制</h2>
<p>如很多编程语言一样，函数是 MATLAB 中主要的代码重用的方法之一。但是反直觉的是，MATLAB 在一个<code>.m</code>文件中只允许暴露一个函数给外部使用。这样迫使使用者要么将可能非常复杂的功能实现在一个“主函数”中，而将其中的逻辑分散在其中不能被外部调用的“子函数”中；要么将所有的“子函数”写成单独<code>.m</code>文件。前者，能够复用的只是实现特定功能的主函数，而不能够复用子函数。设想如果我们有两个神经网络，它们可能用到同一种 activation function，如<code>ReLu</code>。那么为了复用<code>ReLu</code>，我们只能选择将<code>ReLu</code>单独抽出来作为<code>.m</code>文件。这无疑增加了要管理的文件数量，并且最后我们会发现这些<code>.m</code>文件并不在同一个逻辑抽象的层级如在同一个文件夹中，包含<code>cnn.m</code>，<code>rnn.m</code>，<code>relu.m</code>。这样就会非常令人困惑，加大维护难度。当然，通过恰当的将这些文件归类到文件夹中可以稍微减轻不适感。但是作为一门编程语言而言，这样的限制还是相当怪异的。</p>
<p>但是，比起类，函数的文件限制造成影响要温柔许多。是的，<strong>一个<code>.m</code>文件只能包含一个类，而且是同名的类</strong>。设想，JavaScript 中一个<code>.js</code>只能声明一个<code>class</code>（ES6）,Python 中一个<code>.py</code>文件只能声明一个<code>class</code>。再设想，C++中一个<code>.hpp</code>文件中只能包含一个 class 的声明。在所有宣称支持 OOP 的编程语言中，对类施加这种限制的语言恐怕只有 MATLAB 了。这样带来的后果是，就算两个类有非常密切的关系，如一个类是另外一个类的选项的 enumeration class，我们都必须将这些类分开为两个文件，而且根本没有任何的 workaround。这样一来，类文件的层级就会变得非常混乱。</p>
<h2 id="缺少模块作用域或者命名空间"><a class="header-anchor" href="#缺少模块作用域或者命名空间">¶</a>缺少模块作用域或者命名空间</h2>
<p>在许多现代的编程语言之中，为了在大型项目中避免命名冲突，或多或少都会引入模块作用域或者命名空间的概念。如 Python，一个<code>.py</code>文件就是一个 module。在其他文件中要使用到这个文件的一些函数或者类的时候，要显式地<code>import xxx</code>到另外的文件中。这样减少了命名冲突的可能。但是，MATLAB 却不然。所有在 MATLAB 的 Path 中的函数都在同一个作用域中——全局作用域。这些函数可能来自 MATLAB 的内置功能、安装的工具箱、第三方库以及自己编写的代码。有兴趣的话，在 Command Window 输入<code>is</code>然后再使用 tab 键自动补全，看看下拉菜单里这些函数名。根本不知道哪个函数来自于哪个功能。这个缺陷导致最严重的后果就是命名时冲突的可能性大大增加。由于 MATLAB 涵盖很多工程领域的一些算法，如果当我们不知道有这样一个算法或者想动手实现一个相同的算法时，命名相同的可能性就会非常的大。而在 MATLAB 中是允许后来的名字去覆盖前面的名字的，此时造成的 BUG 就会非常难以察觉。MATLAB 所提供的工具箱中有很多重名的函数，如<code>write</code>。在一次想实现 TCP socket 通信时，就出现了这样一个 BUG。<code>write(tcpclient, data)</code>是向建立好的 socket 写入数据的函数。但是，实际调用的时候，MATLAB 却提示参数错误。在一段非常令人懊恼的 DEBUG 过程之后，我终于发现出问题的<code>write</code>函数并不是来自于想要的工具箱。通过手动的调整 pathdef.m 文件才解决了这一 BUG。</p>
<p><img src="/2017/10/26/matlab-bad-language/images/2017/10/20171025222801.png" alt="若干重复的write函数"></p>
<h2 id="混乱的命名规则"><a class="header-anchor" href="#混乱的命名规则">¶</a>混乱的命名规则</h2>
<p>一个项目必然要遵循一定的命名规则。如果所有的命名都是遵循一致的命名规则的时候，我们就可以通过命名规则去猜测实现某一功能的函数的名字。但是 MATLAB 再次令人失望了。在短短的以<code>is</code>开头能够搜索到的函数，我们就能够看到至少三种命名规则的存在：驼峰命名法（<code>is2dDataArray</code>）、下划线间隔的全小写命名（<code>is_simulink_handle</code>）以及不用下划线间隔的全小写命名（<code>ischar</code>）。当初学某种语言的时候，我们会模仿着其标准库去制定命名规则。但是在这里，我们能够选择什么命名规则呢？所有都可以吧。当第三方开发者再向这个本来就缺少隔离的，杂乱无比的全局作用域中添加函数时，简直就是一种灾难。这时，MATLAB 文档就凸显了其重要性。我们只能够对功能进行描述去 Google 出文档，才能够知道对应的函数是什么。而一门优秀的语言不是这样的。如 JavaScript 中对<code>Array</code>进行遍历操作。JavaScript 可以使用<code>Array.forEach(callback)</code>对一个数组进行遍历，我们绝对不会在写代码的时候怀疑这个函数到底是<code>foreach</code>、<code>for_each</code>、<code>ForEach</code>等等。</p>
<p>总而言之，混乱的命名规则进一步使得本来就不怎么干净的作用域变得混乱无比。加大了开发的难度。</p>
<h2 id="vector-array-cell-array"><a class="header-anchor" href="#vector-array-cell-array">¶</a>Vector? Array? Cell Array?</h2>
<p>数组(array)是一种常见的数据结构，几乎在所有的程序中都会或多或少的用到它。无论是静态语言中，如 C++中的原生数组<code>int arr[10]</code>，或者是其标准库中的<code>Vector&lt;t&gt;</code>，或者是动态语言中，如 Python 中的 List <code>l = [1, 2, 3]</code>。它们的意义和操作都非常的清晰。当选择用什么东西去实现“数组”的时候，我们根本不会有什么其他的想法。但是，MATLAB 又给我们上了一课。</p>
<p>MATLAB 中存在像数组的对象不止一种，如<code>array</code>、<code>cell array</code>、<code>character array</code>等。第一种是矩阵的一个特殊形式——“一维矩阵”，在数学意义上叫做向量，为了避免歧义，第一种数组从现在开始用<code>vector</code>来表示。这种数组只能用于存储数。这很容易理解，毕竟它来自于 MATLAB 的杀手功能——矩阵运算。当我们仅仅需要存储数的时候，<code>vector</code>可以是一种选择。它具备在运行时调整大小的能力，是一个完全的“动态数组”的实现。当我们很开心地用上了<code>vector</code>却发现我们需要去实现一个二维动态数组的时候，问题就出现了。</p>
<p>如我们有两个数组<code>a = [1 2 3]</code>，<code>b = [3 2]</code>。<code>a</code>记录 A 端口的历史数据，<code>b</code>记录 B 端口的历史数据。由于不同步的原因，A 和 B 不会同时收到数据。而我们预测到之后有增加端口的需求，总不能够<code>c</code>、<code>d</code>、<code>e</code>这样的命名下去吧。我们很容易想到用一个以端口号索引的二维数组<code>history</code>，调用<code>history[1]</code>就可以获取第 1 个端口的历史数据。这时如果是各个端口历史记录个数不相同的情况下时，MATLAB 就会报出与维数相关的错误了。因为如果用到了二维数组，此时概念就变成了<code>matrice</code>（矩阵），它在数学意义上是一个$m \times n$的数字阵列。任何一行的数字个数不相等是不能够定义一个矩阵的。</p>
<p>此时<code>cell array</code>就会变成一个很好的选择。它和 Python 中的 List 非常的相像。具有动态调整大小的能力，而且不关心里面所存元素的数据类型。可以说，<code>cell array</code>才是最贴近作为数据结构的<code>array</code>的概念。所以，个人推荐在需要使用到数组这一数据结构的时候都使用<code>cell array</code>实现。</p>
<p>但是接下来麻烦才刚刚开始。在解决一些 BUG 的时候，会发现<code>cell array</code>居然会有两种访问的方式，小括号的下标运算符<code>[]</code>以及大括号的下标运算符<code>&#123;&#125;</code>，而且它们的作用截然不同。</p>
<pre><code>&gt;&gt; history=&#123;&#123;1,2&#125;,&#123;3,5,2&#125;&#125;

history =

1×2 cell array

  &#123;1×2 cell&#125;    &#123;1×3 cell&#125;

&gt;&gt; history&#123;1&#125;

ans =

1×2 cell array

  [1]    [2]

&gt;&gt; history(1)

ans =

cell

  &#123;1×2 cell&#125;
</code></pre>
<p>你没有看错，当你尝试去访问第一个端口的历史数据时，<code>history&#123;1&#125;</code>得到是一个<code>1x2 cell array</code>，而<code>history(1)</code>得到的是一个<code>cell</code>，它的元素是一个<code>1x2</code>的<code>cell array</code>。这意味与<code>history&#123;1&#125;</code>的等价写法是</p>
<pre><code>tempArray = history(1);
tempArray&#123;1&#125;
</code></pre>
<p>那么可能有人会问<code>history(1)&#123;1&#125;</code>不就等价了吗？不，MATLAB 会提示你<code>Error: ()-indexing must appear last in an index expression.</code> Index 这一类操作符还有顺序限制？这也是在写本文的时候才发现的问题。难道不是<code>history(1)</code>先得到一个<code>cell</code>，我们再用<code>&#123;1&#125;</code>去 index 第一个元素吗?想不通啊。这样就会出现一类 BUG，你以为得到了值，但是其实你并没有真正得到你想要的东西。这种 BUG 会非常令人困惑，如果不通过单步调试是找不出来的。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>不可否认 MATLAB 以及其工具箱是非常强大的。对于一些利用微分方程等就能够进行简单建模的任务，MATLAB 是极佳的选择。但是，当这门脱胎于数值计算任务的语言用于构建较为复杂的“软件”的时候，其自身的局限就会被放大，甚至造成非常不好的编程体验。这就是为什么我称它是糟糕的“编程语言”的原因。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>Programming Language</tag>
      </tags>
  </entry>
  <entry>
    <title>非递归的二叉树后序遍历</title>
    <url>/2016/10/28/nonrecursive-post-order-traversal/</url>
    <content><![CDATA[<p>后序遍历是遍历二叉树的一种方式。其遍历方式是先遍历一个结点的所有左子结点，再遍历其所有右
子结点，最后访问自身。后序遍历有非常简单的递归解法，但是如果要把它转化为非递归的解法的话
会出现一定的困难。</p>
<span id="more"></span>
<h2 id="后序遍历的递归解法"><a class="header-anchor" href="#后序遍历的递归解法">¶</a>后序遍历的递归解法</h2>
<p>后序遍历可以归结于以下步骤：</p>
<ol>
<li>后序遍历一个结点的左子结点；</li>
<li>后序遍历一个结点的右子结点；</li>
<li>访问自己</li>
</ol>
<p>因此可以使用以下递归算法来解决这一问题（使用伪代码描述）：</p>
<pre><code>Post-Order-Traversal(node):
  if node.left != NIL
    Post-Order-Traversal(node.left)
  if node.right != NIL
    Post-Order-Traversal(node.right)
  Manipulate(node)
</code></pre>
<h2 id="非递归的后序遍历算法"><a class="header-anchor" href="#非递归的后序遍历算法">¶</a>非递归的后序遍历算法</h2>
<p>众所周知，程序中函数的调用一般是通过栈实现的。因此，对于一个递归函数，我们总能够通过模仿
系统管理栈的做法把它转化为非递归的实现。
但是，在后序遍历里，只使用一个栈记录结点是不足的。当先前一个结点，如一个结点的父结点，当
它出栈的时候，算法不能够记录它的状态，如它的子结点是否已经处理过？显然处理过和没处理过两
种状态，之后要执行的步骤是不一样的。基于这种想法，在非递归的实现中，我们可以增加另外一个
栈，专门记录状态。在一些语言中允许使用<code>tuple</code>或<code>pair</code>这样的有序数组，可以使用这些结构作
为栈的元素（因为结点和状态是一一对应的），这样就可以不用另外开一个栈。</p>
<p>非递归的后序遍历算法可以写成如下伪代码：</p>
<pre><code>//Sn: New stack of node
//Ss: New stack of status
//Node: root of tree
Post-Order-Traversal(Sn, Ss, node):
  Sn.push(node)
  Ss.push('uncheck')
  while Sn is not empty:
    presentNode = Sn.pop()
    presentStatus = Sn.pop()
    if presentStatus is 'uncheck':
      Sn.push(presentNode)
      Ss.push('checked')
      if presentNode.right != NIL:
        Sn.push(presentNode.right)
        Ss.push('uncheck')
      if presentNode.left != NIL:
        Sn.push(presentNode.left)
        Ss.push('uncheck')
    else  // Case for checked node
      Manipulate(presentNode)
</code></pre>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>概率图模型(I)——motivation</title>
    <url>/2018/02/03/pgm-note-1/</url>
    <content><![CDATA[<span id="more"></span>
<p>对于一个含有很多随机变量的复杂的分布而言，所有可能的事件可能非常多，如果用每一个事件对于一个描述概率的参数的话，显然参数的个数会非常的多，甚至不可行。但是现实世界中，随机变量之间常常会有联系，如果我们能够在模型构建的过程中将这些联系考虑进去的话，会大大减少表示这个模型所需要的参数。要描述随机变量之间的联系，很自然地，我们会想到用<strong>图</strong>。所以概率图模型就是这样一个通过引入随机变量之间的联系，来对概率模型进行建模的一种框架。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Probabilistic Graphical Model</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>坑日志:Python在初始化数组时奇怪的元素重用</title>
    <url>/2018/04/19/pitfall-strange-reuse-in-initialization-of-array-in-python/</url>
    <content><![CDATA[<p>数组是非常好用的东西。有的时候，我们想要初始化一个固定长度的数组。Python提供了一个非常简便的写法<code>[elem_to_repeat] * num_time</code>，如<code>[0] * 4</code>，会初始化一个长度为4，元素全为0的数组<code>[0, 0, 0, 0]</code>。这种写法在处理一维数值型、布尔型数据的时候不会产生问题。但是，通常人们会不了解这种写法的真实意义，即_将<code>elem_to_repeat</code>的引用_重复<code>num_time</code>遍来初始化数组。</p>
<span id="more"></span>
<h1>例子</h1>
<p>假如我们要初始化一个元素全为0的2*2的矩阵，在不适用任何第三方库的情况下，最容易想到的方法是<code>[[0]*2]*2</code>。我们在环境中运行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">0</span>] * <span class="number">2</span>] * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p>看起来没有任何问题，我们可能就接着继续往前做了。但是，如果某个时候，我们想把第1行第1个元素改成1，然后继续，会发现结果和自己认为的大相径庭。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p>没有看错，第1行的第1个元素，以及第2行的第1个元素都变成了1。这和我们所期望的完全不一样。</p>
<h2 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h2>
<p>为什么会这样呢？出现问题的原因就在初始化使用的语句<code>a = [[0] * 2] * 2</code>。更准确的来说是最外层的重复。注意到<code>list</code>是一个可变对象，那么我们实际在最外层的数组中存储了两个同样指向<code>[0] * 2</code>的引用。等效的执行过程是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inner_elem = [<span class="number">0</span>] * <span class="number">2</span></span><br><span class="line">a = [inner_elem, inner_elem]</span><br></pre></td></tr></table></figure>
<p>如果此时，我们对<code>a[0][0]</code>赋值的话，实际上改变的是<code>inner_elem[0]</code>的值，此时输出<code>a</code>的值的话，自然是之前输出的结果，因为<code>a[0]</code>和<code>a[1]</code>指向的都是相同的元素。</p>
<p>那么内层的初始化为什么不会出现这样的问题呢？因为数值型的数据都是不可变对象，引用的方式是指向内存池中表示该数值的内存地址。所以实际表现起来会像所谓按值传递的性质——会复制传入的值的值。感兴趣的话可以参考有关Python中可变对象以及不可变对象的区别。</p>
<h2 id="解决方案"><a class="header-anchor" href="#解决方案">¶</a>解决方案</h2>
<p>那么问题的核心在于如何强迫Python创建不同的list。我们可以使用List comprehension</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p><code>[[0] * 2 for _ in range(2)]</code>会强迫Python创建两个_不同_的初始值为2个0的list。自此问题解决。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>设置Atom的包管理器——apm的代理</title>
    <url>/2017/03/11/proxy-setting-of-apm/</url>
    <content><![CDATA[<p>Atom是一款非常流行的文本编辑器。借由庞大的插件支持，用户可以把它改造成适合自己的开发环境使用。但是由于众所周知的原因，在某地要更新插件并不容易。有时会刷不出来可更新插件的列表，即使能够刷出来，更新也可能因为各种网络原因而失败。解决这一问题，为Atom的更新服务挂上代理是一个不错的解决方案。</p>
<span id="more"></span>
<h2 id="apm-atom-package-manager"><a class="header-anchor" href="#apm-atom-package-manager">¶</a>apm——Atom Package Manager</h2>
<p>Atom的插件更新功能由apm提供。apm内部封装了一个npm。熟悉JS的同学会对npm非常的熟悉。apm更新插件时会先发送请求到atom.io/api/packages获取所有安装的包的最新信息。如果发现有更新的版本，apm会利用npm获取最新的包。所以，如果你刷不出来列表，多半是因为无法连接到atom.io。刷出来列表了，但是更新时出现网络错误，可能是因为无法连接到npm的源。</p>
<h2 id="解决方案"><a class="header-anchor" href="#解决方案">¶</a>解决方案</h2>
<h3 id="为apm挂上代理"><a class="header-anchor" href="#为apm挂上代理">¶</a>为apm挂上代理</h3>
<p>首先我们来解决第一个问题，访问atom.io不畅。这一点可以通过给apm挂上代理解决。apm内置了设置代理的功能，详细可以参见<a href="https://github.com/atom/apm#using-a-proxy" title="apm - Atom Package Manager">apm - Atom Package Manager</a>。简单而言，在命令行/终端窗口执行下列命令：</p>
<pre><code>apm config set https-proxy http://your-proxy-address:port
</code></pre>
<p>将上面的<code>your-proxy-address</code>替换为你的代理服务器地址，<code>port</code>替换为你的代理服务器端口即可。</p>
<p>执行下列命令，看<code>https-proxy</code>是否出现在输出中，可以证实设置是生效的：</p>
<pre><code>apm config list
</code></pre>
<p>网上有教程说要设置<code>http-proxy</code>的，通过<code>apm upgrade --verbose</code>查看请求之后可以看到请求并未经过代理。</p>
<h4 id="对于ss代理的解决方案"><a class="header-anchor" href="#对于ss代理的解决方案">¶</a>对于SS代理的解决方案</h4>
<p>SS代理在这里是无法直接使用的。因为SS本身并不是一个http代理。所以，我们可以用polipo将SS代理转化为一个http代理。这一方面可以参见<a href="https://github.com/shadowsocks/shadowsocks/wiki/Convert-Shadowsocks-into-an-HTTP-proxy" title="Convert Shadowsocks into an HTTP proxy">SS的官方文档</a>。</p>
<h3 id="给apm换一个软件源"><a class="header-anchor" href="#给apm换一个软件源">¶</a>给apm换一个软件源</h3>
<p>Atom的插件实际上在npm上，npm的官方源在国内访问起来是非常缓慢的。但是，国内有许多镜像源可以使用，如淘宝源(http://registry.npm.taobao.org/)，CNPM（http://r.cnpmjs.org）。</p>
<p>要设置apm使用的软件源很简单，执行下列命令：</p>
<pre><code>apm config set registry npm_mirror_url
</code></pre>
<p>将上面的<code>npm_mirror_url</code>替换为你想要使用的镜像源。如要使用淘宝源，即可以使用以下命令。</p>
<pre><code>apm config set registry http://registry.npm.taobao.org
</code></pre>
<p>至此，我们已经完成了整个更新流程的“优化”。atom应该可以正常更新了。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title>纯CSS Flex实现骰子5点布局</title>
    <url>/2018/11/11/pure-flex-dice/</url>
    <content><![CDATA[<p>前几天面试的时候被问到这样一个问题：</p>
<blockquote>
<p>如何使用纯CSS Flex实现骰子五点。不能使用<code>position: absolute</code>等绝对定位技巧。实现五点的元素，如<code>div</code>处于同一个嵌套层级。</p>
</blockquote>
<p>没答上来，凉了。我真是CSS苦手啊。。。昨晚突然一想，这个好像有解的样子。于是实现了一波。</p>
<span id="more"></span>
<h2 id="level-1：-多层flex"><a class="header-anchor" href="#level-1：-多层flex">¶</a>Level 1： 多层Flex</h2>
<p>如果我们不看最后一个约束，即我们可以自由的安排元素之间的嵌套关系，这道题没有什么难度。注意到Flex可以嵌套Flex。我们需要1个大的Flex容器，嵌套2个小的Flex容器（左右两个点）就可以做出来了，代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-circle-container&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-circle-container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-circle-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: column nowrap;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circle-center</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有<a href="https://codepen.io/ayase-252/pen/PxGWMe">Demo</a>。</p>
<h2 id="level-2：纯flex-无嵌套"><a class="header-anchor" href="#level-2：纯flex-无嵌套">¶</a>Level 2：纯Flex，无嵌套</h2>
<p>当我们要满足所有题目的要求的时候呢，问题就来了。总所周知，Flex布局的核心就是沿着主轴排布元素，元素可以放置侧轴的一些位置上（<code>align-items/align-self</code>）。运用这些特性，我们可以做成五点的大模样，但是不标准。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-center</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-bottom</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2018/11/11/pure-flex-dice/imperfect-dice.png" alt="imperfect-dice"></p>
<p>问题在于下面两个点的位置。（好像无解的样子啊，好紧张啊…(面试中的我))</p>
<p>其实我们有一些方式移动元素的位置，当时没有想到。哎…第一，我们可以使用<code>transform</code>去移动下面两个点，第二，我们也可以使用<strong>负margin</strong>去移动下面两个点。但是所有这些，我们都要先计算出要移动的距离。注意我们使用的<code>justify-content: space-between</code>。它的语义是将头和尾部两个元素放在<code>flex-start</code>和<code>flex-end</code>的位置，然后元素之间的间隙由剩下的空白空间平均分配。在这个例子中，容器宽度为<code>100px</code>，所有<code>flex</code>元素的宽度加起来也为<code>100px (20px * 5)</code>。所以元素之间的空隙为<code>0px</code>。那么我们要移动的距离是多少呢？当然是<code>20px</code>。</p>
<p>依照这个想法，我们先使用<code>transform</code>实现一下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-bottom circle-bottom-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-bottom circle-bottom-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-center</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-bottom-left</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">20px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-bottom-right</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">20px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/ayase-252/pen/RqGKOL">Demo</a>，效果可以。</p>
<p>但是，对于负<code>margin</code>，这里有一点有趣的地方。下面两个点需要<code>-40px</code>才能够做到，可以看<a href="https://codepen.io/ayase-252/pen/VVKppy">Demo</a>。至于为什么？我还需要探索探索。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>这里介绍的技巧也许在生产环境中用不着，但是是一个比较好的综合题。嗯。。。（我当时真的想不出来）对Flex中多种布局属性以及元素移动技巧考察还是挺到位的。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title>你所不知道的scroll事件：为什么scroll事件会失效？</title>
    <url>/2018/11/20/scroll-event/</url>
    <content><![CDATA[<p>在Web开发中，<code>Scroll</code>事件是一个很重要的事件。通过<code>Scroll</code>事件，我们可以通过一些方式获知视口在页面的位置。知道这个信息可以帮助我们判断很多东西，如用户即将浏览到页面底部，是不是该调用API加载一些新的内容等等。</p>
<p>在实际运用中，<code>scroll</code>事件常常带来很多迷惑。最近在开发练手的博客项目时就遇到了一个问题，在<code>Vue</code>中的组件绑定<code>scroll</code>事件，事件处理函数似乎不会触发。这个问题好像困扰过很多人，谷歌<code>Vue 滚动事件失效</code>能发现很多相关内容。比如说<a href="https://segmentfault.com/q/1010000009119633">这一个问题</a>，可以一个个去试他们给出的解决方案，总会发现几个有用的。但是作为开发者，知其然还要知其所以然。那么，本文就来探究一下这个<code>scroll</code>事件的背后到底有什么不为人知的东西。</p>
<span id="more"></span>
<h2 id="javascript事件模型"><a class="header-anchor" href="#javascript事件模型">¶</a>JavaScript事件模型</h2>
<p>大家都知道，JavaScript事件有两个阶段——（1）<strong>捕获阶段(Capture Phase)</strong>（2）<strong>冒泡阶段(Bubble Phase)</strong>。捕获阶段是事件从<code>document</code>到传递到目标元素的过程，而冒泡阶段是事件从目标元素传递到<code>document</code>的过程。下面是《高程》上的一张图，很明了地描述了整个过程。</p>
<p><img src="/2018/11/20/scroll-event/capture-bubble-phase.png" alt="capture-bubble-phase"></p>
<p>在平时，大家一般是监听事件的冒泡阶段，即<code>elem.addEventListener('scroll', handler)</code>。<code>Vue</code>中也提供了<code>v-on</code>指令监听某个事件，默认用的也是事件的冒泡阶段。那么这里会有什么坑呢？</p>
<p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/scroll">MDN</a>对<code>scroll</code>事件的描述，我们发现了惊人的事实：</p>
<blockquote>
<p>冒泡: <code>element</code>的<code>scroll</code>事件<strong>不冒泡</strong>, 但是<code>document</code>的<code>defaultView</code>的<code>scroll</code>事件冒泡</p>
</blockquote>
<p>这句话的意思就是说，如果<code>scroll</code>的目标元素是一个元素的话，比如说是一个<code>div</code>元素。那么此时事件只有从<code>document</code>到<code>div</code>的捕获阶段以及<code>div</code>的冒泡阶段。如果尝试在父级监视<code>scroll</code>的冒泡阶段监视这一事件是无效的。如果<code>scroll</code>是由<code>document.defaultView</code>（目前<code>document</code>关联的<code>window</code>对象）产生的有冒泡阶段。但是由于其本身就是DOM树里最顶级的对象，因此只能在<code>window</code>里监视<code>scroll</code>的捕获阶段以及冒泡阶段。</p>
<p>注意到在元素为目标元素时，也在目标元素上监视<code>scroll</code>事件的捕获阶段以及冒泡阶段。两种情况其实内在是一致的。接下来我们会通过两个Demo证明这一点。</p>
<h2 id="当scroll的目标元素为document-defaultview时"><a class="header-anchor" href="#当scroll的目标元素为document-defaultview时">¶</a>当scroll的目标元素为document.defaultView时</h2>
<p>这是最常见的情形，比如知乎，可以在console里执行<code>window.addEventListener('scroll', e =&gt; console.log(e.target), true)</code>，然后滑动滚动条就可以看见效果。</p>
<p>这里我们自己写一个小型的HTML文档。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;scroll-in-window.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（大段复制代码搞得我像灌水一样，反正是自己博客，灌就灌吧）那么多的<code>Hello world</code>是为了让浏览器产生滚动条，所需要的数量由屏幕分辨率而定。。</p>
<p>接下来，我们分别在<code>window</code>与<code>div#root</code>上监听<code>scroll</code>事件的捕获阶段以及冒泡阶段；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scroll-in-window.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll handler is triggered in window during capture phase.&#x27;</span>), <span class="literal">true</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll handler is triggered in window during bubble phase.&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll handler is triggered in root during capture phase.&#x27;</span>), <span class="literal">true</span>)</span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll handler is triggered in root during bubble phase.&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Chrome下运行如下：
<img src="/2018/11/20/scroll-event/result-in-window.png" alt="result-in-window"></p>
<p>这里我也准备了在线Demo，请戳<a href="https://codepen.io/ayase-252/pen/xQpGKj?editors=1011">这里</a></p>
<p>可以看到在全程只有<code>window</code>上监听<code>scroll</code>的<strong>捕获阶段</strong>以及<strong>冒泡阶段</strong>的回调函数执行了。这验证之前的结论：</p>
<blockquote>
<p>如果<code>scroll</code>是由<code>document.defaultView</code>（目前<code>document</code>关联的<code>window</code>对象）产生的有冒泡阶段。但是由于其本身就是DOM树里最顶级的对象，因此只能在<code>window</code>里监视<code>scroll</code>的捕获阶段以及冒泡阶段。</p>
</blockquote>
<h2 id="当scroll的目标元素是元素时"><a class="header-anchor" href="#当scroll的目标元素是元素时">¶</a>当scroll的目标元素是元素时</h2>
<p>这种情况也常见，我给出一种示例：一个双栏布局，左侧为导航栏，右侧为内容，父容器使用<code>Flex</code>布局，要求导航栏不随内容的滑动而滑动。HTML文档如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Scroll In Element<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#wrapper</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#left-col</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#right-col</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left-col&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        barabara</span><br><span class="line">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right-col&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;scroll-in-element.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下：
<img src="/2018/11/20/scroll-event/demo.png" alt="demo"></p>
<p>此时<code>scroll</code>事件的目标元素是<code>div#right-col</code>。接下来我们，分别在<code>window</code>,<code>div#wrapper</code>,<code>div#right-col</code>上监听<code>scroll</code>的捕获阶段以及冒泡阶段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">log</span> = (<span class="params">elem, phase</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scroll handler is trigged in <span class="subst">$&#123;elem&#125;</span> during <span class="subst">$&#123;phase&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bindEvent</span> = (<span class="params">elem, elemName</span>)  =&gt; &#123;</span><br><span class="line">  elem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, log.<span class="title function_">bind</span>(<span class="literal">null</span>, elemName, <span class="string">&#x27;capture&#x27;</span>), <span class="literal">true</span>)</span><br><span class="line">  elem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, log.<span class="title function_">bind</span>(<span class="literal">null</span>, elemName, <span class="string">&#x27;bubble&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bindEvent</span>(<span class="variable language_">window</span>, <span class="string">&#x27;window&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> wrapper = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#wrapper&#x27;</span>)</span><br><span class="line"><span class="title function_">bindEvent</span>(wrapper, <span class="string">&#x27;wrapper&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> rightCol = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#right-col&#x27;</span>)</span><br><span class="line"><span class="title function_">bindEvent</span>(rightCol, <span class="string">&#x27;rightCol&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在Chrome上运行如下：
<img src="/2018/11/20/scroll-event/result-in-element.png" alt="result-in-element"></p>
<p>这里我也准备了在线Demo，请戳<a href="https://codepen.io/ayase-252/pen/BGJNXR?editors=1011#">这里</a></p>
<p>这里的运行结果很清楚的展示了<code>scroll</code>事件的传递轨迹，也证明了展示了我们之前说的：</p>
<blockquote>
<p>如果<code>scroll</code>的目标元素是一个元素的话，比如说是一个<code>div</code>元素。那么此时事件只有从<code>document</code>到<code>div</code>的捕获阶段以及<code>div</code>的冒泡阶段。</p>
</blockquote>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>还用《高程》里那一副图总结一下<code>scroll</code>的事件流向：</p>
<p><img src="/2018/11/20/scroll-event/scroll-event-flow.png" alt="scroll-event-flow"></p>
<p>当触发元素为<code>div</code>时，事件从<code>document</code>（在浏览器的实现上是<code>window</code>）开始向下传递，直到目标元素，此时捕获阶段结束。接下来在目标元素上进行一次冒泡阶段（4），然后不再冒泡。</p>
<p>对于<code>document.defaultView</code>产生的<code>scroll</code>事件一样，由于其本身就是顶层元素，在其本身上冒泡可以视为冒泡阶段结束。</p>
<h3 id="建议"><a class="header-anchor" href="#建议">¶</a>建议</h3>
<p>综上所述，在debug<code>scroll</code>事件失效问题的时候要清楚两个东西：</p>
<ol>
<li><code>scroll</code>事件的目标元素是什么？也可以说谁产生了<code>scroll</code>事件。如果实在不清楚的话，可以用Chrome开发者工具的<code>Performance</code>模块录制一下滚动动作，然后在<code>Event Log</code>里查看<code>scroll</code>事件的目标元素。</li>
<li>监听<code>scroll</code>事件的元素是否在<code>scroll</code>事件的传递路径上，是否监听了正确的阶段？</li>
</ol>
<p>弄清楚这些基本上就能够判定为什么<code>scroll</code>事件的回调触发不了了。</p>
<p>另外有一个万能的方法，就是在<code>window</code>上监听<code>scroll</code>的捕获阶段，即<code>window.addEventListener('scroll', handler, true)</code>。这也是很多类似问题中答主回答的答案。希望在看完本文之后能对其原理有所了解。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li>Nicholas C. Zakas, Professional JavaScript for Web Developers, Third Edition</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/scroll">scroll - MDN</a></li>
</ol>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Web Development</tag>
        <tag>JavaScript</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>快慢指针寻找链表中的环</title>
    <url>/2018/08/21/slow-fast-pointers-for-cycle-detection-in-linked-list/</url>
    <content><![CDATA[<p>在做<a href="https://leetcode.com/problems/find-the-duplicate-number/description/">Find the Duplicate Number</a>的时候，看到一个非常有趣的算法。这个算法可以用$O(n)$的复杂度来寻找链表（有向图）中的环的起始点。</p>
<span id="more"></span>
<h2 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h2>
<p>问题要求在$n+1$个数中寻找重复的数，其中数是$[1, n]$中的整数。由此很容易证明序列中一定会有重复的数。</p>
<p>题目有四个限制条件，限制了常用的减少复杂度的方法：</p>
<ol>
<li>不能修改原数据。（不能使用$O(n\log n)$的排序算法进行预处理）</li>
<li>只能使用$O(1)$的空间。（不能使用哈希表）</li>
<li>计算复杂度小于$O(n^2)$。(不能穷举）</li>
<li>只有一个重复的数字，但是重复的次数可能不止一次。（不能使用数学公式直接得出）</li>
</ol>
<p>在限制之下，这个看似简单的问题的解法就变得很少了。一种方法是把传入的数组看作是邻接数组。此时就可以将问题看作是在链表（有向图）中寻找环的问题。</p>
<h2 id="深度优先搜索-dfs"><a class="header-anchor" href="#深度优先搜索-dfs">¶</a>深度优先搜索（DFS）</h2>
<p>在有向图中寻找环，首先想到的算法是深度优先搜索（DFS），但是由于要标记访问过的节点，需要$O(n)$的空间复杂度，不符合本题的限制。</p>
<h2 id="快慢指针法"><a class="header-anchor" href="#快慢指针法">¶</a>快慢指针法</h2>
<p>在无法使用DFS的情况下，可以使用双指针去解决寻找链表中的环的问题。问题转化非常巧妙。由于算法细节乍看难以理解，这里先展示算法代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slowTag = nums[<span class="number">0</span>]</span><br><span class="line">        fastTag = nums[nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">while</span> slowTag != fastTag:</span><br><span class="line">            slowTag = nums[slowTag]</span><br><span class="line">            fastTag = nums[nums[fastTag]]</span><br><span class="line">        fastTag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> slowTag != fastTag:</span><br><span class="line">            slowTag = nums[slowTag]</span><br><span class="line">            fastTag = nums[fastTag]</span><br><span class="line">        <span class="keyword">return</span> slowTag</span><br></pre></td></tr></table></figure>
<h3 id="算法思想"><a class="header-anchor" href="#算法思想">¶</a>算法思想</h3>
<p>整个算法包含两个部分，第一部分在寻找环的位置，第二部分是寻找所在环的入口点。而这个入口点就是我们要寻找的重复的数。以<code>[1, 3, 4 ,2, 2]</code>为例，用链表可以表示为下图。
<img src="/2018/08/21/slow-fast-pointers-for-cycle-detection-in-linked-list/2018-08-21-21-21-24.png" alt="Illustration"></p>
<p>很显然因为<strong>重复的数会有多条边同时指向它</strong>，因此重复的数就是链表中环的起始点。</p>
<p>算法的第一部分是使用两个指针，一个快指针<code>fastTag</code>，一个慢指针<code>slowTag</code>。<code>fastTag</code>一次前进两步，<code>slowTag</code>一次前进一步。直到两者相等停止。原理很简单，假设环是一个跑道，当两个不同速度的运动员在环中跑步，不限跑动距离的情况下，跑的慢的运动员总会被跑的快的运动员“套圈”。被套圈的位置必然在环中。这个位置是我们算法的一个中间结果，记为$m$。</p>
<p>第二部分是算法难以理解的部分，我们将其中的一个指针，如<code>fastTag</code>重新放到起始点0。并在循环中同时将每一个指针的位置向前移动一个位置。到它们相遇的时候，相遇点就是<strong>环的起始位置</strong>。用数学可以证明这一点。</p>
<h3 id="第二次循环的相遇点是环起始点的证明"><a class="header-anchor" href="#第二次循环的相遇点是环起始点的证明">¶</a>第二次循环的相遇点是环起始点的证明</h3>
<p>设起点0到第一次循环的相遇点$m$的距离为$d$。环的长度为$c$。显然，慢指针移动的距离为$d_s = d$。快指针移动速度是慢指针的两倍，因此移动的距离为$d_f = 2d_s = 2d=d+nc$，其中$n$为正整数。整理有$d=nc$。设起始点到环的入口点的距离为$l$，入口点到第一次循环相遇点的距离为$d_m$。有$d=l+d_m$。将$d=nc$带入，有$nc=l+d_m$。整理有$l=(n-1)c+(c-d_m)$。因此，从起点开始的指针前进$l$步的同时，从中间位置出发的指针会回到环的起始点。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>这套算法的时间复杂度为$O(n)$，空间复杂度为$O(1)$，符合题目的限制。这套算法精彩的地方在使用两个速度不同的指针在环中相遇做文章。实在是非常聪明的想法。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Linked List</tag>
        <tag>Cycle Detection</tag>
      </tags>
  </entry>
  <entry>
    <title>Step by Step —— 解密原型链</title>
    <url>/2018/11/21/step-by-step-prototype/</url>
    <content><![CDATA[<p>原型链是JavaScript中的一个核心特性，会在前端面试中经常问道。原型链原理十分简单，但是在面试题里看起来似乎不是那么简单。通过一些不常有的操作，原型链的面试题很容易就可以将人陷入一个迷宫之中无法脱出。只有掌握原型链的基本原理的勇士才能够找出通往出口的道路。</p>
<p>但是正如我说的，原型链的原理是简单的。本文会通过三个步骤，来看这些面试题是怎么将简单的原型链弄复杂的。</p>
<span id="more"></span>
<h2 id="入门：prototype与-prototype"><a class="header-anchor" href="#入门：prototype与-prototype">¶</a>入门：prototype与[[prototype]]</h2>
<p>原型链的原理其实很简单：<strong>如果在某个对象中查找一个属性而在当前属性中未命中时，JavaScript引擎会转向该对象<code>[[prototype]]</code>指向的对象继续查找这个属性</strong>。在一般浏览器里<code>[[prototype]]</code>被实现为<code>__proto__</code>属性，因此下面用<code>__proto__</code>替换<code>[[prototype]]</code>的写法。</p>
<p>因此执行以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">obj.<span class="property">__proto__</span> = &#123;<span class="attr">c</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">c</span>)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>obj.c</code>为2，因为<code>c</code>属性不在<code>obj</code>的属性中，因此JS引擎向原型链的上一级，即<code>obj.__proto__</code>查找<code>c</code>，此时命中了<code>c</code>。所有原型链的终极思路都是这个。</p>
<p>接下来，我们将问题变的复杂一点点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jim = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jim&#x27;</span>)</span><br><span class="line">jim.<span class="title function_">sayName</span>() <span class="comment">// &#x27;Jim&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这是一个很典型地使用原型链实现类的形式。这里<code>jim</code>搜寻到了<code>.sayName</code>方法。为什么呢？这个问题的关键在于<code>new Person(Jim)</code>干了什么？</p>
<p><code>new</code>操作符可以看作以下函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">F, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    obj.<span class="property">__proto__</span> = F.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="keyword">const</span> retVal = F.<span class="title function_">apply</span>(obj, args)</span><br><span class="line">    <span class="keyword">if</span>(!retVal &amp;&amp; <span class="keyword">typeof</span> retVal === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> retVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总而言之，<code>new</code>就干了三件事情：</p>
<ol>
<li>生成一个继承自<code>F.prototype</code>的新对象<code>obj</code>；</li>
<li>在新对象<code>obj</code>上调用构造函数<code>F</code>；</li>
<li>如果构造函数有返回值，<strong>且返回值是一个对象</strong>，返回返回值，如果不满足以上情况，返回构造的对象<code>obj</code>。</li>
</ol>
<div class="note warning"><p><code>new</code>操作符在构造函数返回对象的时候会将其当作<code>new</code>操作符的结果返回。见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new</a>。</p>
<p>2018/12/18修改</p>
</div>
<p>构造函数一般没有返回值。但是在有返回值的情况下注意区别，可能这里要考。</p>
<p>到这里，原型链的初级部分就差不多了。用这些知识可以做一个小练习：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span> (name, school) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">school</span> = school</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">saySchool</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">school</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jack = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;MIT&#x27;</span>)</span><br><span class="line">jack.<span class="title function_">sayName</span>()</span><br><span class="line">jack.<span class="title function_">saySchool</span>()</span><br></pre></td></tr></table></figure>
<p>上面<code>jack.sayName()</code>、<code>jack.saySchool</code>会输出什么呢?</p>
<h2 id="进阶-constructor"><a class="header-anchor" href="#进阶-constructor">¶</a>进阶:constructor</h2>
<p>当原型链与<code>constructor</code>混合起来，问题就又复杂了一层。复杂的原因在于，从属性名看起来它指向的是对象的构造函数，但是可能因为一堆骚操作之后，<code>constructor</code>并不是指向对象的构造函数。</p>
<p>要解决<code>constructor</code>是什么的问题，我们还是从最简单的例子开始。</p>
<h3 id="constructor在哪里？"><a class="header-anchor" href="#constructor在哪里？">¶</a>constructor在哪里？</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jim = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jim&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jim.<span class="property">constructor</span>)</span><br></pre></td></tr></table></figure>
<p>在浏览器上是可以打印<code>jim.constructor</code>属性的，它指向的确实是<code>Person</code>函数。但是能够打印属性那么它一定在<code>jim</code>上吗？事实上不是的，<code>jim.constructor</code>其实是<code>jim.__proto__.constructor</code>。在浏览器上执行<code>jim.constructor === jim.__proto__.constructor</code>会返回<code>true</code>证明了这一结果。</p>
<p>从<code>new</code>操作符的执行过程来看，我们并没有向新构造的元素添加<code>constructor</code>属性，我们有的只是通过<code>__proto__</code>方法继承构造函数的<code>prototype</code>，<code>constructor</code>就是在这一步被加入对象的原型链中。</p>
<p>在明白了<code>constructor</code>在哪里之后，诶？说了那么久，<code>constructor</code>到底是什么东西啊?</p>
<h3 id="constructor是什么？"><a class="header-anchor" href="#constructor是什么？">¶</a><code>constructor</code>是什么？</h3>
<p>相信大家都用过<code>instanceof</code>运算符。这个运算符的功能就是沿着原型链查找<code>constructor</code>，如果在原型链上找到了运算符右边所指的构造函数，那么<code>instanceof</code>就会返回<code>true</code>。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jim <span class="keyword">instanceof</span> <span class="title class_">Person</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jim <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>大家可能会疑问为什么<code>jim instanceof Object</code>是<code>true</code>呢？这个答案在<code>jim.__proto__.__proto__.constructor === Object</code>。这就是沿着原型链查找<code>constructor</code>属性的意思。这样也就是说<code>Person.prototype.__proto__.constructor === Object</code>。emmmm，越来越混乱了吧，这个思路我们先停在这里，不要细想。接下来我们会讲到这一问题。</p>
<h3 id="练习题"><a class="header-anchor" href="#练习题">¶</a>练习题</h3>
<p>明白了这一原理，我们来面试中常出现的骚操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jim = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jim&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jim.<span class="property">constructor</span>)</span><br></pre></td></tr></table></figure>
<p>现在<code>jim.constructor</code>该打印出什么呢？</p>
<p>按照我们刚才的思路，<code>jim.constructor === jim.__proto__.constructor === Person.prototype.constructor === &#123;&#125;.constructor</code>。注意到<code>&#123;&#125;</code>本身又是一个对象，它也有<code>__proto__</code>属性，我们继续推导<code>&#123;&#125;.constructor === &#123;&#125;.__proto__.constructor === Object.prototype.constructor === Object</code>。推导结束，答案为<code>Object</code>。大家可以自行在浏览器里验证这一答案。</p>
<p>看完上面的推导过程是不是感觉在做数学题一样呢？但是这种骚操作仍然是较简单的操作，更加混乱的还在后面。</p>
<h2 id="专家：function-prototype"><a class="header-anchor" href="#专家：function-prototype">¶</a>专家：<code>Function.prototype</code></h2>
<p>既然，对象的<code>__proto__</code>属性与构造函数的<code>prototype</code>属性的关系是如此密切。那么在默认情况下，构造函数的<code>prototype</code>又是什么呢？</p>
<p>通过控制台查看<code>Person.prototype</code>可以看到，在默认情况，<code>Person.prototype</code>是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">constructor</span>: ƒ <span class="title class_">Person</span>(name)</span><br><span class="line"><span class="attr">__proto__</span>:</span><br><span class="line">    <span class="attr">constructor</span>: ƒ <span class="title class_">Object</span>()</span><br><span class="line">    <span class="attr">hasOwnProperty</span>: ƒ <span class="title function_">hasOwnProperty</span>()</span><br><span class="line">    <span class="attr">isPrototypeOf</span>: ƒ <span class="title function_">isPrototypeOf</span>()</span><br><span class="line">    <span class="attr">propertyIsEnumerable</span>: ƒ <span class="title function_">propertyIsEnumerable</span>()</span><br><span class="line">    <span class="attr">toLocaleString</span>: ƒ <span class="title function_">toLocaleString</span>()</span><br><span class="line">    <span class="attr">toString</span>: ƒ <span class="title function_">toString</span>()</span><br><span class="line">    <span class="attr">valueOf</span>: ƒ <span class="title function_">valueOf</span>()</span><br><span class="line">    <span class="attr">__defineGetter__</span>: ƒ <span class="title function_">__defineGetter__</span>()</span><br><span class="line">    <span class="attr">__defineSetter__</span>: ƒ <span class="title function_">__defineSetter__</span>()</span><br><span class="line">    <span class="attr">__lookupGetter__</span>: ƒ <span class="title function_">__lookupGetter__</span>()</span><br><span class="line">    <span class="attr">__lookupSetter__</span>: ƒ <span class="title function_">__lookupSetter__</span>()</span><br><span class="line">    get <span class="attr">__proto__</span>: ƒ <span class="title function_">__proto__</span>()</span><br><span class="line">    set <span class="attr">__proto__</span>: ƒ <span class="title function_">__proto__</span>()</span><br></pre></td></tr></table></figure>
<p>即一个指向自身的<code>constructor</code>属性，以及指向<code>Object.prototype</code>的<code>__proto__</code>。构造函数的<code>prototype</code>属性是<strong>唯一影响通过该构造函数构造的对象的原型链的因素。</strong></p>
<p>但是，在面试中为了增加混乱度，有一些单位会在<code>Function.prototype</code>上动手脚，这又是怎么一回事呢？</p>
<h3 id="构造函数与function-prototype"><a class="header-anchor" href="#构造函数与function-prototype">¶</a>构造函数与Function.prototype</h3>
<p>在JavaScript中，函数本身也是对象，因此函数本身也有<code>__proto__</code>属性指向<code>Function.prototype</code>对象。可以通过<code>Person.__proto__ === Function.prototype</code>验证这一结论。因为这条原型链的关系，我们可以使用诸如<code>Person.call(this, args)</code>这些函数专有的方法。但是注意，这条原型链上与构建出来的对象的原型链是没有任何关系的，因为<code>new</code>操作符的关系，构造出来的对象的<code>__proto__</code>只和函数的<code>prototype</code>有关。</p>
<h3 id="终极测验"><a class="header-anchor" href="#终极测验">¶</a>终极测验</h3>
<p>下面是本文的终极测验，类似真实面试中的题，可以花几分钟时间做一下…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">o1</span> (a) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = a</span><br><span class="line">&#125;</span><br><span class="line">o1.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="number">2</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">d</span> = <span class="number">4</span></span><br><span class="line"><span class="keyword">const</span> ob1 = <span class="keyword">new</span> <span class="title function_">o1</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">b</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">constructor</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">__proto__</span>.<span class="property">constructor</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">constructor</span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">d</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span>)</span><br></pre></td></tr></table></figure>
<p>答案密封线</p>
<p>==========</p>
<p>答案揭晓，不知道各位同学答对没有</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">a</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">b</span>)  <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">constructor</span>) <span class="comment">// o1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">__proto__</span>.<span class="property">constructor</span>) <span class="comment">// o1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>) <span class="comment">// o1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ob1.<span class="property">constructor</span>.<span class="property">__proto__</span>) <span class="comment">// Function.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">d</span>) <span class="comment">//4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>) <span class="comment">// Object.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span>) <span class="comment">// Object</span></span><br></pre></td></tr></table></figure>
<p>这种题我还能随手写很多，可见其变化。。。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>在遇见复杂的原型链问题时，特别是像上面那种代码非常杂乱的，首先先冷静，问题都是从一个对象查找一个属性，用我们的原型链原理：</p>
<blockquote>
<p>如果在某个对象中查找一个属性而在当前属性中未命中时，JavaScript引擎会转向该对象<code>[[prototype]]</code>指向的对象继续查找这个属性。</p>
</blockquote>
<p>此时只要明白一件事情，当前对象里有什么属性。如果当前对象里没有所要的属性，就搞清楚当前对象的<code>__proto__</code>里有什么属性。根据对象的不同，如普通对象（由字面值构建出来的对象）、构造对象（由<code>new</code>操作符构建的对象）、函数对象，一定弄清楚<code>__proto__</code>是什么。一直查找到不存在<code>__proto__</code>或者<code>__proto__</code>为<code>null</code>为止。</p>
<p>下面是基于本文例子的一张关系图，用于参考。
<img src="/2018/11/21/step-by-step-prototype/relation-among-objects.png" alt="relation among objects"></p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new运算符</a></li>
</ol>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Web Development</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>无题</title>
    <url>/2018/02/03/the-manipulation-of-public-opinion/</url>
    <content><![CDATA[<p>一直以来，我自认为是一个自由主义者。我尊重所有人说话的权力，尽管有的时候我不同意你的意见。我支持所有人都有不受限制的访问互联网的权利，这是互联网诞生的意义。地球的所有公民能够在一个友善祥和的气氛中，通过无处不在的互联网，分享自己的所见所学，共同进步。小时候从学到互联网的时候，我觉得互联网应该就是这样的。直到现在，依然如此觉得。</p>
<span id="more"></span>
<p>随着互联网的普及，互联网似乎变成了第二社会一样。各种各样的措施被用在互联网中，似乎害怕着其用户看到什么东西。但是，当你看到外面的东西的时候呢，却发现外面其实没有什么可害怕的东西，甚至还有无穷无尽的知识的精粹在外面放着。多好的东西啊，为什么害怕人看见呢？百思不得其解的问题。</p>
<p>我也喜欢看一些片，纯粹地只是为了缓解一天学习工作后的精神劳累。没有什么特殊的理由。这些片也很简单，不会比相声复杂到哪里去。在前几年呢，从现在的眼光看，看片本身是一个很“累”的事情。需要先想一想今天会有哪一些片播出来，然后一个一个的在一个小网站找，把下载到的文件再导入到另外一个下载软件里，等待个几分钟才能看。但是最近这些年呢方便一点了，因为一些网站有钱了，可以把一些片买下来了，，我可以在浏览器里点一点鼠标就能看了，虽然说这都是生意，网站需要流量，我需要片，各取所需，所以我还是不反感这种做法的。</p>
<p>但是呢，久而久之，这个圈子也如当年的80后鄙视90后一样，鄙视链慢慢就形成起来了。先来的叫dalao，因为他们看过的片很多，很有想法，认为最近出的片都是辣鸡。后来的叫萌二，我不知道这个词到底是怎么来的，词义大概是讽刺这些新来的看到一部片就说是神作。其实我并不关心谁是dalao，谁是萌二。大家都是看片的，没有什么高下之分的。但是后来，有很多人发现，可以通过看片掌握话语权，话语权是一个真正好东西，没人嫌多的东西。有了话语权，你的观点就会有很多人看，换句话说就是钱啊。当看片都成为了一门生意的时候，事情就开始向意想不到的方向发展了。起初为了流量，他们可以故意的在看片这个问题上制造矛盾点，引起无数小白的战争，流量到了。但是，战争的种子播下去之后是会生根发芽的，正如war,war never change。之后，每一季换片之后，这个战争愈演愈烈。直到这一季，终于突破了临界点，一部分看片的观众终于发现了只要毁灭掉世界，就可以毁灭掉对手这种方案，可喜可贺。</p>
<p>另外一件令人惊叹的事情就是，要把一件事情说成像是真的成本有多低这个问题。一个SMS的截图，甚至是一张论坛网页的截图就能够当作实锤发出来。从没有想过，第一种只要你会精分就能够自己凭空造出来。第二种？伟大的Chrome给了你一个无敌好用的网页debug的工具，别说一张论坛的截图，就算是给谁谁谁转账100000000000的截图也能轻易造出来的。只需要这样一点劳动力就能够让群众在舞台上跳舞，成本真是令人低得乍舌。在小时候，互联网被认为是信息的快车道。但是现在，互联网，仍然是信息的快车道，但是上面的车是不是黑车就要更细心的判别了。说实话，就连我也不一定判断的准。</p>
<p>这篇文章原来不是写互联网的吗？怎么突然扯了那么多东西。直到现在，我依然还是认为，互联网应该是开放的，依然那么认为。希望过几年，如果能够翻出这篇不成熟的文章，希望世界能够变成期望中的那样了。今天中二了一下，抱歉了。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Anime</tag>
        <tag>Feeling</tag>
      </tags>
  </entry>
  <entry>
    <title>测试的价值</title>
    <url>/2021/06/08/the-value-of-testing/</url>
    <content><![CDATA[<p>今天，我打算开一个新的栏目——<a href="/categories/Thinking">Thinking</a>
来记录在生活中的一些思考。栏目中的文章主题不限于技术，
包含生活中的方方面面。（其实是因为长文太难写了，草稿箱里可能已经坑了20来篇了
（笑）。</p>
<p>那么栏目的第一篇，我打算聊一聊「自动化测试」。</p>
<span id="more"></span>
<p>很多研发会觉得写测试用例是非常累赘的事情。有些会认为，
业务变化太快，维护测试用例费时不讨好；有些会认为，公司配备了完整的 QA 团队，
有问题让 QA 人工测试就好，没必要让研发写自动化测试等等；还有可能，
业务需求开发时间被压缩，觉得“额外”再写一份测试用例降低工作效率等等。</p>
<p>在日常工作中，至今为止接触的数十个项目中，
只有少数一两个项目在 CI 的要求下保证了一定的单元测试覆盖率（如果我没记错的话 50% ）。
其它项目基本上没有自动化测试用例的存在。毫不令人意外的，项目经常出现的现象有：</p>
<ul>
<li>实现一个不相关的需求，导致线上其它不相关功能出现 bug；</li>
<li>为了不改动旧代码逻辑，大量复制粘贴代码，
仔细一看，其中的实现逻辑大同小异，如就差一个判断等；</li>
<li>没人完全知道一个函数所有的输入输出的意义，类型与范围；</li>
<li>大量的全局变量；</li>
<li>大家都知道代码逻辑很烂，但是没有勇气重构去改良它们；</li>
<li>测试提出问题之后，需要在多处埋点 <code>console.log</code> 去寻找问题的根源在哪，
耗费大量时间；</li>
</ul>
<p>如果自动化测试是低效的，那么与之相反，没有自动化测试应该会体现出高效。
但是在实际中，没有自动化测试的项目中，反而也体现了低效与风险。
仔细思考的话，是否对于<em>自动化测试</em>的看法是有误的吗？是否自动化测试真的会对
项目的<em>开发效率</em>、<em>调试效率</em>、<em>可维护性</em>产生负面影响？🤔</p>
<h2 id="自动化测试与开发效率"><a class="header-anchor" href="#自动化测试与开发效率">¶</a>自动化测试与开发效率</h2>
<p>拒绝自动化测试的一大原因是开发<em>害怕</em>实施自动化测试会影响开发效率。毕竟，
研发除了业务代码之外，还要多维护一份测试用例代码。很多人下意识的会同意这种说法。</p>
<p>但是，实际上真的是这样吗？回想实际开发的过程，在完成一个需求的时候，
最频繁的操作会是什么？对于我而言会是<em>验证</em>操作。比如修改一处代码，
然后满怀希望的等待编译（可能耗时 10s 左右），然后在浏览器上模拟用户操作，
看程序的反应。这一套操作下来，个人估计至少需要 30s 左右。所以<em>人工验证</em>需要
30s 来一个功能点是否正常工作。人工验证是繁琐与无趣的，中间可能走神，
这样需要时间会更长。</p>
<p>如果换做用自动化测试的话，一个单元测试耗费的时间是毫秒级的，
一个 E2E 测试用例的时间大概在 1s 左右。在一次人工验证的时间中，
通过自动化测试我们能验证多少功能点呢？只跑 E2E 测试，
我们都至少能够验证 30 几个功能点。
况且 E2E 测试是自动化测试中最耗费时间的一类测试用例了，
自动化测试的效率对于人工验证的效率是数量级上的提升的。
另外，很多框架为了最小化繁琐操作，都自带了 <code>watch</code> 功能。
当检测到代码改变，自动运行相关的测试用例。基本上，
在修改代码后的<strong>几秒</strong>之内就能够知道代码修改<strong>对整个项目的影响</strong>。
这是人工验证无法做到的。</p>
<p>另外，自动化测试会使开发在整个研发的工作流中，不用在工具之间切来切去。
只用在代码编辑器与命令行中就可以知道修改代码的结果。
这会使开发更加专注于编写逻辑，不受“上下文”切换的影响。</p>
<p>自动化测试将开发中最频繁操作的效率提升了一个数量级。
付出的是仅仅几分钟时间设计一个测试用例。</p>
<h2 id="自动化测试与调试效率"><a class="header-anchor" href="#自动化测试与调试效率">¶</a>自动化测试与调试效率</h2>
<p>在调试中最难的问题莫过于找到问题的原因。如果没有测试用例的话，
我们可能会通过在有疑问的地方打日志的方式来找出问题。
对于一个较大型的程序而言，涉及到的代码可能横跨几个文件，好几个方法，
打日志的方法非常盲目，属于最后的手段。</p>
<p>但是如果有测试用例覆盖的话，DEBUG 会容易很多。
如果程序出现了问题，而同时某个测试用例没有通过。
可以直接怀疑相关的代码出现了问题。
修正代码使测试用例通过，bug 就修完了。
不再有到处打 <code>console.log</code> 来寻找问题在哪的操作。</p>
<p>即使，当所有测试用例都通过，程序仍然出现了 bug。这说明当前测试用例没有完全覆盖需·求。
此时，我们用 bug 的复现方法编写一个一定会失败的测试用例。
然后调整代码使这个测试用例通过。这样，不仅在调试过程中借助了自动化工具提升了体验，
而且更重要的是，测试用例可以保证这个 bug 永远不会再次出现。</p>
<h2 id="自动化测试与可维护性"><a class="header-anchor" href="#自动化测试与可维护性">¶</a>自动化测试与可维护性</h2>
<p>代码的可维护性与很多因素有关。如架构设计的合理性，模块之间是否存在耦合等等。
由于业务多变难以预测，几乎很少能够<em>一次性</em>的写出既符合需求又易于扩展的代码。
因此，在开发过程中，不断对代码进行<a href="https://en.wikipedia.org/wiki/Code_refactoring">重构</a>，
优化代码结构是提高项目可维护性的必经之路。</p>
<p>从定义而言，<em>重构</em>要求代码的改动不能改变软件的功能。然而，现实并不是乌托邦。
有时，代码几经接手，原需求已经不可考；有时，代码充斥着<a href="https://blog.codinghorror.com/code-smells/">坏味道</a>，
我们已经无法理解代码的职责是什么。在这种情况下，
我们无法保证代码能够被安全重构。</p>
<p>重构对于项目健康而言是必要的，那么如何保证在安全的情况下重构呢？
——完整的测试用例。测试用例就像合同一样，保证了一个单元的输入输出的正确性。
单元的用户不关心单元内部的实现逻辑，只需要单元的输入输出符合预期即可。
如果一个单元有完整的测试用例覆盖的话，我们在单元内部任意调整代码结构，
只要能够保证测试通过，我们都能够认为重构是安全的。因此，Martin Fowler
在<a href="https://book.douban.com/subject/33400354/">《重构——改善既有代码的设计》</a>
中提到了单元测试是重构的基础。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>自动化测试是提高软件设计质量与可靠性的良好手段。在现代的软件开发中，
软件代码与测试用例代码是同样重要的。在大型开源项目中，如 Node.js 中，
实现任何新特性或者修复 bug 都会被<a href="https://github.com/nodejs/node/blob/master/doc/guides/contributing/pull-requests.md#step-6-test"><strong>要求附上</strong></a>相应的测试用例。
但是在实际工作中，推行自动化测试也许遇到一些阻力。希望借由本文能够消除一些对单元测试的误解。</p>
]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>Automated Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript初探（I）</title>
    <url>/2017/01/29/typescript-note-1/</url>
    <content><![CDATA[<p>TypeScript是微软开发的一种开源的编程语言。它脱胎于JavaScript，为了解决JavaScript用于大型工程时出现的问题。最近几年，由于移动互联网的爆发，web开发越来越复杂，新技术层出不穷。但是JavaScript却迟迟没有进步，其自身的语言短板使得开发web app变成一件非常有挑战性的事情。TypeScript于2012年发布，正如其官方网站所言，目标是成为“JavaScript that scales”。TypeScript推出了类型系统、类等一些特性，其中一些特性已经被引入到下一代JavaScript标准ES6。TypeScript也是知名web应用框架AngularJs 2的推荐编程语言。</p>
<span id="more"></span>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<p>TypeScript可以从<code>npm</code>中安装。下面的命令将会在全局范围内安装<code>typescript</code>。</p>
<pre><code>npm install -g typescript
</code></pre>
<h2 id="编译typescript"><a class="header-anchor" href="#编译typescript">¶</a>编译TypeScript</h2>
<p>网页中浏览器实际运行的是JavaScript代码，我们的TypeScript代码需要通过编译器编译到对应的JavaScript代码。假设我们要编译<code>a.ts</code>文件，下面的命令将会将<code>a.ts</code>编译为对应的JavaScript版本<code>a.js</code>。</p>
<pre><code>tsc a.ts
</code></pre>
<p>TypeScript编译的js文件兼容ES3标准。</p>
<h2 id="类型注记-type-annotation-let-hello-string-world"><a class="header-anchor" href="#类型注记-type-annotation-let-hello-string-world">¶</a>类型注记(Type Annotation)——let hello:string = “world”</h2>
<p>类型系统是TypeScript的杀手级特性。我们可以给各种变量，函数的返回值打上类型注记，限定这些变量或返回值的类型。编译器会在编译时对这些变量的类型进行检查。如果实际传入的参数类型不符合注记，编译器会产生错误警告。值得注意的是，尽管有错误警告，但是编译器仍然会将ts文件编译成js文件。只是程序的行为可能不会和想要的一样。</p>
<h2 id="接口-interface-interface-yakusoku-youshouldhavethis-any"><a class="header-anchor" href="#接口-interface-interface-yakusoku-youshouldhavethis-any">¶</a>接口（Interface）——interface Yakusoku{youShouldHaveThis:any}</h2>
<p>接口是代码与用户代码的约定，即用户代码应该拥有或者实现接口所要求的功能。在TypeScript中，接口作为约定，在编译时，编译器会对接口进行复杂的类型检查，例如检查传入的参数是否拥有接口所指示的属性；如果以object literal作为参数直接传入，编译器会检查是否有过多的属性在参数中。接口的使用可以为函数的正确调用提供一定的保证。至少，传入参数的属性名的正确性是可以保证的。</p>
<h2 id="类-class-class-oop"><a class="header-anchor" href="#类-class-class-oop">¶</a>类（class）——class OOP {…}</h2>
<p>ES6标准正式引入了类的概念。在一些传统的编程语言中如<code>C++</code>，OOP往往是基于类的（class-based）。而在JavaScript中，OOP是基于原型的（prototype-based）。两种方法那种更优尚存争议，但是基于类的OOP对于一些来自于<code>C++</code>、<code>Java</code>等编程语言的程序员来说更为友好。而且基于类的OOP也有许多的工程实践。为了兼容ES6的标准，TypeScript也引入了类。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>从数据的角度看React Hooks</title>
    <url>/2020/01/07/understand-react-hook-from-the-perspective-of-data/</url>
    <content><![CDATA[<p><a href="https://reactjs.org/docs/hooks-intro.html">React Hooks</a>在 2020 年已经不是前沿的概念了。
Hooks 已经可以很自然地融入日常工作中。在绝大部分情况下，
Hooks + Function Component 完全可以满足需求。
Hooks 的设计是非常有想象力的，说实话，在 Hooks 出现之前，
我完全想不出来有那么优雅的方式来将逻辑和 UI 组件融合在一起。
赞美之词先到这里，很多介绍 Hooks 的材料，包括官方文档都会以 Hooks
与其相对应的 Class-based Component 的功能的比较来入门 Hooks 的核心概念。
这令人看起来，Hooks 像是 Class-based Component 的<code>setState</code>与生命周期的延伸。
其实不然，Hooks 创造出了一种更加声明式的编程范式。</p>
<span id="more"></span>
<h2 id="从一个带建议的输入框说起"><a class="header-anchor" href="#从一个带建议的输入框说起">¶</a>从一个带建议的输入框说起</h2>
<p>带建议的输入框是非常常见的需求，例如 Google 的搜索建议。</p>
<p><img src="/2020/01/07/understand-react-hook-from-the-perspective-of-data/suggestion.gif" alt="a input with suggestion"></p>
<p>在这种需求中，一般而言后台会提供一个 API，
我们以用户输入作为关键字调用这个 API 来获取备选词的列表。
我们一起来使用 Class-based Component 来实现这个组件。为了简单起见，
我们实现输入框和建议列表，点击建议项回填到输入框暂时不实现。</p>
<p>首先，我们需要一个输入框和一个显示建议项的列表。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoComplete</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/07/understand-react-hook-from-the-perspective-of-data/2020-01-07-23-06-04.png" alt="demo"></p>
<p>然后，由于需要以近乎实时的方式给用户提供建议，
用受控组件的方式来管理用户输入是更好的选择。这里我们新增加了一个状态<code>keyword</code>
来保存用户的输入，增加了一个事件处理函数 <code>handleKeywordInput</code>。
将 <code>handleKeywordInput</code> 绑定在 <code>onChange</code> 事件之后，
我们的状态 <code>keyword</code> 就与用户输入同步了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoComplete</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">keyword</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleKeywordInput</span> = <span class="variable language_">this</span>.<span class="property">handleKeywordInput</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleKeywordInput</span>(<span class="params">keyword</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      keyword</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;this.state.input&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> this.handleKeywordInput(event.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">AutoComplete</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要获取建议项的列表。显然，最好的时机是<code>componentDidUpdate</code>生命周期。
同样为了简单期间，我们不调用真正的 API，用下面一个根据关键词来生成一个列表的函数来替代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchSuggestions</span>(<span class="params">keyword</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">repeatTime</span> =&gt;</span> keyword.<span class="title function_">repeat</span>(repeatTime)),</span><br><span class="line">        <span class="number">2000</span></span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个<s>伪</s>API 之后，我们需要一个新的状态<code>suggestions</code>来保存获取到的建议项，
并且使用<code>map</code>将这些建议项渲染出来。最终的代码就像这样。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoComplete</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">keyword</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">suggestions</span>: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleKeywordInput</span> = <span class="variable language_">this</span>.<span class="property">handleKeywordInput</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleKeywordInput</span>(<span class="params">keyword</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      keyword</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevState.<span class="property">keyword</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">keyword</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newSuggestions = <span class="keyword">await</span> <span class="title function_">fetchSuggestions</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">keyword</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">suggestions</span>: newSuggestions</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;this.state.keyword&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> this.handleKeywordInput(event.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.state.suggestions.map(suggestion =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;suggestion&#125;</span>&gt;</span>&#123;suggestion&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo 如下:</p>
<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="result" data-user="ayase-252" data-slug-hash="wvByMqP" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Suggestion CBC">
  <span>See the Pen <a href="https://codepen.io/ayase-252/pen/wvByMqP">
  Suggestion CBC</a> by Qingyu Deng (<a href="https://codepen.io/ayase-252">@ayase-252</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
<p>让我们回想一下设计组件的整个思考流程：</p>
<ul>
<li>首先，我们用了两个标签将组件的整体轮廓给画了出来；</li>
<li>然后，我们思考用户动作对数据的影响，因此，
我们新建了状态<code>keyword</code>与事件处理函数<code>handleKeywordInput</code>来实现受控组件；</li>
<li>接下来，我们<strong>为了获取</strong>建议列表，选择在 <code>componentDidUpdate</code>这个生命周期中调用 API。</li>
<li>最后，我们渲染建议列表。</li>
</ul>
<p>可以看到，我们的思路仍然是命令式的。因为我们需要获取建议列表，
所以我们要在组件的某个生命周期里去做这件事情。
这样的思路对于熟悉命令式的开发者而言是很自然的。但是，
如果我们从另外一个角度来看，是不是会有一些新的想法呢?</p>
<h2 id="数据依赖"><a class="header-anchor" href="#数据依赖">¶</a>数据依赖</h2>
<p>从需求来看，建议列表<code>suggestions</code>是我们通过向一个 API 输入关键词<code>keyword</code>获取的。从数据的关系来看，
建议列表<code>suggestions</code>就像是关键词<code>keyword</code>的<a href="https://stackoverflow.com/questions/14551845/what-is-satellite-information-in-data-structures">卫星数据</a>。
换句话说，<code>suggestions</code>是依赖的<code>keyword</code>。想起数据依赖，
熟悉 Hooks API 的同学可能会想起<code>useEffect</code>等 API 中的依赖数组。
没有错，这些 API 就是我们刻画数据依赖关系的核心。</p>
<h2 id="用-hooks-重写带建议的输入框"><a class="header-anchor" href="#用-hooks-重写带建议的输入框">¶</a>用 Hooks 重写带建议的输入框</h2>
<p>在上一节中，我们发现了<code>suggestions</code>依赖于<code>keyword</code>。
我们可以很方便地用<code>useEffect</code>来刻画这样的数据依赖关系。
现在，让我们用 Hooks 重写这个组件。</p>
<p>首先，我们仍然会有一个<code>keyword</code>状态与一个<code>suggestions</code>状态。然后，
为了表现两者的依赖关系，我们使用以<code>[keyword]</code>为依赖数组的 <code>useEffect</code>来<strong>自动地</strong>
在<code>keyword</code>改变的时候重新获取相对应的<code>suggestions</code>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AutoComplete</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ----- 数据逻辑</span></span><br><span class="line">  <span class="keyword">const</span> [keyword, setKeyword] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [suggestions, setSuggestions] = <span class="title function_">useState</span>([]);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">_fetchSuggestions</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newSuggestions = <span class="keyword">await</span> <span class="title function_">fetchSuggestions</span>(keyword);</span><br><span class="line">      <span class="title function_">setSuggestions</span>(newSuggestions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">_fetchSuggestions</span>();</span><br><span class="line">  &#125;, [keyword]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -----交互逻辑</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleKeywordInput</span>(<span class="params">keyword</span>) &#123;</span><br><span class="line">    <span class="title function_">setKeyword</span>(keyword);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;keyword&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> handleKeywordInput(event.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;suggestions.map((suggestion, idx) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;idx&#125;</span>&gt;</span>&#123;suggestion&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo 如下：</p>
<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="result" data-user="ayase-252" data-slug-hash="ZEYrWwp" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Sugguestion with Hooks">
  <span>See the Pen <a href="https://codepen.io/ayase-252/pen/ZEYrWwp">
  Sugguestion with Hooks</a> by Qingyu Deng (<a href="https://codepen.io/ayase-252">@ayase-252</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
<p>我们回顾使用 Hooks 实现的思路。我们不再是<em>为了获取某个数据，然后在某个生命周期里执行某些操作去考虑。</em>
而是变成了，<em>因为某个数据 A 是依赖某个数据 B 的，所以在被依赖数据 B 改变的时候，我们也应该通过某些手段让数据 A 与数据 B 同步。</em>
我们不再刻意地去挑选同步的时机，刚渲染完也好（<code>componentDidMount</code>）、
刚更新完也好（<code>compnentDidUpdate</code>）甚至是任意时候，
只要框架能够保证这两个数据是同步的就行。正因为如此，在 Hooks 的作用下，
React 的数据管理能够变得更加声明化。</p>
<p>由于我们不必要去挑选数据同步时机，组件的生命周期这一概念消失了。
数据之间的交互与组件彻底解耦，因此，Hooks 带来了第二个好处——逻辑重用。
我们可以很轻松地将通过关键词来获取建议的逻辑封装起来变成一个自定义 Hook——<code>useSuggestions</code>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> useSuggestions &#123;</span><br><span class="line">  <span class="keyword">const</span> [keyword, setKeyword] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [suggestions, setSuggestions] = <span class="title function_">useState</span>([])</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">_fetchSuggestions</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newSuggestions = <span class="keyword">await</span> <span class="title function_">fetchSuggestions</span>(keyword)</span><br><span class="line">      <span class="title function_">setSuggestions</span>(newSuggestions)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">_fetchSuggestions</span>()</span><br><span class="line">  &#125;, [keyword])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setKeyword,</span><br><span class="line">    keyword,</span><br><span class="line">    suggestions</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AutoComplete</span> () &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;keyword, setKeyword, suggestions&#125; = <span class="title function_">useSuggestions</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleKeywordInput</span>(<span class="params">keyword</span>) &#123;</span><br><span class="line">    <span class="title function_">setKeyword</span>(keyword)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;keyword&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> handleKeywordInput(event.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           &#123;suggestions.map((suggestion, idx) =&gt; <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;idx&#125;</span>&gt;</span>&#123;suggestion&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以在其他组件上也可以用到根据关键词提供的建议列表了。甚至，
通过参数化请求方法，我们可以创造出更加通用的 Hook。
具体的组件不需要知道里面的数据之间的交互逻辑。
因此，Hooks 开创了可以将一些业务中典型的数据交互逻辑抽象出来的方法。这一方面，
无论是之前的 Class-based Component 或者 Vue 的响应式系统都是没能做到的。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>Hooks 强调数据之间的依赖关系，在 Hooks 的框架下：</p>
<ul>
<li>相关联的数据可以自动地同步；</li>
<li>Hooks 是独立于组件的；</li>
</ul>
<p>前者免除了我们需要手动同步相关联数据的需要，抹除了组件生命周期的存在意义；
后者可以将业务中典型的数据交互逻辑抽象出来应用于其他组件中。通过 Hooks，
我们实现组件的思路得以更加向声明式与数据驱动靠近。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>解决图的动态连接性问题：Union-Find算法</title>
    <url>/2018/07/31/union-find/</url>
    <content><![CDATA[<p>图是一种非常有用的数据结构。很多问题可以看作是图来处理，如迷宫、网络等等。有的时候，我们需要寻找图的连通分量。如<a href="https://leetcode.com/problems/accounts-merge/description/">LeetCode的721题（账号整合）</a>，解法的中心思路就是把Email看作是图中的节点，通过动态的增加边（把在同一个账户中的Email连接起来），最后读出图中的所有连通分量。这里，我们介绍一种专门处理图的动态连接性问题的算法——Union-Find。</p>
<span id="more"></span>
<p><em>关于Union-Find算法，在Robert Sedgewick等所著的《Algorithms 4 ed.》的1.5节有图文并茂的描述，有兴趣的话可以参阅。</em></p>
<h2 id="中心思想"><a class="header-anchor" href="#中心思想">¶</a>中心思想</h2>
<p>对于图的动态连接性问题，我们最关心的问题是：图中节点间之间是否存在路径（节点是否处于同一个连通分量中）。对于图的动态变化，我们允许动态地添加边，但是不允许删除边。因此，定义API如下：</p>
<table>
<thead>
<tr>
<th>API签名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bool connected(int p, int q)</code></td>
<td>节点<code>p</code>与节点<code>q</code>是否连通</td>
</tr>
<tr>
<td><code>void union(int p, int q)</code></td>
<td>将节点<code>p</code>与节点<code>q</code>连接起来</td>
</tr>
<tr>
<td><code>int find(int p)</code></td>
<td>寻找<code>p</code>处于哪一个连通分量中</td>
</tr>
</tbody>
</table>
<p>很显然，对于<code>connected</code>方法，只要检查<code>p</code>与<code>q</code>是否处于一个连通分量中就行，实现很直观：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="comment"># To be implemented</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Union-Find算法的核心在于<code>union</code>方法与<code>find</code>方法的实现上，根据侧重操作的不同可以演变为三种不同的版本Quick-Find, Quick-Union与Weighted-Union。</p>
<h2 id="quick-find"><a class="header-anchor" href="#quick-find">¶</a>Quick-Find</h2>
<p>Quick-Find算法是理解起来最简单直接的Union-Find算法。核心思想就是通过一个数组持续地追踪节点处在的连通分量。实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuickFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, numNode</span>):</span><br><span class="line">        <span class="comment"># _id数组表示的是各个节点的连通分量号</span></span><br><span class="line">        self._<span class="built_in">id</span> = <span class="built_in">list</span>(<span class="built_in">range</span>(numNode))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        pId = self.find(p)</span><br><span class="line">        qId = self.find(q)</span><br><span class="line">        <span class="comment"># 将所有处于q所在连通分量的节点放在p所在的连通分量中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self._<span class="built_in">id</span>)):</span><br><span class="line">            <span class="keyword">if</span> self._<span class="built_in">id</span>[i] == qId：</span><br><span class="line">                self._<span class="built_in">id</span>[i] = pId</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">return</span> self._<span class="built_in">id</span>[p]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过分析这个简单的实现，不难看出为什么它叫Quick-Find版本。<code>find</code>操作仅仅需要返回<code>_id</code>数组中所储存的数，时间复杂度为常数，即$O(1)$。但是对于<code>union</code>操作，假设节点数为$N$，它每次都需要遍历所有的节点，因此时间复杂度为$O(N)$。对于动态变化非常多的图，Quick-Find版本的性能就会比较低了。我们有什么办法能够提高<code>union</code>操作的性能呢？</p>
<h2 id="quick-union"><a class="header-anchor" href="#quick-union">¶</a>Quick-Union</h2>
<p>联想到对于元素插入频繁的情况，链表的表现要比数组来的好。因此我们可以模拟一个“链表”，准确来说是一颗树，把属于同一连通分量的元素放在一棵树中，用这棵树的根节点作为连通分量的编号。在这种想法下，我们可以实现Quick-Union：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuickUnion</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, numNode</span>):</span><br><span class="line">        <span class="comment"># parent数组表示各个节点的父节点</span></span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(numNode))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="comment"># 找到p所在连通分量（树）的根节点</span></span><br><span class="line">        pRoot = self.find(p)</span><br><span class="line">        qRoot = self.find(q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将p树的根节点接在q树的根节点下</span></span><br><span class="line">        self.parent[pRoot] = qRoot</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="comment"># 寻找p树的根节点</span></span><br><span class="line">        last = p</span><br><span class="line">        <span class="keyword">while</span> self.parent[last] != last:</span><br><span class="line">            last = self.parent[last]</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>
<p>从上面的实现可以看出，<code>union</code>除去寻找根节点的所需的耗时，只需要一个将一棵树的根节点放在另外一棵树的根节点下的操作，是常数时间，因此<code>union</code>操作的时间复杂度取决于<code>find</code>操作，但是<code>find</code>操作需要从指定节点遍历到根节点，在最坏情况下需要$O(N)$的时间。</p>
<pre><code>对于有4个节点的图的最坏情况

         A
        /
       B
      /
     C
    /
   D
如果find(D)的话需要遍历所有的节点。
</code></pre>
<p>Quick-Union版本的<code>find</code>操作效率变得比较低。但是我们可以看到，<code>find</code>的最坏情况就是需要从树的叶子节点遍历到根节点，所需要的步数就是树的高度。如果我们有办法去降低树的高度，<code>find</code>操作效率就会提升。所幸，我们可以用几条代码就可以提高Quick-Union的性能。</p>
<h2 id="weighted-union"><a class="header-anchor" href="#weighted-union">¶</a>Weighted-Union</h2>
<p>为了使树的高度降低，在整合两颗树的时候，把较小的树放在较大的树的下面是比较好的。因此，为了实时地掌握树的规模（树的节点数），我们增加一个数组去追踪这一情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedUnion</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, numNode</span>):</span><br><span class="line">        <span class="comment"># parent数组表示各个节点的父节点</span></span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(numNode))</span><br><span class="line">        <span class="comment"># size数组表示以某个节点形成的树包含的节点数</span></span><br><span class="line">        self.size = [<span class="number">1</span>] * numNode</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="comment"># 找到p所在连通分量（树）的根节点</span></span><br><span class="line">        pRoot = self.find(p)</span><br><span class="line">        qRoot = self.find(q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果p树的节点比q树多，将q树接在p树的下面</span></span><br><span class="line">        <span class="keyword">if</span> self.size[pRoot] &gt;= self.size[qRoot]:</span><br><span class="line">            self.parent[qRoot] = pRoot</span><br><span class="line">            self.size[pRoot] += self.size[qRoot]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.parent[pRoot] = qRoot</span><br><span class="line">            self.size[qRoot] += self.size[pRoot]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="comment"># 寻找p树的根节点</span></span><br><span class="line">        last = p</span><br><span class="line">        <span class="keyword">while</span> self.parent[last] != last:</span><br><span class="line">            last = self.parent[last]</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>
<p>可以看到Weighted-Union版本的代码只比Quick-Union版本的代码多6行，但是由于小树接在大树规则的限制下，形成的树的高度要降低很多。可以证明其<code>union</code>操作以及<code>find</code>操作的时间复杂度是$O(\log N)$。对数阶的复杂度说明这已经是一个比较实用算法了。</p>
<p>然而我们还可以进一步缩减树的高度，理想情况下，我们希望树的高度为1，这样的话，<code>find</code>操作就可以以近乎常数时间得到树的根节点。理想情况在我们目前实现的版本中是不可能的，但是如果我们能够在运行的过程中动态地压缩非根节点到根节点的路径的话，是可以进一步降低树的高度的。</p>
<h2 id="带路径压缩的weighted-union"><a class="header-anchor" href="#带路径压缩的weighted-union">¶</a>带路径压缩的Weighted-Union</h2>
<p>注意到<code>find</code>的遍历操作，我们遍历了从指定节点到根节点路径上的所有节点，我们最后也得到了根节点。为了下一次遍历的时候不用再重复一遍这条路径。我们直接将这些节点接到根节点的下面。这仅仅需要添加一个循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedUnionWithPathCompression</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, numNode</span>):</span><br><span class="line">        <span class="comment"># 与WeightedUnion相同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="comment"># 与WeightedUnion相同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="comment"># 寻找p树的根节点</span></span><br><span class="line">        last = p</span><br><span class="line">        <span class="keyword">while</span> self.parent[last] != last:</span><br><span class="line">            last = self.parent[last]</span><br><span class="line">        root = last</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再遍历一遍压缩指定节点到根节点路径上所有节点到根节点的路径</span></span><br><span class="line">        last = p</span><br><span class="line">        <span class="keyword">while</span> last != root:</span><br><span class="line">            tempLast = self.parent[last]</span><br><span class="line">            self[last] = root</span><br><span class="line">            last = tempLast</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>可以证明带路径压缩版本的<code>union</code>与<code>find</code>操作的平摊时间复杂度近乎为$O(1)$。</p>
<h2 id="各种版本的union-find的时间复杂度汇总"><a class="header-anchor" href="#各种版本的union-find的时间复杂度汇总">¶</a>各种版本的Union-Find的时间复杂度汇总</h2>
<table>
<thead>
<tr>
<th>版本</th>
<th><code>union</code></th>
<th><code>find</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Quick-Find</td>
<td>$O(N)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>Quick-Union</td>
<td>最坏$O(N)$</td>
<td>最坏$O(N)$</td>
</tr>
<tr>
<td>Weighted-Union</td>
<td>$O(\log N)$</td>
<td>$O(\log N)$</td>
</tr>
<tr>
<td>Weighted-Union with Data Compression</td>
<td>平摊接近$O(1)$</td>
<td>平摊接近 $O(1)$</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>图的动态连通性问题是非常多实际问题的抽象，这里介绍的Union-Find算法将会是解决这一类问题的利器。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Graph</tag>
        <tag>Union-Find</tag>
        <tag>Dynamic Connectivity</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jest进行单元测试</title>
    <url>/2018/12/09/unit-test-with-jest/</url>
    <content><![CDATA[<p><a href="https://jestjs.io/">Jest</a>是Facebook开发的一款JavaScript测试框架。我之前做单元测试一直使用的是<a href="https://mochajs.org/">Mocha</a>测试框架与<a href="https://www.chaijs.com/">Chai</a>断言库。之前在好几个地方看到了Jest测试框架，心生好奇学习了一下。</p>
<span id="more"></span>
<h2 id="jest框架"><a class="header-anchor" href="#jest框架">¶</a>Jest框架</h2>
<p>Jest框架标榜&quot;Delightful JavaScript Testing&quot;，提供零配置、快速反馈与快照测试功能。</p>
<p>零配置方面，Jest本身就是测试框架、断言库、Mock框架与测试覆盖率检查工具的结合体。而Mocha仅仅是测试框架。要在Mocha里配置出与Jest相同的功能的话需要自行安装像Chai断言库、<a href="https://sinonjs.org/">Sinon.js</a>框架与<a href="https://istanbul.js.org/">istanbul</a>测试覆盖率检查。所以说Jest可以说是开箱即用的。Jest在零配置的情况下就可以自动检测以<code>*.spec.js</code>，<code>*.test.js</code>模式命名的文件以及<code>__tests__</code>文件夹下的文件，把它们作为测试用例。</p>
<p>快速反馈方面，Jest的监视模式可以只运行与<strong>被改变的文件相关的测试用例</strong>，不需要把所有的测试用例重跑一遍。开发者可以快速知道改变代码的结果。</p>
<p>快照测试方面，Jest可以将某次函数的输出保存为一个快照，之后测试就把实际输出与快照中的输出进行对比，保证函数行为的一致性。</p>
<p>Jest可以分为测试框架、断言以及Mock三个部分。</p>
<h2 id="测试框架"><a class="header-anchor" href="#测试框架">¶</a>测试框架</h2>
<p>关注Jest的测试框架部分，主要是关注在Jest中测试用例如何写、如何组织的问题。Jest中，测试用例的写法与Mocha非常相似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">binaryStringToNumber</span> = binString =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^[01]+$/</span>.<span class="title function_">test</span>(binString)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">&#x27;Not a binary number.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(binString, <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;binaryStringToNumber&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&#x27;given an invalid binary string&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">test</span>(<span class="string">&#x27;composed of non-numbers throws CustomError&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">expect</span>(<span class="function">() =&gt;</span> <span class="title function_">binaryStringToNumber</span>(<span class="string">&#x27;abc&#x27;</span>)).<span class="title function_">toThrowError</span>(<span class="title class_">CustomError</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">test</span>(<span class="string">&#x27;with extra whitespace throws CustomError&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">expect</span>(<span class="function">() =&gt;</span> <span class="title function_">binaryStringToNumber</span>(<span class="string">&#x27;  100&#x27;</span>)).<span class="title function_">toThrowError</span>(<span class="title class_">CustomError</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&#x27;given a valid binary string&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">test</span>(<span class="string">&#x27;returns the correct number&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">expect</span>(<span class="title function_">binaryStringToNumber</span>(<span class="string">&#x27;100&#x27;</span>)).<span class="title function_">toBe</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Jest中，不必将<code>test</code>嵌入<code>describe</code>中。如果能使测试更简单的话，<code>test</code>也可以直接写在顶层。</p>
<h3 id="skip-only-each修饰符"><a class="header-anchor" href="#skip-only-each修饰符">¶</a>skip，only，each修饰符</h3>
<p><code>describe</code>与<code>test</code>可以连接<code>skip</code>，<code>only</code>，<code>each</code>修饰符。如<code>describe.skip('something', testFunction)</code>，会在测试时跳过这一个<code>describe</code>。<code>only</code>会使测试只运行指定的测试用例，这在某个测试用例出错Debug时非常好用。<code>each</code>修饰符可以执行多次参数不同的测试，它接受一个数组<code>table</code>和一个测试函数，<code>table</code>里的元素会作为参数传入测试函数。具体语法可以参见<a href="https://jestjs.io/docs/zh-Hans/api#describeeachtable-name-fn-timeout">文档</a>。</p>
<h3 id="beforeall-afterall-beforeeach-afterall钩子函数"><a class="header-anchor" href="#beforeall-afterall-beforeeach-afterall钩子函数">¶</a>beforeAll，afterAll，beforeEach，afterAll钩子函数</h3>
<p>Jest也支持在执行测试用例之前以及之后执行一些代码来做一些工作，像在测试前设置好测试数据、在测试后清理测试数据。这些工作可以作为<code>beforeAll</code>、<code>afterAll</code>、<code>beforeEach</code>、<code>afterAll</code>的回调函数。</p>
<h2 id="断言"><a class="header-anchor" href="#断言">¶</a>断言</h2>
<p>Jest支持<code>expect</code>式的断言，像<code>expect(1).toBe(1)</code>，其中<code>toBe</code>就是断言部分。Jest支持很丰富的断言。</p>
<h3 id="相等断言"><a class="header-anchor" href="#相等断言">¶</a>相等断言</h3>
<p>断言两个基本类型的值相等使用<code>expect(val1).toBe(val2)</code>。注意<code>toBe</code>断言使用<code>Object.is()</code>判断相等。它与<code>==</code>以及<code>===</code>都有不同。相对<code>===</code>，<code>Object.is()</code>在<code>-0</code>, <code>+0</code>与<code>NaN</code>的判断上有所不同。</p>
<p>如果要断言数组或者Object相等，使用<code>toEqual</code>断言。它会递归地判断每个属性/元素是否是相等的。</p>
<h3 id="数字大小断言"><a class="header-anchor" href="#数字大小断言">¶</a>数字大小断言</h3>
<p>大小关系断言有<code>toBeGreaterThan</code>、<code>toBeGreaterThanOrEqual</code>、<code>toBeLessThan</code>、<code>toBeLessThanOrEqual</code>。名字很直白，不解释。</p>
<p>对于浮点数，不能使用<code>toBe</code>或者<code>toEqual</code>进行相等断言。Jest提供了<code>toBeCloseTo</code>断言，可以在忽略一定误差的情况下，断言浮点数相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;float equality&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">expect</span>(<span class="number">0.2</span> + <span class="number">0.1</span>).<span class="title function_">toBeCloseTo</span>(<span class="number">0.3</span>) <span class="comment">//pass</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="真值断言-truthiness"><a class="header-anchor" href="#真值断言-truthiness">¶</a>真值断言（Truthiness）</h3>
<p>Jest提供<code>toBeTruthy</code>与<code>toBeFalsy</code>断言被测试函数的返回结果在<code>if</code>中是真还是假。像：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;nonempty string should be true&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">expect</span>(<span class="string">&#x27;it is true&#x27;</span>).<span class="title function_">toBeTruthy</span>() <span class="comment">//pass</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Jest也提供<code>toBeNull</code>、<code>toBeUndefined</code>、<code>toBeDefined</code>针对性的断言<code>null</code>与<code>undefined</code>的情况。</p>
<h3 id="字符串相关"><a class="header-anchor" href="#字符串相关">¶</a>字符串相关</h3>
<p>Jest提供<code>toMatch</code>断言被测试的字符串是否匹配给定正则表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;but there is a &quot;stop&quot; in Christoph&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">expect</span>(<span class="string">&#x27;Christoph&#x27;</span>).<span class="title function_">toMatch</span>(<span class="regexp">/stop/</span>) <span class="comment">// pass</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h3>
<p>要断言数组中包含某个子项可以使用<code>toContain</code>断言。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shoppingList = [</span><br><span class="line">  <span class="string">&#x27;diapers&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;kleenex&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;trash bags&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;paper towels&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beer&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;购物清单（shopping list）里面有啤酒（beer）&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">expect</span>(shoppingList).<span class="title function_">toContain</span>(<span class="string">&#x27;beer&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="抛出异常"><a class="header-anchor" href="#抛出异常">¶</a>抛出异常</h3>
<p>要断言对函数的某些操作会抛出异常可以使用<code>toThrow</code>断言。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;throws on octopus&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">expect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">drinkFlavor</span>(<span class="string">&#x27;octopus&#x27;</span>);</span><br><span class="line">  &#125;).<span class="title function_">toThrow</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="not修饰符"><a class="header-anchor" href="#not修饰符">¶</a>not修饰符</h3>
<p><code>not</code>修饰符可以把所有的断言反向，像<code>expect(1).not.toBe(2)</code>。</p>
<p>Jest提供的断言不止上面提到那么多。常用到的还有像断言长度的<code>toHaveLength</code>，断言对象有某个属性以及属性的值的<code>toHaveProperty</code>。更多断言的可以参见<a href="https://jestjs.io/docs/zh-Hans/expect">Expect文档</a>。</p>
<h2 id="mock"><a class="header-anchor" href="#mock">¶</a>Mock</h2>
<p>如果目前正在开发的模块存在依赖，比如某个函数需要一个随机产生的结果。假如依赖模块没有开发完成或者结果不可预知，我们是无法测试我们的模块的。为了解开开发模块与依赖模块在测试上的耦合，我们可以使用Mock功能去模拟被依赖模块的行为，比如规定某个函数调用时返回某些值。此时测试我们开发的模块就与被依赖模块的实际逻辑无关，实现了测试上的解耦。</p>
<p>这一部分比较复杂，我会在另外一篇文章来介绍这一部分。</p>
<h2 id="踩坑部分"><a class="header-anchor" href="#踩坑部分">¶</a>踩坑部分</h2>
<p>这里是我将一个用Vue编写的项目从Mocha转到Jest时踩的一些坑，算是笔记吧。</p>
<h3 id="automatic-mock不支持引用路径带有alias"><a class="header-anchor" href="#automatic-mock不支持引用路径带有alias">¶</a>Automatic mock不支持引用路径带有alias</h3>
<p><code>@</code>是Vue项目中<code>src</code>目录的<code>alias</code>（通过<code>jest.config.js</code>的<code>moduleNameMapper</code>指定）。如果尝试使用<code>alias</code>指定Automatic mock的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Module</span> <span class="keyword">from</span> <span class="string">&#x27;@/src/libs/module&#x27;</span></span><br><span class="line">jest.<span class="title function_">mock</span>(<span class="string">&#x27;@src/libs/module&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上述会报错。目前的解决方案是<a href="https://github.com/facebook/jest/issues/1290">jest issue #1290</a>提到的用Manual mock。这个方式有用，但是过了那么多年可能有更好的做法。</p>
<h3 id="vscode-jest与vue-cli-3脚手架生成的项目整合"><a class="header-anchor" href="#vscode-jest与vue-cli-3脚手架生成的项目整合">¶</a>vscode-jest与Vue CLI 3脚手架生成的项目整合</h3>
<p><code>vscode-jest</code>是一款VS Code的插件，它可以在文件保存时使用Jest的监视模式进行单元测试。但是对于Vue CLI 3生成的项目，<code>vscode-js</code>原生的配置无法使用。为了使<code>vscode-jest</code>有用我们需要做一些额外的工作。下面假设已经通过<code>vue add @vue/unit-jest</code>安装了<code>@vue/cli-plugin-unit-jest</code>。</p>
<ol>
<li>在Workspace设置中将<code>jest.pathToJest</code>设置为<code>npm run test:unit</code>（使用npm）或者<code>yarn test:unit</code>（使用yarn）。</li>
<li>在<code>jest.config.js</code>里添加两行</li>
</ol>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.<span class="property">env</span>.<span class="property">VUE_CLI_BABEL_TARGET_NODE</span> = <span class="literal">true</span></span><br><span class="line">process.<span class="property">env</span>.<span class="property">VUE_CLI_BABEL_TRANSPILE_MODULES</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>执行<code>npx jest --clearCache</code></li>
</ol>
<p>在<a href="https://github.com/vuejs/vue-cli/issues/1879">vue-cli issue #1879</a>上有关于这个问题的讨论。如果没用可以尝试其他人提出的方法。</p>
]]></content>
      <categories>
        <category>Programming</category>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>单元测试</tag>
        <tag>Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的Provide与Inject机制</title>
    <url>/2018/11/24/vue-provide-and-inject/</url>
    <content><![CDATA[<p><code>Vue</code>中父组件到子组件的通信主要由子组件的<code>props</code>属性实现。但是在一些情况下，父组件无法直接向子组件的<code>props</code>传值。比如子组件通过父组件的<code>slot</code>进入父组件，父组件根本不知道子组件是谁，更不用说用子组件的<code>props</code>了。这时应该怎么办呢？<code>Vue</code>在<code>2.2.0</code>版本引入了<code>provide</code>与<code>inject</code>，正好适合处理这一情况。</p>
<span id="more"></span>
<h2 id="什么是provide与inject"><a class="header-anchor" href="#什么是provide与inject">¶</a>什么是provide与inject</h2>
<p>用<a href="https://cn.vuejs.org/v2/api/#provide-inject">文档</a>的话说：</p>
<blockquote>
<p><code>provide</code>/<code>inject</code>需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</p>
</blockquote>
<p>这就是说从父组件的<code>provide</code>属性传入一个对象，子组件（或者是孙组件，只要是子级组件）可以用<code>inject</code>属性接收父组件的<code>provide</code>属性。比如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// main.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c1</span> <span class="attr">message</span>=<span class="string">&quot;hello world&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">c2</span>&gt;</span><span class="tag">&lt;/<span class="name">c2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// c1.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: [<span class="string">&#x27;message&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">  provides () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="variable language_">this</span>.<span class="property">message</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// c2.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c2&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">inject</span>: [<span class="string">&#x27;message&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>main</code>组件会被渲染为:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>= <span class="string">&quot;c2&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>c1</code>组件在不清楚子组件是什么的情况下，将它的<code>props</code>中的<code>message</code>传给了<code>c2</code>组件。在这里<code>c1</code>组件就像是一个数据源一样，为子组件提供数据。但是，<code>c1</code>组件提供的数据仅在<code>c1</code>的子孙组件中可见，因此可以算作是有作用域限定的数据源。</p>
<h2 id="父到子孙组件方向的数据流"><a class="header-anchor" href="#父到子孙组件方向的数据流">¶</a>父到子孙组件方向的数据流</h2>
<p>父到子孙组件方向是<code>provide/inject</code>机制设计时的数据流方向。我们可能会猜想，在父组件中更改<code>provide</code>的值，子组件会响应式的发生改变。但是注意到文档中话。</p>
<blockquote>
<p>提示：<code>provide</code>和<code>inject</code>绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p>
</blockquote>
<p>这意味着，如果<code>provide</code>的值不是可监听对象时，在父组件中更改<code>provide</code>的值，子组件不会发生任何变化。比如模板仍然为上面那个例子的模板，<code>message</code>的值是一个<code>props</code>属性，不是可监听对象，如果我们在<code>c1</code>的<code>mounted</code>钩子函数里改变<code>message</code>的值。如:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// c1.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//...</span></span></span><br><span class="line"><span class="language-javascript">  mounted () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Opps, it would not be rendered&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件不会响应修改后的值。</p>
<p>但是如果<code>provide</code>的值是一个可监听对象呢？请看一下例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// c1.vue</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;hello world&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  provide () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">messageData</span>: <span class="variable language_">this</span>.<span class="property">$data</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  mounted () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;I can show in c2.&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">10000</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// c2.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c2&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; messageData.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">inject</span>: [<span class="string">&#x27;messageData&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时在<code>c1</code>挂载10s后，子组件将会显示<code>I can show in c2</code>。为什么呢？<code>c2</code>中<code>messageData</code>实际上就是<code>c1</code>实例的<code>this.$data</code>。而<code>this.$data</code>上有<code>message</code>的响应式<code>getter</code>与<code>setter</code>。所以<code>c2</code>的视图会被<code>message</code>的<code>dep</code>收集，因此在<code>c1</code>中更新<code>message</code>，<code>c2</code>的视图也会更新。如果对此处不熟悉，可以看一看关于<code>Vue</code>数据绑定的文章。</p>
<h2 id="vue的源码实现"><a class="header-anchor" href="#vue的源码实现">¶</a>Vue的源码实现</h2>
<p>首先我们来看<code>provide</code>与<code>inject</code>的初始化，在<code>src/core/instance/init.js</code>里，我们能够看到它们初始化的过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/core/instance/init.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">  <span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  <span class="title function_">initState</span>(vm)</span><br><span class="line">  <span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在一个组件内，<code>initInjections</code>是先于<code>initProvide</code>调用的，但是从整个组件树的初始化顺序来看，父组件的<code>initProvide</code>的调用要先于子组件的<code>initInjections</code>。为了理解上的方便，我们先来看<code>initProvide</code>。</p>
<h3 id="initprovide"><a class="header-anchor" href="#initprovide">¶</a>initProvide</h3>
<p><code>initProvide</code>定义在<code>src/core/instance/inject.js</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/inject.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initProvide</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> provide = vm.<span class="property">$options</span>.<span class="property">provide</span></span><br><span class="line">  <span class="keyword">if</span> (provide) &#123;</span><br><span class="line">    vm.<span class="property">_provided</span> = <span class="keyword">typeof</span> provide === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">      ? provide.<span class="title function_">call</span>(vm) <span class="comment">// 如果provide是函数，在本组件上调用</span></span><br><span class="line">      : provide</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initProvide</code>函数很简单，就是将组件的<code>provide</code>对象放到<code>vm._provided</code>中。这里兼顾了<code>provide</code>为函数与为对象两种情况。与文档中所述的一致：</p>
<blockquote>
<p>类型：
provide：<code>Object | () =&gt; Object</code></p>
</blockquote>
<p>注意到，<code>initProvide</code>方法中只是进行了简单的复制。在大多数情况下，如果要把父级的响应式属性作为<code>provide</code>，此时只有值被复制进去。Vue并没有对<code>_provided</code>属性做响应式处理（熟悉源码的同学应该知道<code>defineReactive</code>方法）。因此，<code>provide</code>是非响应式的。</p>
<h3 id="initinjections"><a class="header-anchor" href="#initinjections">¶</a>initInjections</h3>
<p><code>initInjections</code>定义同一个文件中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/inject.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initInjections</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">resolveInject</span>(vm.<span class="property">$options</span>.<span class="property">inject</span>, vm)</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 不会观察vm.key</span></span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(result).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不是`production`环境中，当试图更改inject的值时会报错。</span></span><br><span class="line">        <span class="title function_">defineReactive</span>(vm, key, result[key], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`Avoid mutating an injected value directly since the changes will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the provided component re-renders. `</span> +</span><br><span class="line">            <span class="string">`injection being mutated: &quot;<span class="subst">$&#123;key&#125;</span>&quot;`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(vm, key, result[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出现了一个<code>resolveInject</code>函数，还是在这个文件里:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/inject.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveInject</span> (<span class="attr">inject</span>: any, <span class="attr">vm</span>: <span class="title class_">Component</span>): ?<span class="title class_">Object</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (inject) &#123;</span><br><span class="line">    <span class="comment">// inject is :any because flow is not smart enough to figure out cached</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 如果支持Symbol</span></span><br><span class="line">    <span class="keyword">const</span> keys = hasSymbol</span><br><span class="line">      ? <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(inject).<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(inject, key).<span class="property">enumerable</span></span><br><span class="line">      &#125;)</span><br><span class="line">      : <span class="title class_">Object</span>.<span class="title function_">keys</span>(inject)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有inject中的key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = keys[i]</span><br><span class="line">      <span class="keyword">const</span> provideKey = inject[key].<span class="property">from</span></span><br><span class="line">      <span class="keyword">let</span> source = vm</span><br><span class="line">      <span class="comment">// 从本级的._provided中查找（注意到inject先于provide初始化，因此事实上是</span></span><br><span class="line">      <span class="comment">// 从父组件开始查找），如果本级没找到，就到父级的._provided中查找</span></span><br><span class="line">      <span class="keyword">while</span> (source) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (source.<span class="property">_provided</span> &amp;&amp; <span class="title function_">hasOwn</span>(source.<span class="property">_provided</span>, provideKey)) &#123;</span><br><span class="line">          result[key] = source.<span class="property">_provided</span>[provideKey]</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        source = source.<span class="property">$parent</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果整条链都没有找到，尝试使用`default`属性构建fallback值</span></span><br><span class="line">      <span class="keyword">if</span> (!source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;default&#x27;</span> <span class="keyword">in</span> inject[key]) &#123;</span><br><span class="line">          <span class="keyword">const</span> provideDefault = inject[key].<span class="property">default</span></span><br><span class="line">          result[key] = <span class="keyword">typeof</span> provideDefault === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">            ? provideDefault.<span class="title function_">call</span>(vm)</span><br><span class="line">            : provideDefault</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(<span class="string">`Injection &quot;<span class="subst">$&#123;key&#125;</span>&quot; not found`</span>, vm)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回result对象，它的key是inject中指定的key</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>resolveInject</code>是实现<code>provide/inject</code>的核心函数。它从父/祖父组件中把<code>provide</code>的值捕捉下来，之后<code>initInjections</code>利用这一结果，在自身组件上定义响应式属性。注意到在定义响应式属性之前，<code>toggleObserving(false)</code>。这意味着<code>inject</code>的值里面是没有<code>__ob__</code>的。也就是说，当<strong>更改<code>inject</code>的值会触发视图的改变</strong>，而<strong>更改<code>inject</code>对象的属性不会触发视图改变</strong>。当然，最佳实践是不要在子组件里更改<code>inject</code>。</p>
<p>纵观整个过程，<code>provide/inject</code>机制是非响应式的，即<code>provide</code>与<code>inject</code>之间没有绑定。具体的值是在<strong>子组件初始化</strong>过程中决定的。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p><code>provide/inject</code>提供了一种新的组件间通信的方法。它允许父组件向子孙组件间进行跨层级的数据分发。但是<code>provide/inject</code>是非响应式的，如果要子孙组件根据父组件的值进行改变，<code>provide/inject</code>机制不是一个好的选择。此时可以使用<code>Vuex</code>来管理状态。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://cn.vuejs.org/v2/api/#provide-inject">API - Vue.js</a></li>
<li><a href="https://segmentfault.com/a/1190000009054946">Vue源码分析之Observer</a></li>
</ol>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>「只要有爱，世界与我何干」——《天气之子》观后感</title>
    <url>/2019/11/01/weathering-with-you-review/</url>
    <content><![CDATA[<p>今天出门看了新海诚导演的新作《天气之子》，
回来的时候总感觉心中有种奇妙又说不清的感觉，
因此就写一篇类似影评的东西来梳理梳理这种感觉，
记录这次奇妙的观影经历吧。</p>
<span id="more"></span>
<blockquote>
<p>本篇日志将有大量剧透。</p>
</blockquote>
<p>诚哥电影的一个标签就是爱情故事，诚哥擅长制作各种各样的爱情故事。
然而诚哥的爱情故事不总是只有一种中心主题。比如《秒速五厘米》
诉说了一种带有缺憾的爱情；《你的名字。》讲述了「所有的相遇都是久别重逢」的爱情。
《天气之子》也不例外，而且这种爱情更为奔放，我称之为一种
「只要有爱，世界与我何干」的爱情。</p>
<h2 id="no-在剧情模式上没有创新"><a class="header-anchor" href="#no-在剧情模式上没有创新">¶</a>No，在剧情模式上没有创新</h2>
<p>如果你看过《你的名字》的话，也许你会产生一种既视感。是的，
《天气之子》的剧情模式与《你的名字》是大致相同的。
《你的名字》的剧情模式是：</p>
<ul>
<li>邂逅：身体交换；</li>
<li>关系发展：在身体交换时体验对方的生活；</li>
<li>产生情愫：在身体交换现象停止后，瀧前往三叶所在的城市寻找；</li>
<li>悲剧：三叶在彗星坠落事件中遇难；</li>
<li>逆天改命：通过口嚼酒回到三年前，修改三叶遇难的命运；</li>
<li>再邂逅：经过多年后，重新相遇；</li>
</ul>
<p>《天气之子》有着相似的剧情模式：</p>
<ul>
<li>邂逅：在麦当劳相遇，然后触发了一段解救阳菜的剧情；</li>
<li>关系发展：帆高与阳菜共同运营「晴女」；</li>
<li>产生情愫：帆高认识到自己喜欢阳菜；</li>
<li>悲剧：帆高由于持有枪械被调查，阳菜姐妹由于缺少监护人面临强制分离，阳菜由于操纵天气的能力消失，帆高被逮捕；</li>
<li>逆天改命：帆高逃出警察局，前往鸟居从天上带回了阳菜；</li>
<li>再邂逅：经过多年后，重新相遇；</li>
</ul>
<p>可以看到《天气之子》的剧情模式复制了大为成功的《你的名字》的剧情模式。
所以，观影过程中也许出现某种既视感是正常的。
我个人对于使用同样的剧情模式是有一点不满意的。
毕竟 3 年过去了，个人还是希望看到更多不一样的东西。</p>
<h2 id="yes-有不同的故事"><a class="header-anchor" href="#yes-有不同的故事">¶</a>Yes，有不同的故事</h2>
<p>每看一部动画或者电影，都是一种独特体验。
尽管剧情模式相同，然而观看《天气之子》的体验也是独特的。
《天气之子》的主题更加直接——「只要有我喜欢的人在，世界与我何干」，
非常唯我的立场。</p>
<h3 id="动画版的有轨电车问题"><a class="header-anchor" href="#动画版的有轨电车问题">¶</a>动画版的有轨电车问题</h3>
<p><a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E8%BD%A8%E7%94%B5%E8%BD%A6%E9%9A%BE%E9%A2%98">有轨电车问题</a>
是一个经典的道德两难问题。
《天气之子》中最主要的剧情冲突抽象起来就是一个有轨电车问题。
对这个问题的解答将会体现作者在个人利益与群体利益之间的偏好。</p>
<p>有轨电车问题是一个这样的问题。
有一辆刹车坏掉的电车，即将撞上前方轨道上的五个人，
所幸的是在电车前方有一个道岔，
如果你扳动这一道岔就可以让电车驶入备用轨道，但是备用轨道上有一个人。</p>
<p>在剧中，只要牺牲阳菜，东京就可以放晴。对应到有轨电车问题上就是，
电车前方是东京，而备用轨道上是阳菜。
我们可以很容易看到诚哥在这个问题上的抉择。扳什么道岔？让东京自生自灭吧。
对这个问题的解答，也就奠定了《天气之子》的主题——
「只要有我喜欢的人在，世界与我何干」。即便是与整个社会为敌，
我都要和你在一起。</p>
<h3 id="更加低潮的故事"><a class="header-anchor" href="#更加低潮的故事">¶</a>更加低潮的故事</h3>
<p>《天气之子》描述的是一个处于低潮的主人公们的故事，
我们可以看到故事的角色大多处于低潮，像失业、未成年、离家出走、
缺少收入、丧母、丧偶等等甚至还被警察调查、逮捕等等。
尽管在《你的名字》中三叶直接遇难了，但瀧依然是衣食无忧、不用担心生活的状态的。
所以我认为，《天气之子》的低潮更加的“低”。给人一种喘不过气来的感觉。</p>
<h3 id="更加-无谋-的故事"><a class="header-anchor" href="#更加-无谋-的故事">¶</a>更加“无谋”的故事</h3>
<p>《天气之子》的故事推进，我认为更加“无谋”一点。主人公们似乎没有思考，
没有选择地直接奔着结局前进。这给观众一种主人公是“铁头”的感觉。
当然，我在思考之后觉得也许是因为在当时的情景下，他们没有选择。
毕竟他们的人生是真的难啊。</p>
<h2 id="结论"><a class="header-anchor" href="#结论">¶</a>结论</h2>
<p>离《你的名字》3 年之后，诚哥交出新作《天气之子》。从观影体验上来说是值回票价的。
这里没有提电影的画面以及音乐，我认为没有必要提。
诚哥的作品这些元素的质量是业界顶尖的。
《天气之子》用与《你的名字》同样的模式，写出了一个不一样的，
更加直接与唯我的故事。我个人而言还挺吃这一套的。
希望诚哥下个作品能够带来一种更“新”的感觉。下一部作品我还会再去看的。</p>
]]></content>
      <categories>
        <category>Anime</category>
        <category>Life</category>
      </categories>
      <tags>
        <tag>新海诚</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2中为什么不要使用普通中间件</title>
    <url>/2018/11/26/why-not-use-common-middleware-in-koa2/</url>
    <content><![CDATA[<p>Koa2里支持两种中间件的写法，一种是使用ES7<code>async/await</code>语法的<strong>异步函数</strong>，这里我们称为<strong>异步中间件</strong>。一种是使用普通函数语法的<strong>普通中间件</strong>。尽管说官方支持两种写法，但是在实际应用中，我们可能不大常见普通中间件的写法。为什么呢？</p>
<span id="more"></span>
<blockquote>
<p>tl;dr</p>
<ol>
<li>普通中间件可以有，但没必要；</li>
<li>错误的普通中间件写法可能破坏洋葱模型；</li>
<li>正确的普通中间件的写法可能和想象中的有点不太一样。</li>
</ol>
</blockquote>
<h2 id="koa2的中间件洋葱模型"><a class="header-anchor" href="#koa2的中间件洋葱模型">¶</a>Koa2的中间件洋葱模型</h2>
<p>大家都知道Koa2的中间件的执行流类似洋葱，即请求会从第一个中间件开始然后暂停在<code>next</code>，接着执行第二个中间件，一直到最后一个中间件暂停在<code>next</code>。接着最后一个中间件从<code>next</code>恢复执行，执行完之后倒数第二个中间件从<code>next</code>的地方恢复执行，一直到第一个中间件从<code>next</code>恢复执行到完毕。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Application</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">middleware_1</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;middleware_1 before next&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;middleware_1 after next&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">middleware_2</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;middleware_2 before next&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;middleware_2 after next&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Application</span>()</span><br><span class="line">app.<span class="title function_">use</span>(middleware_1)</span><br><span class="line">app.<span class="title function_">use</span>(middleware_2)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有请求经过的时候，console会打印</span></span><br><span class="line"><span class="comment">// middleware_1 before next</span></span><br><span class="line"><span class="comment">// middleware_2 before next</span></span><br><span class="line"><span class="comment">// middleware_2 after next</span></span><br><span class="line"><span class="comment">// middleware_1 after next</span></span><br></pre></td></tr></table></figure>
<h2 id="koa2中间件洋葱模型的实现"><a class="header-anchor" href="#koa2中间件洋葱模型的实现">¶</a>Koa2中间件洋葱模型的实现</h2>
<p>这一部分我们简单介绍一下Koa2中间件洋葱模型的实现。当我们使用<code>app.use(middleware)</code>时，其实内部会将<code>middleware</code>推入一个数组保存:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// koa/lib/application.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">class</span> <span class="title class_">Application</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Emitter</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="title function_">use</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="comment">// if (typeof fn !== &#x27;function&#x27;) throw new TypeError(&#x27;middleware must be   a function!&#x27;);</span></span><br><span class="line">    <span class="comment">// if (isGeneratorFunction(fn)) &#123;</span></span><br><span class="line">    <span class="comment">//   deprecate(&#x27;Support for generators will be removed in v3. &#x27; +</span></span><br><span class="line">    <span class="comment">//             &#x27;See the documentation for examples of how to convert old middleware &#x27; +</span></span><br><span class="line">    <span class="comment">//             &#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;);</span></span><br><span class="line">    <span class="comment">//   fn = convert(fn);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// debug(&#x27;use %s&#x27;, fn._name || fn.name || &#x27;-&#x27;);</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">middleware</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略掉大量检查代码，<code>use</code>就做了一件事情，<code>this.middleware.push(fn)</code>。<code>this.middleware</code>是一个数组。</p>
<p>接下来，在<code>app.listen(3000)</code>的时候，<code>app.listen</code>会调用原生的<code>http</code>模块，然后使用<code>this.callback()</code>产生一个回调函数在请求到来的时候调用。接下来就是重头戏了，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title function_">compose</span>(<span class="variable language_">this</span>.<span class="property">middleware</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if (!this.listenerCount(&#x27;error&#x27;)) this.on(&#x27;error&#x27;, this.onerror);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleRequest</span> = (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// const ctx = this.createContext(req, res);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">handleRequest</span>(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>compose(this.middleware)</code>，它将中间件数组组合起来，然后返回一个执行函数<code>fn</code>，当调用执行函数时，如<code>fn(ctx)</code>时，<code>ctx</code>就会以洋葱模型被各个中间件所处理。<code>this.handleRequest</code>干的就是这么一件事，可以看源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>) &#123;</span><br><span class="line">  <span class="comment">// const res = ctx.res;</span></span><br><span class="line">  <span class="comment">// res.statusCode = 404;</span></span><br><span class="line">  <span class="comment">// const onerror = err =&gt; ctx.onerror(err);</span></span><br><span class="line">  <span class="comment">// const handleResponse = () =&gt; respond(ctx);</span></span><br><span class="line">  <span class="comment">// onFinished(res, onerror);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fnMiddleware</span>(ctx).<span class="title function_">then</span>(handleResponse).<span class="title function_">catch</span>(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点来看一下<code>compose</code>函数，它是实现洋葱模型的核心函数。</p>
<h3 id="compose函数"><a class="header-anchor" href="#compose函数">¶</a>compose函数</h3>
<p><code>compose</code>函数并不在<code>koa</code>包里，而是在<code>koa-compose</code>包中，是一个非常短小精悍的函数。源码地址在<a href="https://github.com/koajs/compose">这里</a>。我们只保留函数的核心部分如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = compose</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span> (middleware) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">context, next</span>) &#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span> (i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.<span class="property">length</span>) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到我们的中间件是如何调用的，比如上面第一个中间件其实是以<code>middleware_1(context, dispatch(1))</code>的形式调用的。函数中使用到了<code>Promise</code>来保证各个中间件按照洋葱模型执行。具体原理可以自行推导一下。</p>
<h2 id="一种错误的普通中间件写法"><a class="header-anchor" href="#一种错误的普通中间件写法">¶</a>一种错误的普通中间件写法</h2>
<p>下面是一种很流行的<strong>错误的</strong>普通中间件写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">one</span> = (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt; one&#x27;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;&lt; one&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">two</span> = (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt; two&#x27;</span>);</span><br><span class="line">  <span class="title function_">next</span>(); </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;&lt; two&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">three</span> = (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt; three&#x27;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;&lt; three&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(one);</span><br><span class="line">app.<span class="title function_">use</span>(two);</span><br><span class="line">app.<span class="title function_">use</span>(three);</span><br></pre></td></tr></table></figure>
<p>代码出自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2017/08/koa.html">Koa 框架教程</a>。上面的代码是说明中间件栈（和洋葱模型差不多）这个概念。但是，代码成立的条件是<strong>所有中间件都是同步的</strong>。当其中有任意一个中间件是<code>async</code>的时候，代码就可能不是按照洋葱模型执行了。阮一峰老师提到**如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。**可能就是因为这一原因。</p>
<p>下面是一个例子，在响应请求的过程中，我们需要记录响应请求所需要的时间，然后对用户传过来的密码进行哈希之后保存。对密码加盐哈希是一个非常耗时的操作，一般使用异步，这里为了模拟耗时，使用<code>setTimeout</code>延时1s。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logger</span> = (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;logger starts&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> entryTime = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">  <span class="keyword">const</span> msUsed = <span class="keyword">new</span> <span class="title class_">Date</span>() - entryTime</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`response takes <span class="subst">$&#123;msUsed&#125;</span>ms.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hashPassword</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hashing user password&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;password has been hashed&#x27;</span>)</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;password secure&quot;</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hashing password after next&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>()</span><br><span class="line">app.<span class="title function_">use</span>(logger)</span><br><span class="line">app.<span class="title function_">use</span>(hashPassword)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>当在浏览器里请求<code>localhost:3000</code>时，console输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logger starts</span><br><span class="line">Hashing user password</span><br><span class="line">response takes 1ms.</span><br><span class="line">password has been hashed</span><br><span class="line">Hashing password after next</span><br></pre></td></tr></table></figure>
<p>可以看到<code>logger</code>的<code>next</code>之下的部分先于<code>hashPassword</code>的<code>next</code>之下的部分执行，这破坏了洋葱模型。</p>
<h3 id="这种写法问题出现在哪？"><a class="header-anchor" href="#这种写法问题出现在哪？">¶</a>这种写法问题出现在哪？</h3>
<p>注意到，<code>next()</code>返回的是一个<code>Promise</code>，在上面的写法中没有对这个<code>Promise</code>做任何处理，直觉告诉我们，这里极有可能会出现异步调用的顺序问题。事实上也是如此，我们来一步一步的分析问题产生的原因。</p>
<p>首先，<code>logger</code>函数被调用，传入的<code>next</code>参数是<code>dispatch(1)</code>。当<code>logger</code>执行<code>next()</code>，实际上<code>dispatch(1)</code>被执行。注意到<code>dispatch(i)</code>的返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br></pre></td></tr></table></figure>
<p>这个<code>Promise.resolve</code>是什么东西呢？</p>
<blockquote>
<p>Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；如果传入的value本身就是promise对象，则该对象作为Promise.resolve方法的返回值返回；否则以该值为成功状态返回promise对象。</p>
</blockquote>
<p>很不巧，接下来的<code>fn</code>，即<code>hashPassword</code>是一个<code>async</code>函数，当运行<code>async</code>函数时，遇见<code>await</code>，函数会暂停执行并立即返回一个状态为<code>pending</code>的<code>Promise</code>。也就是说，<code>hashPassword</code>在第一个<code>await</code>的时候就返回了一个<code>pending</code>的<code>Promise</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hashPassword</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hashing user password&#x27;</span>)</span><br><span class="line">  &gt;&gt; <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;password has been hashed&#x27;</span>)</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;password secure&quot;</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hashing password after next&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后问题就大了，<code>Promise.resolve(fn(context, dispatch.bind(null, i + 1)))</code>一看到<code>fn</code>返回了一个<code>Promise</code>，接着就把这个<code>Promise</code>再返回给上层。此时<code>dispatch(1)</code>结束。<code>logger</code>看到<code>next()</code>返回，然后兴高采烈地执行接下来的语句。此时<code>hashPassword</code>仍然在紧张地哈希用户的密码，甚至还没有调用<code>next()</code>函数。洋葱模型就此打乱。</p>
<h3 id="那么正确的普通中间件的写法是？"><a class="header-anchor" href="#那么正确的普通中间件的写法是？">¶</a>那么正确的普通中间件的写法是？</h3>
<p>既然官方支持普通中间件，那么正确的写法是什么呢？根据<a href="https://github.com/koajs/koa#middleware">文档</a>一个正确的普通中间件的写法应该是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Middleware normally takes two parameters (ctx, next), ctx is the context for one request,</span></span><br><span class="line"><span class="comment">// next is a function that is invoked to execute the downstream middleware. It returns a Promise with a then function for running code after completion.</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">next</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到正确处理<code>next()</code>返回的<code>Promise</code>才能够保证洋葱模型的正确性。。。</p>
<p>既然要处理<code>Promise</code>的话…为什么不直接使用<code>async/await</code>呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码明显要比普通中间件的写法要好看一点。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>文章可能标题党了一点，Koa里面的中间件非得是<code>async</code>函数吗？当然不是。但是普通中间件的写法，第一可能和你想象中的不一样，第二还要略懂中间件实现的原理才能够正确实现普通中间件。如果坚信自己会用普通中间件，just do it!</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve">Promise.resolve() - MDN</a></li>
</ol>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
</search>
